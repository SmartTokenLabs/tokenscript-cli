{"version":3,"names":["version","logger","Logger","_constructorGuard","ModifiersBytes","calldata","memory","storage","ModifiersNest","checkModifier","type","name","indexOf","throwArgumentError","parseParamType","param","allowIndexed","originalParam","throwError","i","replace","newNode","parent","node","state","allowType","indexed","length","c","allowParams","verifyType","components","child","allowName","allowArray","sibling","push","readArray","populate","object","params","key","defineReadOnly","FormatTypes","Object","freeze","sighash","minimal","full","json","paramTypeArray","RegExp","ParamType","constructor","constructorGuard","errors","UNSUPPORTED_OPERATION","operation","this","match","arrayLength","parseInt","arrayChildren","fromObject","baseType","_isParamType","format","result","undefined","map","comp","JSON","parse","stringify","String","join","static","value","fromString","isParamType","ParamTypify","parseParams","allowIndex","splitNesting","Fragment","_isFragment","isFragment","FunctionFragment","EventFragment","ConstructorFragment","ErrorFragment","trim","split","substring","anonymous","inputs","input","isEventFragment","verifyIdentifier","regexParen","forEach","modifier","warn","parseGas","gas","comps","BigNumber","from","parseModifiers","constant","payable","stateMutability","console","log","verifyState","toNumber","isConstructorFragment","parens","outputs","output","toString","isFunctionFragment","returns","checkForbidden","fragment","sig","isErrorFragment","regexIdentifier","accum","depth","offset","checkResultErrors","checkErrors","path","Array","isArray","childPath","slice","error","Coder","localName","dynamic","_throwError","message","Writer","wordSize","_data","_dataLength","_padding","Uint8Array","data","hexConcat","_writeData","appendWriter","writer","concat","writeBytes","bytes","arrayify","paddingOffset","_getValue","BUFFER_OVERRUN","writeValue","writeUpdatableValue","Reader","coerceFunc","allowLoose","_offset","hexlify","consumed","coerce","_coerceFunc","_peekBytes","loose","alignedLength","Math","ceil","subReader","readBytes","readValue","AddressCoder","super","defaultValue","encode","getAddress","decode","reader","hexZeroPad","toHexString","AnonymousCoder","coder","pack","coders","values","arrayValues","unique","INVALID_ARGUMENT","argument","staticWriter","dynamicWriter","updateFuncs","index","dynamicOffset","updateFunc","baseOffset","func","unpack","baseReader","offsetReader","code","uniqueNames","reduce","Error","defineProperty","enumerable","get","ArrayCoder","defaultChild","count","checkArgumentCount","BooleanCoder","isZero","DynamicBytesCoder","BytesCoder","FixedBytesCoder","size","NullCoder","AddressZero","HashZero","NumberCoder","signed","v","maxUintValue","MaxUint256","mask","bounds","gt","lt","add","One","mul","NegativeOne","Zero","toTwos","fromTwos","UnicodeNormalizationForm","Utf8ErrorReason","errorFunc","reason","badCodepoint","ignoreFunc","BAD_PREFIX","UNEXPECTED_CONTINUE","o","OVERRUN","replaceFunc","OVERLONG","Utf8ErrorFuncs","ignore","getUtf8CodePoints","onError","extraLength","overlongMask","res","j","nextChar","MISSING_CONTINUE","OUT_OF_RANGE","UTF16_SURROGATE","toUtf8Bytes","str","form","current","checkNormalize","normalize","charCodeAt","c2","pair","_toUtf8String","codePoints","codePoint","fromCharCode","toUtf8String","toUtf8CodePoints","StringCoder","TupleCoder","types","paramTypeBytes","paramTypeNumber","AbiCoder","_getCoder","component","_getWordSize","_getReader","_getWriter","getDefaultValue","defaultAbiCoder","id","text","keccak256","textData","atob","btoa","flat","array","flatDeep","arr","call","val","fromEntries","decode_arithmetic","pos","u16","symbol_count","total","acc","skip","pos_payload","read_width","read_buffer","read_bit","N","FULL","pow","HALF","QRTR","MASK","register","symbols","low","range","floor","start","end","mid","a","b","x","read_payload","read_compressed_payload","read_counts","n","next","read_ascending","read_deltas","read_member_array","lookup","vX","vN","read_mapped_map","ret","w","read_linear_table","read_replacement_table","read_zero_terminated_array","read_transposed","m","fill","dx","dy","ys","_","j_dy","y","read_emoji_trie","sorted","sort","read","branches","keys","set","Set","temp","valid","fe0f","save","check","getData","r","VALID","IGNORED","MAPPED","EMOJI_ROOT","HYPHEN","UNDERSCORE","explode_cp","filter_fe0f","cps","filter","cp","ens_normalize_post_check","label","lastIndexOf","every","err","ens_normalize","emoji_filter","reverse","emoji","consume_emoji_reversed","pop","has","toUpperCase","nfc","fromCodePoint","s","eaten","_a","saved","stack","find","splice","Zeros","checkComponent","ensNameSplit","last","d","namehash","dnsEncode","__awaiter","thisArg","_arguments","P","generator","adopt","resolve","Promise","reject","fulfilled","step","e","rejected","done","then","apply","padding","hexPadRight","padOffset","hexTrue","hexFalse","domainFieldTypes","chainId","verifyingContract","salt","domainFieldNames","checkString","domainChecks","toLowerCase","getBaseEncoder","width","boundsUpper","boundsLower","encodeType","fields","TypedDataEncoder","deepCopy","links","parents","subtypes","field","encoder","primaryTypes","t","checkCircular","found","subtype","primaryType","st","_types","getEncoder","_encoderCache","_getEncoder","subEncoder","encodedType","unshift","encodeData","hashStruct","hash","_visit","callback","visit","domain","domainFields","EIP712Domain","hashDomain","resolveName","shallowCopy","ensCache","isHexString","domainValues","domainTypes","typesWithDomain","LogDescription","Description","TransactionDescription","ErrorDescription","Indexed","_isIndexed","BuiltinErrors","signature","wrapAccessError","property","wrap","Interface","fragments","abi","getStatic","bucket","deploy","functions","events","address","hexDataSlice","eventFragment","getFunction","nameOrSignatureOrSighash","getSighash","matching","f","getEvent","nameOrSignatureOrTopic","topichash","getEventTopic","getError","_decodeParams","_abiCoder","_encodeParams","encodeDeploy","decodeErrorResult","encodeErrorResult","decodeFunctionData","functionFragment","encodeFunctionData","decodeFunctionResult","errorArgs","errorName","errorSignature","selector","builtin","CALL_EXCEPTION","method","encodeFunctionResult","encodeFilterTopics","UNEXPECTED_ARGUMENT","topics","encodeTopic","encodeEventLog","dataTypes","dataValues","decodeEventLog","topicHash","expected","nonIndexed","resultIndexed","resultNonIndexed","nonIndexedIndex","indexedIndex","parseTransaction","tx","args","parseLog","topic","parseError","hexData","errorFragment","_isInterface","ForkEvent","_isForkEvent","Provider","checkAbstract","getFeeData","block","gasPrice","resolveProperties","getBlock","getGasPrice","catch","lastBaseFeePerGas","maxFeePerGas","maxPriorityFeePerGas","baseFeePerGas","addListener","eventName","listener","on","removeListener","off","_isProvider","allowedTransactionKeys","forwardErrors","INSUFFICIENT_FUNDS","NONCE_EXPIRED","REPLACEMENT_UNDERPRICED","Signer","getBalance","blockTag","_checkProvider","provider","getTransactionCount","estimateGas","transaction","checkTransaction","sendTransaction","populateTransaction","signedTx","signTransaction","getChainId","network","getNetwork","all","to","hasEip1559","feeData","nonce","gasLimit","UNPREDICTABLE_GAS_LIMIT","results","_isSigner","VoidSigner","_fail","signMessage","_signTypedData","connect","resolver","nameOrPromise","resolveAddresses","paramType","makeError","contract","overrides","signer","override","resolved","resolvedAddress","interface","ro","accessList","accessListify","intrinsic","roValue","customData","ccipReadEnabled","leftovers","l","buildPopulate","buildEstimate","signerOrProvider","addContractWait","wait","bind","confirmations","receipt","logs","event","parsed","eventSignature","blockHash","getTransaction","transactionHash","getTransactionReceipt","buildCall","collapseSimple","deployTransaction","_deployed","buildSend","txRequest","buildDefault","getEventTag","RunningEvent","tag","_listeners","once","item","removeAllListeners","listeners","listenerCount","run","argsCopy","setTimeout","prepareEvent","getEmit","ErrorRunningEvent","FragmentRunningEvent","contractInterface","decodeError","WildcardRunningEvent","BaseContract","addressOrName","isSigner","isProvider","uniqueFilters","filters","uniqueSignatures","callStatic","signatures","getContractAddress","isInterface","deployed","_deployedPromise","getCode","contractAddress","fallback","attach","isIndexed","_normalizeRunningEvent","runningEvent","_runningEvents","_getRunningEvent","_checkRunningEvents","emit","_wrappedEmits","_wrapEvent","_addEventListener","wrappedEmit","queryFilter","fromBlockOrBlockhash","toBlock","fromBlock","getLogs","Contract","BaseX","alphabet","charAt","_alphabetMap","source","digits","carry","base","string","k","_leader","q","TypeError","byte","Base58","sha256","update","digest","isRenetworkable","ethDefaultProvider","providers","options","providerList","InfuraProvider","infura","EtherscanProvider","etherscan","AlchemyProvider","alchemy","PocketProvider","pocket","CloudflareProvider","cloudflare","AnkrProvider","ankr","FallbackProvider","quorum","renetwork","etcDefaultProvider","url","JsonRpcProvider","homestead","ensAddress","_defaultProvider","ropsten","classicMordor","networks","unspecified","mainnet","morden","testnet","rinkeby","kovan","goerli","kintsugi","sepolia","classic","classicMorden","classicTestnet","classicKotti","xdai","matic","maticmum","optimism","arbitrum","bnb","bnbt","standard","defaultProvider","getUrl","href","request","headers","body","skipFetchSetup","mode","cache","credentials","redirect","referrer","fetchOptions","opts","response","fetch","arrayBuffer","statusCode","status","statusMessage","statusText","staller","duration","bodyify","isBytesLike","unpercent","_fetchData","connection","processFunc","attemptLimit","throttleLimit","assertArgument","throttleCallback","throttleSlotInterval","errorPassThrough","allow304","timeout","allowGzip","user","password","allowInsecureAuthentication","authorization","base64Encode","reData","dataMatch","base64Decode","SERVER_ERROR","requestBody","requestMethod","flatHeaders","header","runningTimeout","timer","promise","TIMEOUT","cancel","clearTimeout","runningFetch","attempt","location","tryAgain","stall","retryAfter","random","serverError","throttleRetry","race","fetchJson","processJsonFunc","updated","hasContentType","poll","ceiling","interval","retryLimit","oncePoll","onceBlock","ALPHABET","ALPHABET_MAP","z","polymodStep","pre","prefixChk","prefix","chk","words","LIMIT","__decode","lowered","uppered","wordChars","decodeUnsafe","arguments","convert","inBits","outBits","pad","bits","maxV","toWordsUnsafe","toWords","fromWordsUnsafe","fromWords","bech32","Formatter","formats","getDefaultFormats","bigNumber","hex","number","strictData","allowNull","blockNumber","transactionIndex","uint256","creates","raw","transactionRequest","receiptLog","arrayOf","logIndex","root","gasUsed","logsBloom","cumulativeGasUsed","effectiveGasPrice","parentHash","timestamp","difficulty","miner","extraData","transactions","blockWithTransactions","transactionResponse","filterLog","removed","boolean","allowFalsish","strict","callAddress","hexValue","hexDataLength","_block","author","_difficulty","networkId","byzantium","checkKey","checkValue","nullValue","replaceValue","MAX_CCIP_REDIRECTS","checkTopic","serializeTopics","deserializeTopics","isForkEvent","getTime","Date","PollableEvents","Event","_lastBlockNumber","_inflight","pollable","coinInfos","symbol","p2pkh","p2sh","ilk","bytes32ify","base58Encode","matcherIpfs","matchers","_parseString","_parseBytes","getIpfsLink","link","numPad","padded","bytesPad","encodeBytes","datas","byteCount","Resolver","formatter","supportsWildcard","_supportsEip2544","eq","_fetch","parameters","parseBytes","_fetchBytes","_getAddress","coinType","hexBytes","coinInfo","getAvatar","linkage","content","avatar","getText","scheme","owner","_resolvedAddress","addr","tokenId","tokenOwner","balance","metadataUrl","metadata","imageUrl","image","ipfs","getContentHash","ipns","swarm","skynet","urlSafe","keyBytes","defaultFormatter","nextPollId","BaseProvider","_events","_emitted","disableCcipRead","getFormatter","anyNetwork","detectNetwork","_networkPromise","_ready","knownNetwork","_maxInternalBlockNumber","_maxFilterBlockRange","_pollingInterval","_fastQueryDate","_network","UNKNOWN_ERROR","ready","NETWORK_ERROR","ccipReadFetch","urls","sender","errorMessages","errorMessage","_getInternalBlockNumber","maxAge","_internalBlockNumber","internalBlockNumber","respTime","reqTime","checkInternalBlockNumber","perform","networkError","_setFastBlockNumber","pollId","runners","pollingInterval","abs","previousBlockNumber","eventBlockNumber","runner","minFromBlock","resetEventsBlock","polling","currentNetwork","_fastBlockNumber","_fastBlockNumberPromise","detectedNetwork","_poller","setInterval","_bootstrapPoll","clearInterval","_getFastBlockNumber","now","getBlockNumber","waitForTransaction","_waitForTransaction","replaceable","cancelFuncs","alreadyDone","minedHandler","lastBlockNumber","startBlock","scannedBlock","replaceHandler","mined","getBlockWithTransactions","ti","TRANSACTION_REPLACED","cancelled","replacement","_wrapTransaction","unref","_getBlockTag","getStorageAt","position","p","expectedHash","returnedHash","confirms","signedTransaction","hexTx","_getTransactionRequest","_getFilter","_call","redirects","txSender","urlsOffset","urlsLength","urlsData","u","callbackSelector","ccipResult","_getBlock","blockHashOrBlockTag","includeTransactions","blockWithTxs","getEtherPrice","getResolver","currentName","_getResolver","addrData","lookupAddress","resolverAddr","nameOrAddress","resolverAddress","NOT_IMPLEMENTED","_startEvent","_stopEvent","stopped","eventTag","errorGas","spelunk","requireData","checkError","responseText","getResult","payload","getLowerCase","JsonRpcSigner","addressOrIndex","connectUnchecked","UncheckedJsonRpcSigner","_address","_index","send","accounts","sendUncheckedTransaction","fromAddress","estimate","hexlifyTransaction","ACTION_REJECTED","action","messageData","_legacySignMessage","populated","_TypedDataEncoder","resolveNames","getPayload","unlock","networkOrReady","_nextId","_cache","_eventLoopCache","_uncachedDetectNetwork","getSigner","getUncheckedSigner","listAccounts","jsonrpc","prepareRequest","_startPending","_pendingFilter","self","pendingFilter","filterId","hashes","seq","allowExtra","allowed","checkProperties","EthersAdapter","getWalletEthersProvider","chainConfig","async","ethersProvider","getEthersProvider","chain","contractAddr","outputTypes","getEthersContractInstance","arg","waitForConfirmation","switchChain","txNumber","transactionReceipt","txLink","explorer","abiData","convertedType","internalType","ethers.providers.JsonRpcProvider","getRpcUrl","rpc","getChain","appCss","AppRoot","hostRef","tsEngine","TokenScriptEngine","getWalletAdapter","ipfsGateway","tabs","negotiator","Client","issuers","uiOptions","containerElement","openingHeading","walletProvider","getWalletProvider","loadConnections","getConnectedWalletData","createUiInstance","getUi","initialize","updateUI","connectCallback","CHAIN_CONFIG","children","host","querySelector","classList","remove","tabHeader","addTab","tokenScript","emulator","query","URLSearchParams","document","search","tab","createElement","is","app","tabId","tabTitle","getLabel","appendChild","showTab","connectEmulatorSocket","tabIds","showTsLoader","getElementById","style","display","hideTsLoader","tsId","getTokenScript","loadTokenScriptFromFile","getTokenScriptFromUrl","file","files","FileReader","onload","evt","target","loadTokenScript","onerror","readAsText","loadTokenscript","alert","webSocket","WebSocket","URL","onopen","onmessage","render","h","class","alt","src","closable","loadingSpinnerCss","LoadingSpinner","color","borderColor","startTabCss","StartTab","processUrlLoad","queryStr","tsHost","origin","openTokenScriptTab","componentDidLoad","tsFile","htmlFor","marginRight","selected","onClick","accept","onChange","tabHeaderItemCss","title","closeTab"],"sources":["../engine-js/node_modules/@ethersproject/abi/lib.esm/_version.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/fragments.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/coders/address.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/coders/array.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/coders/boolean.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/coders/bytes.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/coders/null.js","../engine-js/node_modules/@ethersproject/constants/lib.esm/addresses.js","../engine-js/node_modules/@ethersproject/constants/lib.esm/hashes.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/coders/number.js","../engine-js/node_modules/@ethersproject/strings/lib.esm/_version.js","../engine-js/node_modules/@ethersproject/strings/lib.esm/utf8.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/coders/string.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/coders/tuple.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/abi-coder.js","../engine-js/node_modules/@ethersproject/hash/lib.esm/id.js","../engine-js/node_modules/@ethersproject/hash/lib.esm/_version.js","../engine-js/node_modules/@ethersproject/base64/lib.esm/base64.js","../engine-js/node_modules/@ethersproject/hash/lib.esm/ens-normalize/decoder.js","../engine-js/node_modules/@ethersproject/hash/lib.esm/ens-normalize/include.js","../engine-js/node_modules/@ethersproject/hash/lib.esm/ens-normalize/lib.js","../engine-js/node_modules/@ethersproject/hash/lib.esm/namehash.js","../engine-js/node_modules/@ethersproject/hash/lib.esm/typed-data.js","../engine-js/node_modules/@ethersproject/abi/lib.esm/interface.js","../engine-js/node_modules/@ethersproject/abstract-provider/lib.esm/_version.js","../engine-js/node_modules/@ethersproject/abstract-provider/lib.esm/index.js","../engine-js/node_modules/@ethersproject/abstract-signer/lib.esm/_version.js","../engine-js/node_modules/@ethersproject/abstract-signer/lib.esm/index.js","../engine-js/node_modules/@ethersproject/contracts/lib.esm/_version.js","../engine-js/node_modules/@ethersproject/contracts/lib.esm/index.js","../engine-js/node_modules/@ethersproject/basex/lib.esm/index.js","../engine-js/node_modules/@ethersproject/sha2/lib.esm/_version.js","../engine-js/node_modules/@ethersproject/sha2/lib.esm/sha2.js","../engine-js/node_modules/@ethersproject/networks/lib.esm/_version.js","../engine-js/node_modules/@ethersproject/networks/lib.esm/index.js","../engine-js/node_modules/@ethersproject/web/lib.esm/_version.js","../engine-js/node_modules/@ethersproject/web/lib.esm/geturl.js","../engine-js/node_modules/@ethersproject/web/lib.esm/index.js","../engine-js/node_modules/bech32/index.js","../engine-js/node_modules/@ethersproject/providers/lib.esm/_version.js","../engine-js/node_modules/@ethersproject/providers/lib.esm/formatter.js","../engine-js/node_modules/@ethersproject/providers/lib.esm/base-provider.js","../engine-js/node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js","../engine-js/node_modules/ethers/lib.esm/_version.js","../engine-js/node_modules/ethers/lib.esm/ethers.js","../engine-js/src/wallet/EthersAdapter.ts","./src/components/app/app.css?tag=app-root","./src/components/app/app.tsx","./src/components/atoms/loading-spinner.css?tag=loading-spinner&encapsulation=shadow","./src/components/atoms/loading-spinner.tsx","./src/components/tabs/start-tab.css?tag=start-tab","./src/components/tabs/start-tab.tsx","./src/components/tabs/tab-header-item.css?tag=tab-header-item&encapsulation=shadow","./src/components/tabs/tab-header-item.tsx"],"sourcesContent":["export const version = \"abi/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nconst _constructorGuard = {};\nlet ModifiersBytes = { calldata: true, memory: true, storage: true };\nlet ModifiersNest = { calldata: true, memory: true };\nfunction checkModifier(type, name) {\n    if (type === \"bytes\" || type === \"string\") {\n        if (ModifiersBytes[name]) {\n            return true;\n        }\n    }\n    else if (type === \"address\") {\n        if (name === \"payable\") {\n            return true;\n        }\n    }\n    else if (type.indexOf(\"[\") >= 0 || type === \"tuple\") {\n        if (ModifiersNest[name]) {\n            return true;\n        }\n    }\n    if (ModifiersBytes[name] || name === \"payable\") {\n        logger.throwArgumentError(\"invalid modifier\", \"name\", name);\n    }\n    return false;\n}\n// @TODO: Make sure that children of an indexed tuple are marked with a null indexed\nfunction parseParamType(param, allowIndexed) {\n    let originalParam = param;\n    function throwError(i) {\n        logger.throwArgumentError(`unexpected character at position ${i}`, \"param\", param);\n    }\n    param = param.replace(/\\s/g, \" \");\n    function newNode(parent) {\n        let node = { type: \"\", name: \"\", parent: parent, state: { allowType: true } };\n        if (allowIndexed) {\n            node.indexed = false;\n        }\n        return node;\n    }\n    let parent = { type: \"\", name: \"\", state: { allowType: true } };\n    let node = parent;\n    for (let i = 0; i < param.length; i++) {\n        let c = param[i];\n        switch (c) {\n            case \"(\":\n                if (node.state.allowType && node.type === \"\") {\n                    node.type = \"tuple\";\n                }\n                else if (!node.state.allowParams) {\n                    throwError(i);\n                }\n                node.state.allowType = false;\n                node.type = verifyType(node.type);\n                node.components = [newNode(node)];\n                node = node.components[0];\n                break;\n            case \")\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let child = node;\n                node = node.parent;\n                if (!node) {\n                    throwError(i);\n                }\n                delete child.parent;\n                node.state.allowParams = false;\n                node.state.allowName = true;\n                node.state.allowArray = true;\n                break;\n            case \",\":\n                delete node.state;\n                if (node.name === \"indexed\") {\n                    if (!allowIndexed) {\n                        throwError(i);\n                    }\n                    node.indexed = true;\n                    node.name = \"\";\n                }\n                if (checkModifier(node.type, node.name)) {\n                    node.name = \"\";\n                }\n                node.type = verifyType(node.type);\n                let sibling = newNode(node.parent);\n                //{ type: \"\", name: \"\", parent: node.parent, state: { allowType: true } };\n                node.parent.components.push(sibling);\n                delete node.parent;\n                node = sibling;\n                break;\n            // Hit a space...\n            case \" \":\n                // If reading type, the type is done and may read a param or name\n                if (node.state.allowType) {\n                    if (node.type !== \"\") {\n                        node.type = verifyType(node.type);\n                        delete node.state.allowType;\n                        node.state.allowName = true;\n                        node.state.allowParams = true;\n                    }\n                }\n                // If reading name, the name is done\n                if (node.state.allowName) {\n                    if (node.name !== \"\") {\n                        if (node.name === \"indexed\") {\n                            if (!allowIndexed) {\n                                throwError(i);\n                            }\n                            if (node.indexed) {\n                                throwError(i);\n                            }\n                            node.indexed = true;\n                            node.name = \"\";\n                        }\n                        else if (checkModifier(node.type, node.name)) {\n                            node.name = \"\";\n                        }\n                        else {\n                            node.state.allowName = false;\n                        }\n                    }\n                }\n                break;\n            case \"[\":\n                if (!node.state.allowArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.allowArray = false;\n                node.state.allowName = false;\n                node.state.readArray = true;\n                break;\n            case \"]\":\n                if (!node.state.readArray) {\n                    throwError(i);\n                }\n                node.type += c;\n                node.state.readArray = false;\n                node.state.allowArray = true;\n                node.state.allowName = true;\n                break;\n            default:\n                if (node.state.allowType) {\n                    node.type += c;\n                    node.state.allowParams = true;\n                    node.state.allowArray = true;\n                }\n                else if (node.state.allowName) {\n                    node.name += c;\n                    delete node.state.allowArray;\n                }\n                else if (node.state.readArray) {\n                    node.type += c;\n                }\n                else {\n                    throwError(i);\n                }\n        }\n    }\n    if (node.parent) {\n        logger.throwArgumentError(\"unexpected eof\", \"param\", param);\n    }\n    delete parent.state;\n    if (node.name === \"indexed\") {\n        if (!allowIndexed) {\n            throwError(originalParam.length - 7);\n        }\n        if (node.indexed) {\n            throwError(originalParam.length - 7);\n        }\n        node.indexed = true;\n        node.name = \"\";\n    }\n    else if (checkModifier(node.type, node.name)) {\n        node.name = \"\";\n    }\n    parent.type = verifyType(parent.type);\n    return parent;\n}\nfunction populate(object, params) {\n    for (let key in params) {\n        defineReadOnly(object, key, params[key]);\n    }\n}\nexport const FormatTypes = Object.freeze({\n    // Bare formatting, as is needed for computing a sighash of an event or function\n    sighash: \"sighash\",\n    // Human-Readable with Minimal spacing and without names (compact human-readable)\n    minimal: \"minimal\",\n    // Human-Readable with nice spacing, including all names\n    full: \"full\",\n    // JSON-format a la Solidity\n    json: \"json\"\n});\nconst paramTypeArray = new RegExp(/^(.*)\\[([0-9]*)\\]$/);\nexport class ParamType {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use fromString\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new ParamType()\"\n            });\n        }\n        populate(this, params);\n        let match = this.type.match(paramTypeArray);\n        if (match) {\n            populate(this, {\n                arrayLength: parseInt(match[2] || \"-1\"),\n                arrayChildren: ParamType.fromObject({\n                    type: match[1],\n                    components: this.components\n                }),\n                baseType: \"array\"\n            });\n        }\n        else {\n            populate(this, {\n                arrayLength: null,\n                arrayChildren: null,\n                baseType: ((this.components != null) ? \"tuple\" : this.type)\n            });\n        }\n        this._isParamType = true;\n        Object.freeze(this);\n    }\n    // Format the parameter fragment\n    //   - sighash: \"(uint256,address)\"\n    //   - minimal: \"tuple(uint256,address) indexed\"\n    //   - full:    \"tuple(uint256 foo, address bar) indexed baz\"\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            let result = {\n                type: ((this.baseType === \"tuple\") ? \"tuple\" : this.type),\n                name: (this.name || undefined)\n            };\n            if (typeof (this.indexed) === \"boolean\") {\n                result.indexed = this.indexed;\n            }\n            if (this.components) {\n                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));\n            }\n            return JSON.stringify(result);\n        }\n        let result = \"\";\n        // Array\n        if (this.baseType === \"array\") {\n            result += this.arrayChildren.format(format);\n            result += \"[\" + (this.arrayLength < 0 ? \"\" : String(this.arrayLength)) + \"]\";\n        }\n        else {\n            if (this.baseType === \"tuple\") {\n                if (format !== FormatTypes.sighash) {\n                    result += this.type;\n                }\n                result += \"(\" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \")\";\n            }\n            else {\n                result += this.type;\n            }\n        }\n        if (format !== FormatTypes.sighash) {\n            if (this.indexed === true) {\n                result += \" indexed\";\n            }\n            if (format === FormatTypes.full && this.name) {\n                result += \" \" + this.name;\n            }\n        }\n        return result;\n    }\n    static from(value, allowIndexed) {\n        if (typeof (value) === \"string\") {\n            return ParamType.fromString(value, allowIndexed);\n        }\n        return ParamType.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ParamType.isParamType(value)) {\n            return value;\n        }\n        return new ParamType(_constructorGuard, {\n            name: (value.name || null),\n            type: verifyType(value.type),\n            indexed: ((value.indexed == null) ? null : !!value.indexed),\n            components: (value.components ? value.components.map(ParamType.fromObject) : null)\n        });\n    }\n    static fromString(value, allowIndexed) {\n        function ParamTypify(node) {\n            return ParamType.fromObject({\n                name: node.name,\n                type: node.type,\n                indexed: node.indexed,\n                components: node.components\n            });\n        }\n        return ParamTypify(parseParamType(value, !!allowIndexed));\n    }\n    static isParamType(value) {\n        return !!(value != null && value._isParamType);\n    }\n}\n;\nfunction parseParams(value, allowIndex) {\n    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));\n}\nexport class Fragment {\n    constructor(constructorGuard, params) {\n        if (constructorGuard !== _constructorGuard) {\n            logger.throwError(\"use a static from method\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"new Fragment()\"\n            });\n        }\n        populate(this, params);\n        this._isFragment = true;\n        Object.freeze(this);\n    }\n    static from(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            return Fragment.fromString(value);\n        }\n        return Fragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (Fragment.isFragment(value)) {\n            return value;\n        }\n        switch (value.type) {\n            case \"function\":\n                return FunctionFragment.fromObject(value);\n            case \"event\":\n                return EventFragment.fromObject(value);\n            case \"constructor\":\n                return ConstructorFragment.fromObject(value);\n            case \"error\":\n                return ErrorFragment.fromObject(value);\n            case \"fallback\":\n            case \"receive\":\n                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?\n                return null;\n        }\n        return logger.throwArgumentError(\"invalid fragment object\", \"value\", value);\n    }\n    static fromString(value) {\n        // Make sure the \"returns\" is surrounded by a space and all whitespace is exactly one space\n        value = value.replace(/\\s/g, \" \");\n        value = value.replace(/\\(/g, \" (\").replace(/\\)/g, \") \").replace(/\\s+/g, \" \");\n        value = value.trim();\n        if (value.split(\" \")[0] === \"event\") {\n            return EventFragment.fromString(value.substring(5).trim());\n        }\n        else if (value.split(\" \")[0] === \"function\") {\n            return FunctionFragment.fromString(value.substring(8).trim());\n        }\n        else if (value.split(\"(\")[0].trim() === \"constructor\") {\n            return ConstructorFragment.fromString(value.trim());\n        }\n        else if (value.split(\" \")[0] === \"error\") {\n            return ErrorFragment.fromString(value.substring(5).trim());\n        }\n        return logger.throwArgumentError(\"unsupported fragment\", \"value\", value);\n    }\n    static isFragment(value) {\n        return !!(value && value._isFragment);\n    }\n}\nexport class EventFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"event\",\n                anonymous: this.anonymous,\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"event \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.anonymous) {\n                result += \"anonymous \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return EventFragment.fromString(value);\n        }\n        return EventFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (EventFragment.isEventFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"event\") {\n            logger.throwArgumentError(\"invalid event object\", \"value\", value);\n        }\n        const params = {\n            name: verifyIdentifier(value.name),\n            anonymous: value.anonymous,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            type: \"event\"\n        };\n        return new EventFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let match = value.match(regexParen);\n        if (!match) {\n            logger.throwArgumentError(\"invalid event string\", \"value\", value);\n        }\n        let anonymous = false;\n        match[3].split(\" \").forEach((modifier) => {\n            switch (modifier.trim()) {\n                case \"anonymous\":\n                    anonymous = true;\n                    break;\n                case \"\":\n                    break;\n                default:\n                    logger.warn(\"unknown modifier: \" + modifier);\n            }\n        });\n        return EventFragment.fromObject({\n            name: match[1].trim(),\n            anonymous: anonymous,\n            inputs: parseParams(match[2], true),\n            type: \"event\"\n        });\n    }\n    static isEventFragment(value) {\n        return (value && value._isFragment && value.type === \"event\");\n    }\n}\nfunction parseGas(value, params) {\n    params.gas = null;\n    let comps = value.split(\"@\");\n    if (comps.length !== 1) {\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature\", \"value\", value);\n        }\n        if (!comps[1].match(/^[0-9]+$/)) {\n            logger.throwArgumentError(\"invalid human-readable ABI signature gas\", \"value\", value);\n        }\n        params.gas = BigNumber.from(comps[1]);\n        return comps[0];\n    }\n    return value;\n}\nfunction parseModifiers(value, params) {\n    params.constant = false;\n    params.payable = false;\n    params.stateMutability = \"nonpayable\";\n    value.split(\" \").forEach((modifier) => {\n        switch (modifier.trim()) {\n            case \"constant\":\n                params.constant = true;\n                break;\n            case \"payable\":\n                params.payable = true;\n                params.stateMutability = \"payable\";\n                break;\n            case \"nonpayable\":\n                params.payable = false;\n                params.stateMutability = \"nonpayable\";\n                break;\n            case \"pure\":\n                params.constant = true;\n                params.stateMutability = \"pure\";\n                break;\n            case \"view\":\n                params.constant = true;\n                params.stateMutability = \"view\";\n                break;\n            case \"external\":\n            case \"public\":\n            case \"\":\n                break;\n            default:\n                console.log(\"unknown modifier: \" + modifier);\n        }\n    });\n}\nfunction verifyState(value) {\n    let result = {\n        constant: false,\n        payable: true,\n        stateMutability: \"payable\"\n    };\n    if (value.stateMutability != null) {\n        result.stateMutability = value.stateMutability;\n        // Set (and check things are consistent) the constant property\n        result.constant = (result.stateMutability === \"view\" || result.stateMutability === \"pure\");\n        if (value.constant != null) {\n            if ((!!value.constant) !== result.constant) {\n                logger.throwArgumentError(\"cannot have constant function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n        // Set (and check things are consistent) the payable property\n        result.payable = (result.stateMutability === \"payable\");\n        if (value.payable != null) {\n            if ((!!value.payable) !== result.payable) {\n                logger.throwArgumentError(\"cannot have payable function with mutability \" + result.stateMutability, \"value\", value);\n            }\n        }\n    }\n    else if (value.payable != null) {\n        result.payable = !!value.payable;\n        // If payable we can assume non-constant; otherwise we can't assume\n        if (value.constant == null && !result.payable && value.type !== \"constructor\") {\n            logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n        }\n        result.constant = !!value.constant;\n        if (result.constant) {\n            result.stateMutability = \"view\";\n        }\n        else {\n            result.stateMutability = (result.payable ? \"payable\" : \"nonpayable\");\n        }\n        if (result.payable && result.constant) {\n            logger.throwArgumentError(\"cannot have constant payable function\", \"value\", value);\n        }\n    }\n    else if (value.constant != null) {\n        result.constant = !!value.constant;\n        result.payable = !result.constant;\n        result.stateMutability = (result.constant ? \"view\" : \"payable\");\n    }\n    else if (value.type !== \"constructor\") {\n        logger.throwArgumentError(\"unable to determine stateMutability\", \"value\", value);\n    }\n    return result;\n}\nexport class ConstructorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"constructor\",\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))\n            });\n        }\n        if (format === FormatTypes.sighash) {\n            logger.throwError(\"cannot format a constructor for sighash\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"format(sighash)\"\n            });\n        }\n        let result = \"constructor(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (this.stateMutability && this.stateMutability !== \"nonpayable\") {\n            result += this.stateMutability + \" \";\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ConstructorFragment.fromString(value);\n        }\n        return ConstructorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ConstructorFragment.isConstructorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        if (state.constant) {\n            logger.throwArgumentError(\"constructor cannot be constant\", \"value\", value);\n        }\n        const params = {\n            name: null,\n            type: value.type,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\n        };\n        return new ConstructorFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"constructor\" };\n        value = parseGas(value, params);\n        let parens = value.match(regexParen);\n        if (!parens || parens[1].trim() !== \"constructor\") {\n            logger.throwArgumentError(\"invalid constructor string\", \"value\", value);\n        }\n        params.inputs = parseParams(parens[2].trim(), false);\n        parseModifiers(parens[3].trim(), params);\n        return ConstructorFragment.fromObject(params);\n    }\n    static isConstructorFragment(value) {\n        return (value && value._isFragment && value.type === \"constructor\");\n    }\n}\nexport class FunctionFragment extends ConstructorFragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"function\",\n                name: this.name,\n                constant: this.constant,\n                stateMutability: ((this.stateMutability !== \"nonpayable\") ? this.stateMutability : undefined),\n                payable: this.payable,\n                gas: (this.gas ? this.gas.toNumber() : undefined),\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"function \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        if (format !== FormatTypes.sighash) {\n            if (this.stateMutability) {\n                if (this.stateMutability !== \"nonpayable\") {\n                    result += (this.stateMutability + \" \");\n                }\n            }\n            else if (this.constant) {\n                result += \"view \";\n            }\n            if (this.outputs && this.outputs.length) {\n                result += \"returns (\" + this.outputs.map((output) => output.format(format)).join(\", \") + \") \";\n            }\n            if (this.gas != null) {\n                result += \"@\" + this.gas.toString() + \" \";\n            }\n        }\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return FunctionFragment.fromString(value);\n        }\n        return FunctionFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (FunctionFragment.isFunctionFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"function\") {\n            logger.throwArgumentError(\"invalid function object\", \"value\", value);\n        }\n        let state = verifyState(value);\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            constant: state.constant,\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),\n            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),\n            payable: state.payable,\n            stateMutability: state.stateMutability,\n            gas: (value.gas ? BigNumber.from(value.gas) : null)\n        };\n        return new FunctionFragment(_constructorGuard, params);\n    }\n    static fromString(value) {\n        let params = { type: \"function\" };\n        value = parseGas(value, params);\n        let comps = value.split(\" returns \");\n        if (comps.length > 2) {\n            logger.throwArgumentError(\"invalid function string\", \"value\", value);\n        }\n        let parens = comps[0].match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid function signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        parseModifiers(parens[3].trim(), params);\n        // We have outputs\n        if (comps.length > 1) {\n            let returns = comps[1].match(regexParen);\n            if (returns[1].trim() != \"\" || returns[3].trim() != \"\") {\n                logger.throwArgumentError(\"unexpected tokens\", \"value\", value);\n            }\n            params.outputs = parseParams(returns[2], false);\n        }\n        else {\n            params.outputs = [];\n        }\n        return FunctionFragment.fromObject(params);\n    }\n    static isFunctionFragment(value) {\n        return (value && value._isFragment && value.type === \"function\");\n    }\n}\n//export class StructFragment extends Fragment {\n//}\nfunction checkForbidden(fragment) {\n    const sig = fragment.format();\n    if (sig === \"Error(string)\" || sig === \"Panic(uint256)\") {\n        logger.throwArgumentError(`cannot specify user defined ${sig} error`, \"fragment\", fragment);\n    }\n    return fragment;\n}\nexport class ErrorFragment extends Fragment {\n    format(format) {\n        if (!format) {\n            format = FormatTypes.sighash;\n        }\n        if (!FormatTypes[format]) {\n            logger.throwArgumentError(\"invalid format type\", \"format\", format);\n        }\n        if (format === FormatTypes.json) {\n            return JSON.stringify({\n                type: \"error\",\n                name: this.name,\n                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),\n            });\n        }\n        let result = \"\";\n        if (format !== FormatTypes.sighash) {\n            result += \"error \";\n        }\n        result += this.name + \"(\" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? \", \" : \",\") + \") \";\n        return result.trim();\n    }\n    static from(value) {\n        if (typeof (value) === \"string\") {\n            return ErrorFragment.fromString(value);\n        }\n        return ErrorFragment.fromObject(value);\n    }\n    static fromObject(value) {\n        if (ErrorFragment.isErrorFragment(value)) {\n            return value;\n        }\n        if (value.type !== \"error\") {\n            logger.throwArgumentError(\"invalid error object\", \"value\", value);\n        }\n        const params = {\n            type: value.type,\n            name: verifyIdentifier(value.name),\n            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])\n        };\n        return checkForbidden(new ErrorFragment(_constructorGuard, params));\n    }\n    static fromString(value) {\n        let params = { type: \"error\" };\n        let parens = value.match(regexParen);\n        if (!parens) {\n            logger.throwArgumentError(\"invalid error signature\", \"value\", value);\n        }\n        params.name = parens[1].trim();\n        if (params.name) {\n            verifyIdentifier(params.name);\n        }\n        params.inputs = parseParams(parens[2], false);\n        return checkForbidden(ErrorFragment.fromObject(params));\n    }\n    static isErrorFragment(value) {\n        return (value && value._isFragment && value.type === \"error\");\n    }\n}\nfunction verifyType(type) {\n    // These need to be transformed to their full description\n    if (type.match(/^uint($|[^1-9])/)) {\n        type = \"uint256\" + type.substring(4);\n    }\n    else if (type.match(/^int($|[^1-9])/)) {\n        type = \"int256\" + type.substring(3);\n    }\n    // @TODO: more verification\n    return type;\n}\n// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234\nconst regexIdentifier = new RegExp(\"^[a-zA-Z$_][a-zA-Z0-9$_]*$\");\nfunction verifyIdentifier(value) {\n    if (!value || !value.match(regexIdentifier)) {\n        logger.throwArgumentError(`invalid identifier \"${value}\"`, \"value\", value);\n    }\n    return value;\n}\nconst regexParen = new RegExp(\"^([^)(]*)\\\\((.*)\\\\)([^)(]*)$\");\nfunction splitNesting(value) {\n    value = value.trim();\n    let result = [];\n    let accum = \"\";\n    let depth = 0;\n    for (let offset = 0; offset < value.length; offset++) {\n        let c = value[offset];\n        if (c === \",\" && depth === 0) {\n            result.push(accum);\n            accum = \"\";\n        }\n        else {\n            accum += c;\n            if (c === \"(\") {\n                depth++;\n            }\n            else if (c === \")\") {\n                depth--;\n                if (depth === -1) {\n                    logger.throwArgumentError(\"unbalanced parenthesis\", \"value\", value);\n                }\n            }\n        }\n    }\n    if (accum) {\n        result.push(accum);\n    }\n    return result;\n}\n//# sourceMappingURL=fragments.js.map","\"use strict\";\nimport { arrayify, concat, hexConcat, hexlify } from \"@ethersproject/bytes\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nexport function checkResultErrors(result) {\n    // Find the first error (if any)\n    const errors = [];\n    const checkErrors = function (path, object) {\n        if (!Array.isArray(object)) {\n            return;\n        }\n        for (let key in object) {\n            const childPath = path.slice();\n            childPath.push(key);\n            try {\n                checkErrors(childPath, object[key]);\n            }\n            catch (error) {\n                errors.push({ path: childPath, error: error });\n            }\n        }\n    };\n    checkErrors([], result);\n    return errors;\n}\nexport class Coder {\n    constructor(name, type, localName, dynamic) {\n        // @TODO: defineReadOnly these\n        this.name = name;\n        this.type = type;\n        this.localName = localName;\n        this.dynamic = dynamic;\n    }\n    _throwError(message, value) {\n        logger.throwArgumentError(message, this.localName, value);\n    }\n}\nexport class Writer {\n    constructor(wordSize) {\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        this._data = [];\n        this._dataLength = 0;\n        this._padding = new Uint8Array(wordSize);\n    }\n    get data() {\n        return hexConcat(this._data);\n    }\n    get length() { return this._dataLength; }\n    _writeData(data) {\n        this._data.push(data);\n        this._dataLength += data.length;\n        return data.length;\n    }\n    appendWriter(writer) {\n        return this._writeData(concat(writer._data));\n    }\n    // Arrayish items; padded on the right to wordSize\n    writeBytes(value) {\n        let bytes = arrayify(value);\n        const paddingOffset = bytes.length % this.wordSize;\n        if (paddingOffset) {\n            bytes = concat([bytes, this._padding.slice(paddingOffset)]);\n        }\n        return this._writeData(bytes);\n    }\n    _getValue(value) {\n        let bytes = arrayify(BigNumber.from(value));\n        if (bytes.length > this.wordSize) {\n            logger.throwError(\"value out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                length: this.wordSize,\n                offset: bytes.length\n            });\n        }\n        if (bytes.length % this.wordSize) {\n            bytes = concat([this._padding.slice(bytes.length % this.wordSize), bytes]);\n        }\n        return bytes;\n    }\n    // BigNumberish items; padded on the left to wordSize\n    writeValue(value) {\n        return this._writeData(this._getValue(value));\n    }\n    writeUpdatableValue() {\n        const offset = this._data.length;\n        this._data.push(this._padding);\n        this._dataLength += this.wordSize;\n        return (value) => {\n            this._data[offset] = this._getValue(value);\n        };\n    }\n}\nexport class Reader {\n    constructor(data, wordSize, coerceFunc, allowLoose) {\n        defineReadOnly(this, \"_data\", arrayify(data));\n        defineReadOnly(this, \"wordSize\", wordSize || 32);\n        defineReadOnly(this, \"_coerceFunc\", coerceFunc);\n        defineReadOnly(this, \"allowLoose\", allowLoose);\n        this._offset = 0;\n    }\n    get data() { return hexlify(this._data); }\n    get consumed() { return this._offset; }\n    // The default Coerce function\n    static coerce(name, value) {\n        let match = name.match(\"^u?int([0-9]+)$\");\n        if (match && parseInt(match[1]) <= 48) {\n            value = value.toNumber();\n        }\n        return value;\n    }\n    coerce(name, value) {\n        if (this._coerceFunc) {\n            return this._coerceFunc(name, value);\n        }\n        return Reader.coerce(name, value);\n    }\n    _peekBytes(offset, length, loose) {\n        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;\n        if (this._offset + alignedLength > this._data.length) {\n            if (this.allowLoose && loose && this._offset + length <= this._data.length) {\n                alignedLength = length;\n            }\n            else {\n                logger.throwError(\"data out-of-bounds\", Logger.errors.BUFFER_OVERRUN, {\n                    length: this._data.length,\n                    offset: this._offset + alignedLength\n                });\n            }\n        }\n        return this._data.slice(this._offset, this._offset + alignedLength);\n    }\n    subReader(offset) {\n        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);\n    }\n    readBytes(length, loose) {\n        let bytes = this._peekBytes(0, length, !!loose);\n        this._offset += bytes.length;\n        // @TODO: Make sure the length..end bytes are all 0?\n        return bytes.slice(0, length);\n    }\n    readValue() {\n        return BigNumber.from(this.readBytes(this.wordSize));\n    }\n}\n//# sourceMappingURL=abstract-coder.js.map","\"use strict\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { hexZeroPad } from \"@ethersproject/bytes\";\nimport { Coder } from \"./abstract-coder\";\nexport class AddressCoder extends Coder {\n    constructor(localName) {\n        super(\"address\", \"address\", localName, false);\n    }\n    defaultValue() {\n        return \"0x0000000000000000000000000000000000000000\";\n    }\n    encode(writer, value) {\n        try {\n            value = getAddress(value);\n        }\n        catch (error) {\n            this._throwError(error.message, value);\n        }\n        return writer.writeValue(value);\n    }\n    decode(reader) {\n        return getAddress(hexZeroPad(reader.readValue().toHexString(), 20));\n    }\n}\n//# sourceMappingURL=address.js.map","\"use strict\";\nimport { Coder } from \"./abstract-coder\";\n// Clones the functionality of an existing Coder, but without a localName\nexport class AnonymousCoder extends Coder {\n    constructor(coder) {\n        super(coder.name, coder.type, undefined, coder.dynamic);\n        this.coder = coder;\n    }\n    defaultValue() {\n        return this.coder.defaultValue();\n    }\n    encode(writer, value) {\n        return this.coder.encode(writer, value);\n    }\n    decode(reader) {\n        return this.coder.decode(reader);\n    }\n}\n//# sourceMappingURL=anonymous.js.map","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"../_version\";\nconst logger = new Logger(version);\nimport { Coder, Writer } from \"./abstract-coder\";\nimport { AnonymousCoder } from \"./anonymous\";\nexport function pack(writer, coders, values) {\n    let arrayValues = null;\n    if (Array.isArray(values)) {\n        arrayValues = values;\n    }\n    else if (values && typeof (values) === \"object\") {\n        let unique = {};\n        arrayValues = coders.map((coder) => {\n            const name = coder.localName;\n            if (!name) {\n                logger.throwError(\"cannot encode object for signature with missing names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            if (unique[name]) {\n                logger.throwError(\"cannot encode object for signature with duplicate names\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"values\",\n                    coder: coder,\n                    value: values\n                });\n            }\n            unique[name] = true;\n            return values[name];\n        });\n    }\n    else {\n        logger.throwArgumentError(\"invalid tuple value\", \"tuple\", values);\n    }\n    if (coders.length !== arrayValues.length) {\n        logger.throwArgumentError(\"types/value length mismatch\", \"tuple\", values);\n    }\n    let staticWriter = new Writer(writer.wordSize);\n    let dynamicWriter = new Writer(writer.wordSize);\n    let updateFuncs = [];\n    coders.forEach((coder, index) => {\n        let value = arrayValues[index];\n        if (coder.dynamic) {\n            // Get current dynamic offset (for the future pointer)\n            let dynamicOffset = dynamicWriter.length;\n            // Encode the dynamic value into the dynamicWriter\n            coder.encode(dynamicWriter, value);\n            // Prepare to populate the correct offset once we are done\n            let updateFunc = staticWriter.writeUpdatableValue();\n            updateFuncs.push((baseOffset) => {\n                updateFunc(baseOffset + dynamicOffset);\n            });\n        }\n        else {\n            coder.encode(staticWriter, value);\n        }\n    });\n    // Backfill all the dynamic offsets, now that we know the static length\n    updateFuncs.forEach((func) => { func(staticWriter.length); });\n    let length = writer.appendWriter(staticWriter);\n    length += writer.appendWriter(dynamicWriter);\n    return length;\n}\nexport function unpack(reader, coders) {\n    let values = [];\n    // A reader anchored to this base\n    let baseReader = reader.subReader(0);\n    coders.forEach((coder) => {\n        let value = null;\n        if (coder.dynamic) {\n            let offset = reader.readValue();\n            let offsetReader = baseReader.subReader(offset.toNumber());\n            try {\n                value = coder.decode(offsetReader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        else {\n            try {\n                value = coder.decode(reader);\n            }\n            catch (error) {\n                // Cannot recover from this\n                if (error.code === Logger.errors.BUFFER_OVERRUN) {\n                    throw error;\n                }\n                value = error;\n                value.baseType = coder.name;\n                value.name = coder.localName;\n                value.type = coder.type;\n            }\n        }\n        if (value != undefined) {\n            values.push(value);\n        }\n    });\n    // We only output named properties for uniquely named coders\n    const uniqueNames = coders.reduce((accum, coder) => {\n        const name = coder.localName;\n        if (name) {\n            if (!accum[name]) {\n                accum[name] = 0;\n            }\n            accum[name]++;\n        }\n        return accum;\n    }, {});\n    // Add any named parameters (i.e. tuples)\n    coders.forEach((coder, index) => {\n        let name = coder.localName;\n        if (!name || uniqueNames[name] !== 1) {\n            return;\n        }\n        if (name === \"length\") {\n            name = \"_length\";\n        }\n        if (values[name] != null) {\n            return;\n        }\n        const value = values[index];\n        if (value instanceof Error) {\n            Object.defineProperty(values, name, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n        else {\n            values[name] = value;\n        }\n    });\n    for (let i = 0; i < values.length; i++) {\n        const value = values[i];\n        if (value instanceof Error) {\n            Object.defineProperty(values, i, {\n                enumerable: true,\n                get: () => { throw value; }\n            });\n        }\n    }\n    return Object.freeze(values);\n}\nexport class ArrayCoder extends Coder {\n    constructor(coder, length, localName) {\n        const type = (coder.type + \"[\" + (length >= 0 ? length : \"\") + \"]\");\n        const dynamic = (length === -1 || coder.dynamic);\n        super(\"array\", type, localName, dynamic);\n        this.coder = coder;\n        this.length = length;\n    }\n    defaultValue() {\n        // Verifies the child coder is valid (even if the array is dynamic or 0-length)\n        const defaultChild = this.coder.defaultValue();\n        const result = [];\n        for (let i = 0; i < this.length; i++) {\n            result.push(defaultChild);\n        }\n        return result;\n    }\n    encode(writer, value) {\n        if (!Array.isArray(value)) {\n            this._throwError(\"expected array value\", value);\n        }\n        let count = this.length;\n        if (count === -1) {\n            count = value.length;\n            writer.writeValue(value.length);\n        }\n        logger.checkArgumentCount(value.length, count, \"coder array\" + (this.localName ? (\" \" + this.localName) : \"\"));\n        let coders = [];\n        for (let i = 0; i < value.length; i++) {\n            coders.push(this.coder);\n        }\n        return pack(writer, coders, value);\n    }\n    decode(reader) {\n        let count = this.length;\n        if (count === -1) {\n            count = reader.readValue().toNumber();\n            // Check that there is *roughly* enough data to ensure\n            // stray random data is not being read as a length. Each\n            // slot requires at least 32 bytes for their value (or 32\n            // bytes as a link to the data). This could use a much\n            // tighter bound, but we are erroring on the side of safety.\n            if (count * 32 > reader._data.length) {\n                logger.throwError(\"insufficient data length\", Logger.errors.BUFFER_OVERRUN, {\n                    length: reader._data.length,\n                    count: count\n                });\n            }\n        }\n        let coders = [];\n        for (let i = 0; i < count; i++) {\n            coders.push(new AnonymousCoder(this.coder));\n        }\n        return reader.coerce(this.name, unpack(reader, coders));\n    }\n}\n//# sourceMappingURL=array.js.map","\"use strict\";\nimport { Coder } from \"./abstract-coder\";\nexport class BooleanCoder extends Coder {\n    constructor(localName) {\n        super(\"bool\", \"bool\", localName, false);\n    }\n    defaultValue() {\n        return false;\n    }\n    encode(writer, value) {\n        return writer.writeValue(value ? 1 : 0);\n    }\n    decode(reader) {\n        return reader.coerce(this.type, !reader.readValue().isZero());\n    }\n}\n//# sourceMappingURL=boolean.js.map","\"use strict\";\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\nimport { Coder } from \"./abstract-coder\";\nexport class DynamicBytesCoder extends Coder {\n    constructor(type, localName) {\n        super(type, type, localName, true);\n    }\n    defaultValue() {\n        return \"0x\";\n    }\n    encode(writer, value) {\n        value = arrayify(value);\n        let length = writer.writeValue(value.length);\n        length += writer.writeBytes(value);\n        return length;\n    }\n    decode(reader) {\n        return reader.readBytes(reader.readValue().toNumber(), true);\n    }\n}\nexport class BytesCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"bytes\", localName);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, hexlify(super.decode(reader)));\n    }\n}\n//# sourceMappingURL=bytes.js.map","\"use strict\";\nimport { arrayify, hexlify } from \"@ethersproject/bytes\";\nimport { Coder } from \"./abstract-coder\";\n// @TODO: Merge this with bytes\nexport class FixedBytesCoder extends Coder {\n    constructor(size, localName) {\n        let name = \"bytes\" + String(size);\n        super(name, name, localName, false);\n        this.size = size;\n    }\n    defaultValue() {\n        return (\"0x0000000000000000000000000000000000000000000000000000000000000000\").substring(0, 2 + this.size * 2);\n    }\n    encode(writer, value) {\n        let data = arrayify(value);\n        if (data.length !== this.size) {\n            this._throwError(\"incorrect data length\", value);\n        }\n        return writer.writeBytes(data);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, hexlify(reader.readBytes(this.size)));\n    }\n}\n//# sourceMappingURL=fixed-bytes.js.map","\"use strict\";\nimport { Coder } from \"./abstract-coder\";\nexport class NullCoder extends Coder {\n    constructor(localName) {\n        super(\"null\", \"\", localName, false);\n    }\n    defaultValue() {\n        return null;\n    }\n    encode(writer, value) {\n        if (value != null) {\n            this._throwError(\"not null\", value);\n        }\n        return writer.writeBytes([]);\n    }\n    decode(reader) {\n        reader.readBytes(0);\n        return reader.coerce(this.name, null);\n    }\n}\n//# sourceMappingURL=null.js.map","export const AddressZero = \"0x0000000000000000000000000000000000000000\";\n//# sourceMappingURL=addresses.js.map","export const HashZero = \"0x0000000000000000000000000000000000000000000000000000000000000000\";\n//# sourceMappingURL=hashes.js.map","\"use strict\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { MaxUint256, NegativeOne, One, Zero } from \"@ethersproject/constants\";\nimport { Coder } from \"./abstract-coder\";\nexport class NumberCoder extends Coder {\n    constructor(size, signed, localName) {\n        const name = ((signed ? \"int\" : \"uint\") + (size * 8));\n        super(name, name, localName, false);\n        this.size = size;\n        this.signed = signed;\n    }\n    defaultValue() {\n        return 0;\n    }\n    encode(writer, value) {\n        let v = BigNumber.from(value);\n        // Check bounds are safe for encoding\n        let maxUintValue = MaxUint256.mask(writer.wordSize * 8);\n        if (this.signed) {\n            let bounds = maxUintValue.mask(this.size * 8 - 1);\n            if (v.gt(bounds) || v.lt(bounds.add(One).mul(NegativeOne))) {\n                this._throwError(\"value out-of-bounds\", value);\n            }\n        }\n        else if (v.lt(Zero) || v.gt(maxUintValue.mask(this.size * 8))) {\n            this._throwError(\"value out-of-bounds\", value);\n        }\n        v = v.toTwos(this.size * 8).mask(this.size * 8);\n        if (this.signed) {\n            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);\n        }\n        return writer.writeValue(v);\n    }\n    decode(reader) {\n        let value = reader.readValue().mask(this.size * 8);\n        if (this.signed) {\n            value = value.fromTwos(this.size * 8);\n        }\n        return reader.coerce(this.name, value);\n    }\n}\n//# sourceMappingURL=number.js.map","export const version = \"strings/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n///////////////////////////////\nexport var UnicodeNormalizationForm;\n(function (UnicodeNormalizationForm) {\n    UnicodeNormalizationForm[\"current\"] = \"\";\n    UnicodeNormalizationForm[\"NFC\"] = \"NFC\";\n    UnicodeNormalizationForm[\"NFD\"] = \"NFD\";\n    UnicodeNormalizationForm[\"NFKC\"] = \"NFKC\";\n    UnicodeNormalizationForm[\"NFKD\"] = \"NFKD\";\n})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));\n;\nexport var Utf8ErrorReason;\n(function (Utf8ErrorReason) {\n    // A continuation byte was present where there was nothing to continue\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"UNEXPECTED_CONTINUE\"] = \"unexpected continuation byte\";\n    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"BAD_PREFIX\"] = \"bad codepoint prefix\";\n    // The string is too short to process the expected codepoint\n    // - offset = the index the codepoint began in\n    Utf8ErrorReason[\"OVERRUN\"] = \"string overrun\";\n    // A missing continuation byte was expected but not found\n    // - offset = the index the continuation byte was expected at\n    Utf8ErrorReason[\"MISSING_CONTINUE\"] = \"missing continuation byte\";\n    // The computed code point is outside the range for UTF-8\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; outside the UTF-8 range\n    Utf8ErrorReason[\"OUT_OF_RANGE\"] = \"out of UTF-8 range\";\n    // UTF-8 strings may not contain UTF-16 surrogate pairs\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range\n    Utf8ErrorReason[\"UTF16_SURROGATE\"] = \"UTF-16 surrogate\";\n    // The string is an overlong representation\n    // - offset       = start of this codepoint\n    // - badCodepoint = the computed codepoint; already bounds checked\n    Utf8ErrorReason[\"OVERLONG\"] = \"overlong representation\";\n})(Utf8ErrorReason || (Utf8ErrorReason = {}));\n;\nfunction errorFunc(reason, offset, bytes, output, badCodepoint) {\n    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, \"bytes\", bytes);\n}\nfunction ignoreFunc(reason, offset, bytes, output, badCodepoint) {\n    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes\n    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {\n        let i = 0;\n        for (let o = offset + 1; o < bytes.length; o++) {\n            if (bytes[o] >> 6 !== 0x02) {\n                break;\n            }\n            i++;\n        }\n        return i;\n    }\n    // This byte runs us past the end of the string, so just jump to the end\n    // (but the first byte was read already read and therefore skipped)\n    if (reason === Utf8ErrorReason.OVERRUN) {\n        return bytes.length - offset - 1;\n    }\n    // Nothing to skip\n    return 0;\n}\nfunction replaceFunc(reason, offset, bytes, output, badCodepoint) {\n    // Overlong representations are otherwise \"valid\" code points; just non-deistingtished\n    if (reason === Utf8ErrorReason.OVERLONG) {\n        output.push(badCodepoint);\n        return 0;\n    }\n    // Put the replacement character into the output\n    output.push(0xfffd);\n    // Otherwise, process as if ignoring errors\n    return ignoreFunc(reason, offset, bytes, output, badCodepoint);\n}\n// Common error handing strategies\nexport const Utf8ErrorFuncs = Object.freeze({\n    error: errorFunc,\n    ignore: ignoreFunc,\n    replace: replaceFunc\n});\n// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499\nfunction getUtf8CodePoints(bytes, onError) {\n    if (onError == null) {\n        onError = Utf8ErrorFuncs.error;\n    }\n    bytes = arrayify(bytes);\n    const result = [];\n    let i = 0;\n    // Invalid bytes are ignored\n    while (i < bytes.length) {\n        const c = bytes[i++];\n        // 0xxx xxxx\n        if (c >> 7 === 0) {\n            result.push(c);\n            continue;\n        }\n        // Multibyte; how many bytes left for this character?\n        let extraLength = null;\n        let overlongMask = null;\n        // 110x xxxx 10xx xxxx\n        if ((c & 0xe0) === 0xc0) {\n            extraLength = 1;\n            overlongMask = 0x7f;\n            // 1110 xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf0) === 0xe0) {\n            extraLength = 2;\n            overlongMask = 0x7ff;\n            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx\n        }\n        else if ((c & 0xf8) === 0xf0) {\n            extraLength = 3;\n            overlongMask = 0xffff;\n        }\n        else {\n            if ((c & 0xc0) === 0x80) {\n                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);\n            }\n            else {\n                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);\n            }\n            continue;\n        }\n        // Do we have enough bytes in our data?\n        if (i - 1 + extraLength >= bytes.length) {\n            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);\n            continue;\n        }\n        // Remove the length prefix from the char\n        let res = c & ((1 << (8 - extraLength - 1)) - 1);\n        for (let j = 0; j < extraLength; j++) {\n            let nextChar = bytes[i];\n            // Invalid continuation byte\n            if ((nextChar & 0xc0) != 0x80) {\n                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);\n                res = null;\n                break;\n            }\n            ;\n            res = (res << 6) | (nextChar & 0x3f);\n            i++;\n        }\n        // See above loop for invalid continuation byte\n        if (res === null) {\n            continue;\n        }\n        // Maximum code point\n        if (res > 0x10ffff) {\n            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Reserved for UTF-16 surrogate halves\n        if (res >= 0xd800 && res <= 0xdfff) {\n            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        // Check for overlong sequences (more bytes than needed)\n        if (res <= overlongMask) {\n            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);\n            continue;\n        }\n        result.push(res);\n    }\n    return result;\n}\n// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array\nexport function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {\n    if (form != UnicodeNormalizationForm.current) {\n        logger.checkNormalize();\n        str = str.normalize(form);\n    }\n    let result = [];\n    for (let i = 0; i < str.length; i++) {\n        const c = str.charCodeAt(i);\n        if (c < 0x80) {\n            result.push(c);\n        }\n        else if (c < 0x800) {\n            result.push((c >> 6) | 0xc0);\n            result.push((c & 0x3f) | 0x80);\n        }\n        else if ((c & 0xfc00) == 0xd800) {\n            i++;\n            const c2 = str.charCodeAt(i);\n            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {\n                throw new Error(\"invalid utf-8 string\");\n            }\n            // Surrogate Pair\n            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);\n            result.push((pair >> 18) | 0xf0);\n            result.push(((pair >> 12) & 0x3f) | 0x80);\n            result.push(((pair >> 6) & 0x3f) | 0x80);\n            result.push((pair & 0x3f) | 0x80);\n        }\n        else {\n            result.push((c >> 12) | 0xe0);\n            result.push(((c >> 6) & 0x3f) | 0x80);\n            result.push((c & 0x3f) | 0x80);\n        }\n    }\n    return arrayify(result);\n}\n;\nfunction escapeChar(value) {\n    const hex = (\"0000\" + value.toString(16));\n    return \"\\\\u\" + hex.substring(hex.length - 4);\n}\nexport function _toEscapedUtf8String(bytes, onError) {\n    return '\"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {\n        if (codePoint < 256) {\n            switch (codePoint) {\n                case 8: return \"\\\\b\";\n                case 9: return \"\\\\t\";\n                case 10: return \"\\\\n\";\n                case 13: return \"\\\\r\";\n                case 34: return \"\\\\\\\"\";\n                case 92: return \"\\\\\\\\\";\n            }\n            if (codePoint >= 32 && codePoint < 127) {\n                return String.fromCharCode(codePoint);\n            }\n        }\n        if (codePoint <= 0xffff) {\n            return escapeChar(codePoint);\n        }\n        codePoint -= 0x10000;\n        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);\n    }).join(\"\") + '\"';\n}\nexport function _toUtf8String(codePoints) {\n    return codePoints.map((codePoint) => {\n        if (codePoint <= 0xffff) {\n            return String.fromCharCode(codePoint);\n        }\n        codePoint -= 0x10000;\n        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));\n    }).join(\"\");\n}\nexport function toUtf8String(bytes, onError) {\n    return _toUtf8String(getUtf8CodePoints(bytes, onError));\n}\nexport function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {\n    return getUtf8CodePoints(toUtf8Bytes(str, form));\n}\n//# sourceMappingURL=utf8.js.map","\"use strict\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { DynamicBytesCoder } from \"./bytes\";\nexport class StringCoder extends DynamicBytesCoder {\n    constructor(localName) {\n        super(\"string\", localName);\n    }\n    defaultValue() {\n        return \"\";\n    }\n    encode(writer, value) {\n        return super.encode(writer, toUtf8Bytes(value));\n    }\n    decode(reader) {\n        return toUtf8String(super.decode(reader));\n    }\n}\n//# sourceMappingURL=string.js.map","\"use strict\";\nimport { Coder } from \"./abstract-coder\";\nimport { pack, unpack } from \"./array\";\nexport class TupleCoder extends Coder {\n    constructor(coders, localName) {\n        let dynamic = false;\n        const types = [];\n        coders.forEach((coder) => {\n            if (coder.dynamic) {\n                dynamic = true;\n            }\n            types.push(coder.type);\n        });\n        const type = (\"tuple(\" + types.join(\",\") + \")\");\n        super(\"tuple\", type, localName, dynamic);\n        this.coders = coders;\n    }\n    defaultValue() {\n        const values = [];\n        this.coders.forEach((coder) => {\n            values.push(coder.defaultValue());\n        });\n        // We only output named properties for uniquely named coders\n        const uniqueNames = this.coders.reduce((accum, coder) => {\n            const name = coder.localName;\n            if (name) {\n                if (!accum[name]) {\n                    accum[name] = 0;\n                }\n                accum[name]++;\n            }\n            return accum;\n        }, {});\n        // Add named values\n        this.coders.forEach((coder, index) => {\n            let name = coder.localName;\n            if (!name || uniqueNames[name] !== 1) {\n                return;\n            }\n            if (name === \"length\") {\n                name = \"_length\";\n            }\n            if (values[name] != null) {\n                return;\n            }\n            values[name] = values[index];\n        });\n        return Object.freeze(values);\n    }\n    encode(writer, value) {\n        return pack(writer, this.coders, value);\n    }\n    decode(reader) {\n        return reader.coerce(this.name, unpack(reader, this.coders));\n    }\n}\n//# sourceMappingURL=tuple.js.map","\"use strict\";\n// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Reader, Writer } from \"./coders/abstract-coder\";\nimport { AddressCoder } from \"./coders/address\";\nimport { ArrayCoder } from \"./coders/array\";\nimport { BooleanCoder } from \"./coders/boolean\";\nimport { BytesCoder } from \"./coders/bytes\";\nimport { FixedBytesCoder } from \"./coders/fixed-bytes\";\nimport { NullCoder } from \"./coders/null\";\nimport { NumberCoder } from \"./coders/number\";\nimport { StringCoder } from \"./coders/string\";\nimport { TupleCoder } from \"./coders/tuple\";\nimport { ParamType } from \"./fragments\";\nconst paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);\nconst paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);\nexport class AbiCoder {\n    constructor(coerceFunc) {\n        defineReadOnly(this, \"coerceFunc\", coerceFunc || null);\n    }\n    _getCoder(param) {\n        switch (param.baseType) {\n            case \"address\":\n                return new AddressCoder(param.name);\n            case \"bool\":\n                return new BooleanCoder(param.name);\n            case \"string\":\n                return new StringCoder(param.name);\n            case \"bytes\":\n                return new BytesCoder(param.name);\n            case \"array\":\n                return new ArrayCoder(this._getCoder(param.arrayChildren), param.arrayLength, param.name);\n            case \"tuple\":\n                return new TupleCoder((param.components || []).map((component) => {\n                    return this._getCoder(component);\n                }), param.name);\n            case \"\":\n                return new NullCoder(param.name);\n        }\n        // u?int[0-9]*\n        let match = param.type.match(paramTypeNumber);\n        if (match) {\n            let size = parseInt(match[2] || \"256\");\n            if (size === 0 || size > 256 || (size % 8) !== 0) {\n                logger.throwArgumentError(\"invalid \" + match[1] + \" bit length\", \"param\", param);\n            }\n            return new NumberCoder(size / 8, (match[1] === \"int\"), param.name);\n        }\n        // bytes[0-9]+\n        match = param.type.match(paramTypeBytes);\n        if (match) {\n            let size = parseInt(match[1]);\n            if (size === 0 || size > 32) {\n                logger.throwArgumentError(\"invalid bytes length\", \"param\", param);\n            }\n            return new FixedBytesCoder(size, param.name);\n        }\n        return logger.throwArgumentError(\"invalid type\", \"type\", param.type);\n    }\n    _getWordSize() { return 32; }\n    _getReader(data, allowLoose) {\n        return new Reader(data, this._getWordSize(), this.coerceFunc, allowLoose);\n    }\n    _getWriter() {\n        return new Writer(this._getWordSize());\n    }\n    getDefaultValue(types) {\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.defaultValue();\n    }\n    encode(types, values) {\n        if (types.length !== values.length) {\n            logger.throwError(\"types/values length mismatch\", Logger.errors.INVALID_ARGUMENT, {\n                count: { types: types.length, values: values.length },\n                value: { types: types, values: values }\n            });\n        }\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = (new TupleCoder(coders, \"_\"));\n        const writer = this._getWriter();\n        coder.encode(writer, values);\n        return writer.data;\n    }\n    decode(types, data, loose) {\n        const coders = types.map((type) => this._getCoder(ParamType.from(type)));\n        const coder = new TupleCoder(coders, \"_\");\n        return coder.decode(this._getReader(arrayify(data), loose));\n    }\n}\nexport const defaultAbiCoder = new AbiCoder();\n//# sourceMappingURL=abi-coder.js.map","import { keccak256 } from \"@ethersproject/keccak256\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nexport function id(text) {\n    return keccak256(toUtf8Bytes(text));\n}\n//# sourceMappingURL=id.js.map","export const version = \"hash/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { arrayify } from \"@ethersproject/bytes\";\nexport function decode(textData) {\n    textData = atob(textData);\n    const data = [];\n    for (let i = 0; i < textData.length; i++) {\n        data.push(textData.charCodeAt(i));\n    }\n    return arrayify(data);\n}\nexport function encode(data) {\n    data = arrayify(data);\n    let textData = \"\";\n    for (let i = 0; i < data.length; i++) {\n        textData += String.fromCharCode(data[i]);\n    }\n    return btoa(textData);\n}\n//# sourceMappingURL=base64.js.map","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\n// https://github.com/behnammodi/polyfill/blob/master/array.polyfill.js\nfunction flat(array, depth) {\n    if (depth == null) {\n        depth = 1;\n    }\n    const result = [];\n    const forEach = result.forEach;\n    const flatDeep = function (arr, depth) {\n        forEach.call(arr, function (val) {\n            if (depth > 0 && Array.isArray(val)) {\n                flatDeep(val, depth - 1);\n            }\n            else {\n                result.push(val);\n            }\n        });\n    };\n    flatDeep(array, depth);\n    return result;\n}\nfunction fromEntries(array) {\n    const result = {};\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        result[value[0]] = value[1];\n    }\n    return result;\n}\nexport function decode_arithmetic(bytes) {\n    let pos = 0;\n    function u16() { return (bytes[pos++] << 8) | bytes[pos++]; }\n    // decode the frequency table\n    let symbol_count = u16();\n    let total = 1;\n    let acc = [0, 1]; // first symbol has frequency 1\n    for (let i = 1; i < symbol_count; i++) {\n        acc.push(total += u16());\n    }\n    // skip the sized-payload that the last 3 symbols index into\n    let skip = u16();\n    let pos_payload = pos;\n    pos += skip;\n    let read_width = 0;\n    let read_buffer = 0;\n    function read_bit() {\n        if (read_width == 0) {\n            // this will read beyond end of buffer\n            // but (undefined|0) => zero pad\n            read_buffer = (read_buffer << 8) | bytes[pos++];\n            read_width = 8;\n        }\n        return (read_buffer >> --read_width) & 1;\n    }\n    const N = 31;\n    const FULL = Math.pow(2, N);\n    const HALF = FULL >>> 1;\n    const QRTR = HALF >> 1;\n    const MASK = FULL - 1;\n    // fill register\n    let register = 0;\n    for (let i = 0; i < N; i++)\n        register = (register << 1) | read_bit();\n    let symbols = [];\n    let low = 0;\n    let range = FULL; // treat like a float\n    while (true) {\n        let value = Math.floor((((register - low + 1) * total) - 1) / range);\n        let start = 0;\n        let end = symbol_count;\n        while (end - start > 1) { // binary search\n            let mid = (start + end) >>> 1;\n            if (value < acc[mid]) {\n                end = mid;\n            }\n            else {\n                start = mid;\n            }\n        }\n        if (start == 0)\n            break; // first symbol is end mark\n        symbols.push(start);\n        let a = low + Math.floor(range * acc[start] / total);\n        let b = low + Math.floor(range * acc[start + 1] / total) - 1;\n        while (((a ^ b) & HALF) == 0) {\n            register = (register << 1) & MASK | read_bit();\n            a = (a << 1) & MASK;\n            b = (b << 1) & MASK | 1;\n        }\n        while (a & ~b & QRTR) {\n            register = (register & HALF) | ((register << 1) & (MASK >>> 1)) | read_bit();\n            a = (a << 1) ^ HALF;\n            b = ((b ^ HALF) << 1) | HALF | 1;\n        }\n        low = a;\n        range = 1 + b - a;\n    }\n    let offset = symbol_count - 4;\n    return symbols.map(x => {\n        switch (x - offset) {\n            case 3: return offset + 0x10100 + ((bytes[pos_payload++] << 16) | (bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n            case 2: return offset + 0x100 + ((bytes[pos_payload++] << 8) | bytes[pos_payload++]);\n            case 1: return offset + bytes[pos_payload++];\n            default: return x - 1;\n        }\n    });\n}\n// returns an iterator which returns the next symbol\nexport function read_payload(v) {\n    let pos = 0;\n    return () => v[pos++];\n}\nexport function read_compressed_payload(bytes) {\n    return read_payload(decode_arithmetic(bytes));\n}\n// eg. [0,1,2,3...] => [0,-1,1,-2,...]\nexport function signed(i) {\n    return (i & 1) ? (~i >> 1) : (i >> 1);\n}\nfunction read_counts(n, next) {\n    let v = Array(n);\n    for (let i = 0; i < n; i++)\n        v[i] = 1 + next();\n    return v;\n}\nfunction read_ascending(n, next) {\n    let v = Array(n);\n    for (let i = 0, x = -1; i < n; i++)\n        v[i] = x += 1 + next();\n    return v;\n}\nfunction read_deltas(n, next) {\n    let v = Array(n);\n    for (let i = 0, x = 0; i < n; i++)\n        v[i] = x += signed(next());\n    return v;\n}\nexport function read_member_array(next, lookup) {\n    let v = read_ascending(next(), next);\n    let n = next();\n    let vX = read_ascending(n, next);\n    let vN = read_counts(n, next);\n    for (let i = 0; i < n; i++) {\n        for (let j = 0; j < vN[i]; j++) {\n            v.push(vX[i] + j);\n        }\n    }\n    return lookup ? v.map(x => lookup[x]) : v;\n}\n// returns array of \n// [x, ys] => single replacement rule\n// [x, ys, n, dx, dx] => linear map\nexport function read_mapped_map(next) {\n    let ret = [];\n    while (true) {\n        let w = next();\n        if (w == 0)\n            break;\n        ret.push(read_linear_table(w, next));\n    }\n    while (true) {\n        let w = next() - 1;\n        if (w < 0)\n            break;\n        ret.push(read_replacement_table(w, next));\n    }\n    return fromEntries(flat(ret));\n}\nexport function read_zero_terminated_array(next) {\n    let v = [];\n    while (true) {\n        let i = next();\n        if (i == 0)\n            break;\n        v.push(i);\n    }\n    return v;\n}\nfunction read_transposed(n, w, next) {\n    let m = Array(n).fill(undefined).map(() => []);\n    for (let i = 0; i < w; i++) {\n        read_deltas(n, next).forEach((x, j) => m[j].push(x));\n    }\n    return m;\n}\nfunction read_linear_table(w, next) {\n    let dx = 1 + next();\n    let dy = next();\n    let vN = read_zero_terminated_array(next);\n    let m = read_transposed(vN.length, 1 + w, next);\n    return flat(m.map((v, i) => {\n        const x = v[0], ys = v.slice(1);\n        //let [x, ...ys] = v;\n        //return Array(vN[i]).fill().map((_, j) => {\n        return Array(vN[i]).fill(undefined).map((_, j) => {\n            let j_dy = j * dy;\n            return [x + j * dx, ys.map(y => y + j_dy)];\n        });\n    }));\n}\nfunction read_replacement_table(w, next) {\n    let n = 1 + next();\n    let m = read_transposed(n, 1 + w, next);\n    return m.map(v => [v[0], v.slice(1)]);\n}\nexport function read_emoji_trie(next) {\n    let sorted = read_member_array(next).sort((a, b) => a - b);\n    return read();\n    function read() {\n        let branches = [];\n        while (true) {\n            let keys = read_member_array(next, sorted);\n            if (keys.length == 0)\n                break;\n            branches.push({ set: new Set(keys), node: read() });\n        }\n        branches.sort((a, b) => b.set.size - a.set.size); // sort by likelihood\n        let temp = next();\n        let valid = temp % 3;\n        temp = (temp / 3) | 0;\n        let fe0f = !!(temp & 1);\n        temp >>= 1;\n        let save = temp == 1;\n        let check = temp == 2;\n        return { branches, valid, fe0f, save, check };\n    }\n}\n//# sourceMappingURL=decoder.js.map","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\nimport { decode } from \"@ethersproject/base64\";\nimport { read_compressed_payload } from './decoder.js';\nexport function getData() {\n    return read_compressed_payload(decode('AEQF2AO2DEsA2wIrAGsBRABxAN8AZwCcAEwAqgA0AGwAUgByADcATAAVAFYAIQAyACEAKAAYAFgAGwAjABQAMAAmADIAFAAfABQAKwATACoADgAbAA8AHQAYABoAGQAxADgALAAoADwAEwA9ABMAGgARAA4ADwAWABMAFgAIAA8AHgQXBYMA5BHJAS8JtAYoAe4AExozi0UAH21tAaMnBT8CrnIyhrMDhRgDygIBUAEHcoFHUPe8AXBjAewCjgDQR8IICIcEcQLwATXCDgzvHwBmBoHNAqsBdBcUAykgDhAMShskMgo8AY8jqAQfAUAfHw8BDw87MioGlCIPBwZCa4ELatMAAMspJVgsDl8AIhckSg8XAHdvTwBcIQEiDT4OPhUqbyECAEoAS34Aej8Ybx83JgT/Xw8gHxZ/7w8RICxPHA9vBw+Pfw8PHwAPFv+fAsAvCc8vEr8ivwD/EQ8Bol8OEBa/A78hrwAPCU8vESNvvwWfHwNfAVoDHr+ZAAED34YaAdJPAK7PLwSEgDLHAGo1Pz8Pvx9fUwMrpb8O/58VTzAPIBoXIyQJNF8hpwIVAT8YGAUADDNBaX3RAMomJCg9EhUeA29MABsZBTMNJipjOhc19gcIDR8bBwQHEggCWi6DIgLuAQYA+BAFCha3A5XiAEsqM7UFFgFLhAMjFTMYE1Klnw74nRVBG/ASCm0BYRN/BrsU3VoWy+S0vV8LQx+vN8gF2AC2AK5EAWwApgYDKmAAroQ0NDQ0AT+OCg7wAAIHRAbpNgVcBV0APTA5BfbPFgMLzcYL/QqqA82eBALKCjQCjqYCht0/k2+OAsXQAoP3ASTKDgDw6ACKAUYCMpIKJpRaAE4A5womABzZvs0REEKiACIQAd5QdAECAj4Ywg/wGqY2AVgAYADYvAoCGAEubA0gvAY2ALAAbpbvqpyEAGAEpgQAJgAG7gAgAEACmghUFwCqAMpAINQIwC4DthRAAPcycKgApoIdABwBfCisABoATwBqASIAvhnSBP8aH/ECeAKXAq40NjgDBTwFYQU6AXs3oABgAD4XNgmcCY1eCl5tIFZeUqGgyoNHABgAEQAaABNwWQAmABMATPMa3T34ADldyprmM1M2XociUQgLzvwAXT3xABgAEQAaABNwIGFAnADD8AAgAD4BBJWzaCcIAIEBFMAWwKoAAdq9BWAF5wLQpALEtQAKUSGkahR4GnJM+gsAwCgeFAiUAECQ0BQuL8AAIAAAADKeIheclvFqQAAETr4iAMxIARMgAMIoHhQIAn0E0pDQFC4HhznoAAAAIAI2C0/4lvFqQAAETgBJJwYCAy4ABgYAFAA8MBKYEH4eRhTkAjYeFcgACAYAeABsOqyQ5gRwDayqugEgaIIAtgoACgDmEABmBAWGme5OBJJA2m4cDeoAmITWAXwrMgOgAGwBCh6CBXYF1Tzg1wKAAFdiuABRAFwAXQBsAG8AdgBrAHYAbwCEAHEwfxQBVE5TEQADVFhTBwBDANILAqcCzgLTApQCrQL6vAAMAL8APLhNBKkE6glGKTAU4Dr4N2EYEwBCkABKk8rHAbYBmwIoAiU4Ajf/Aq4CowCAANIChzgaNBsCsTgeODcFXrgClQKdAqQBiQGYAqsCsjTsNHsfNPA0ixsAWTWiOAMFPDQSNCk2BDZHNow2TTZUNhk28Jk9VzI3QkEoAoICoQKwAqcAQAAxBV4FXbS9BW47YkIXP1ciUqs05DS/FwABUwJW11e6nHuYZmSh/RAYA8oMKvZ8KASoUAJYWAJ6ILAsAZSoqjpgA0ocBIhmDgDWAAawRDQoAAcuAj5iAHABZiR2AIgiHgCaAU68ACxuHAG0ygM8MiZIAlgBdF4GagJqAPZOHAMuBgoATkYAsABiAHgAMLoGDPj0HpKEBAAOJgAuALggTAHWAeAMEDbd20Uege0ADwAWADkAQgA9OHd+2MUQZBBhBgNNDkxxPxUQArEPqwvqERoM1irQ090ANK4H8ANYB/ADWANYB/AH8ANYB/ADWANYA1gDWBwP8B/YxRBkD00EcgWTBZAE2wiIJk4RhgctCNdUEnQjHEwDSgEBIypJITuYMxAlR0wRTQgIATZHbKx9PQNMMbBU+pCnA9AyVDlxBgMedhKlAC8PeCE1uk6DekxxpQpQT7NX9wBFBgASqwAS5gBJDSgAUCwGPQBI4zTYABNGAE2bAE3KAExdGABKaAbgAFBXAFCOAFBJABI2SWdObALDOq0//QomCZhvwHdTBkIQHCemEPgMNAG2ATwN7kvZBPIGPATKH34ZGg/OlZ0Ipi3eDO4m5C6igFsj9iqEBe5L9TzeC05RaQ9aC2YJ5DpkgU8DIgEOIowK3g06CG4Q9ArKbA3mEUYHOgPWSZsApgcCCxIdNhW2JhFirQsKOXgG/Br3C5AmsBMqev0F1BoiBk4BKhsAANAu6IWxWjJcHU9gBgQLJiPIFKlQIQ0mQLh4SRocBxYlqgKSQ3FKiFE3HpQh9zw+DWcuFFF9B/Y8BhlQC4I8n0asRQ8R0z6OPUkiSkwtBDaALDAnjAnQD4YMunxzAVoJIgmyDHITMhEYN8YIOgcaLpclJxYIIkaWYJsE+KAD9BPSAwwFQAlCBxQDthwuEy8VKgUOgSXYAvQ21i60ApBWgQEYBcwPJh/gEFFH4Q7qCJwCZgOEJewALhUiABginAhEZABgj9lTBi7MCMhqbSN1A2gU6GIRdAeSDlgHqBw0FcAc4nDJXgyGCSiksAlcAXYJmgFgBOQICjVcjKEgQmdUi1kYnCBiQUBd/QIyDGYVoES+h3kCjA9sEhwBNgF0BzoNAgJ4Ee4RbBCWCOyGBTW2M/k6JgRQIYQgEgooA1BszwsoJvoM+WoBpBJjAw00PnfvZ6xgtyUX/gcaMsZBYSHyC5NPzgydGsIYQ1QvGeUHwAP0GvQn60FYBgADpAQUOk4z7wS+C2oIjAlAAEoOpBgH2BhrCnKM0QEyjAG4mgNYkoQCcJAGOAcMAGgMiAV65gAeAqgIpAAGANADWAA6Aq4HngAaAIZCAT4DKDABIuYCkAOUCDLMAZYwAfQqBBzEDBYA+DhuSwLDsgKAa2ajBd5ZAo8CSjYBTiYEBk9IUgOwcuIA3ABMBhTgSAEWrEvMG+REAeBwLADIAPwABjYHBkIBzgH0bgC4AWALMgmjtLYBTuoqAIQAFmwB2AKKAN4ANgCA8gFUAE4FWvoF1AJQSgESMhksWGIBvAMgATQBDgB6BsyOpsoIIARuB9QCEBwV4gLvLwe2AgMi4BPOQsYCvd9WADIXUu5eZwqoCqdeaAC0YTQHMnM9UQAPH6k+yAdy/BZIiQImSwBQ5gBQQzSaNTFWSTYBpwGqKQK38AFtqwBI/wK37gK3rQK3sAK6280C0gK33AK3zxAAUEIAUD9SklKDArekArw5AEQAzAHCO147WTteO1k7XjtZO147WTteO1kDmChYI03AVU0oJqkKbV9GYewMpw3VRMk6ShPcYFJgMxPJLbgUwhXPJVcZPhq9JwYl5VUKDwUt1GYxCC00dhe9AEApaYNCY4ceMQpMHOhTklT5LRwAskujM7ANrRsWREEFSHXuYisWDwojAmSCAmJDXE6wXDchAqH4AmiZAmYKAp+FOBwMAmY8AmYnBG8EgAN/FAN+kzkHOXgYOYM6JCQCbB4CMjc4CwJtyAJtr/CLADRoRiwBaADfAOIASwYHmQyOAP8MwwAOtgJ3MAJ2o0ACeUxEAni7Hl3cRa9G9AJ8QAJ6yQJ9CgJ88UgBSH5kJQAsFklZSlwWGErNAtECAtDNSygDiFADh+dExpEzAvKiXQQDA69Lz0wuJgTQTU1NsAKLQAKK2cIcCB5EaAa4Ao44Ao5dQZiCAo7aAo5deVG1UzYLUtVUhgKT/AKTDQDqAB1VH1WwVdEHLBwplocy4nhnRTw6ApegAu+zWCKpAFomApaQApZ9nQCqWa1aCoJOADwClrYClk9cRVzSApnMApllXMtdCBoCnJw5wzqeApwXAp+cAp65iwAeEDIrEAKd8gKekwC2PmE1YfACntQCoG8BqgKeoCACnk+mY8lkKCYsAiewAiZ/AqD8AqBN2AKmMAKlzwKoAAB+AqfzaH1osgAESmodatICrOQCrK8CrWgCrQMCVx4CVd0CseLYAx9PbJgCsr4OArLpGGzhbWRtSWADJc4Ctl08QG6RAylGArhfArlIFgK5K3hwN3DiAr0aAy2zAzISAr6JcgMDM3ICvhtzI3NQAsPMAsMFc4N0TDZGdOEDPKgDPJsDPcACxX0CxkgCxhGKAshqUgLIRQLJUALJLwJkngLd03h6YniveSZL0QMYpGcDAmH1GfSVJXsMXpNevBICz2wCz20wTFTT9BSgAMeuAs90ASrrA04TfkwGAtwoAtuLAtJQA1JdA1NgAQIDVY2AikABzBfuYUZ2AILPg44C2sgC2d+EEYRKpz0DhqYAMANkD4ZyWvoAVgLfZgLeuXR4AuIw7RUB8zEoAfScAfLTiALr9ALpcXoAAur6AurlAPpIAboC7ooC652Wq5cEAu5AA4XhmHpw4XGiAvMEAGoDjheZlAL3FAORbwOSiAL3mQL52gL4Z5odmqy8OJsfA52EAv77ARwAOp8dn7QDBY4DpmsDptoA0sYDBmuhiaIGCgMMSgFgASACtgNGAJwEgLpoBgC8BGzAEowcggCEDC6kdjoAJAM0C5IKRoABZCgiAIzw3AYBLACkfng9ogigkgNmWAN6AEQCvrkEVqTGAwCsBRbAA+4iQkMCHR072jI2PTbUNsk2RjY5NvA23TZKNiU3EDcZN5I+RTxDRTBCJkK5VBYKFhZfwQCWygU3AJBRHpu+OytgNxa61A40GMsYjsn7BVwFXQVcBV0FaAVdBVwFXQVcBV0FXAVdBVwFXUsaCNyKAK4AAQUHBwKU7oICoW1e7jAEzgPxA+YDwgCkBFDAwADABKzAAOxFLhitA1UFTDeyPkM+bj51QkRCuwTQWWQ8X+0AWBYzsACNA8xwzAGm7EZ/QisoCTAbLDs6fnLfb8H2GccsbgFw13M1HAVkBW/Jxsm9CNRO8E8FDD0FBQw9FkcClOYCoMFegpDfADgcMiA2AJQACB8AsigKAIzIEAJKeBIApY5yPZQIAKQiHb4fvj5BKSRPQrZCOz0oXyxgOywfKAnGbgMClQaCAkILXgdeCD9IIGUgQj5fPoY+dT52Ao5CM0dAX9BTVG9SDzFwWTQAbxBzJF/lOEIQQglCCkKJIAls5AcClQICoKPMODEFxhi6KSAbiyfIRrMjtCgdWCAkPlFBIitCsEJRzAbMAV/OEyQzDg0OAQQEJ36i328/Mk9AybDJsQlq3tDRApUKAkFzXf1d/j9uALYP6hCoFgCTGD8kPsFKQiobrm0+zj0KSD8kPnVCRBwMDyJRTHFgMTJa5rwXQiQ2YfI/JD7BMEJEHGINTw4TOFlIRzwJO0icMQpyPyQ+wzJCRBv6DVgnKB01NgUKj2bwYzMqCoBkznBgEF+zYDIocwRIX+NgHj4HICNfh2C4CwdwFWpTG/lgUhYGAwRfv2Ts8mAaXzVgml/XYIJfuWC4HI1gUF9pYJZgMR6ilQHMAOwLAlDRefC0in4AXAEJA6PjCwc0IamOANMMCAECRQDFNRTZBgd+CwQlRA+r6+gLBDEFBnwUBXgKATIArwAGRAAHA3cDdAN2A3kDdwN9A3oDdQN7A30DfAN4A3oDfQAYEAAlAtYASwMAUAFsAHcKAHcAmgB3AHUAdQB2AHVu8UgAygDAAHcAdQB1AHYAdQALCgB3AAsAmgB3AAsCOwB3AAtu8UgAygDAAHgKAJoAdwB3AHUAdQB2AHUAeAB1AHUAdgB1bvFIAMoAwAALCgCaAHcACwB3AAsCOwB3AAtu8UgAygDAAH4ACwGgALcBpwC6AahdAu0COwLtbvFIAMoAwAALCgCaAu0ACwLtAAsCOwLtAAtu8UgAygDAA24ACwNvAAu0VsQAAzsAABCkjUIpAAsAUIusOggWcgMeBxVsGwL67U/2HlzmWOEeOgALASvuAAseAfpKUpnpGgYJDCIZM6YyARUE9ThqAD5iXQgnAJYJPnOzw0ZAEZxEKsIAkA4DhAHnTAIDxxUDK0lxCQlPYgIvIQVYJQBVqE1GakUAKGYiDToSBA1EtAYAXQJYAIF8GgMHRyAAIAjOe9YncekRAA0KACUrjwE7Ayc6AAYWAqaiKG4McEcqANoN3+Mg9TwCBhIkuCny+JwUQ29L008JluRxu3K+oAdqiHOqFH0AG5SUIfUJ5SxCGfxdipRzqTmT4V5Zb+r1Uo4Vm+NqSSEl2mNvR2JhIa8SpYO6ntdwFXHCWTCK8f2+Hxo7uiG3drDycAuKIMP5bhi06ACnqArH1rz4Rqg//lm6SgJGEVbF9xJHISaR6HxqxSnkw6shDnelHKNEfGUXSJRJ1GcsmtJw25xrZMDK9gXSm1/YMkdX4/6NKYOdtk/NQ3/NnDASjTc3fPjIjW/5sVfVObX2oTDWkr1dF9f3kxBsD3/3aQO8hPfRz+e0uEiJqt1161griu7gz8hDDwtpy+F+BWtefnKHZPAxcZoWbnznhJpy0e842j36bcNzGnIEusgGX0a8ZxsnjcSsPDZ09yZ36fCQbriHeQ72JRMILNl6ePPf2HWoVwgWAm1fb3V2sAY0+B6rAXqSwPBgseVmoqsBTSrm91+XasMYYySI8eeRxH3ZvHkMz3BQ5aJ3iUVbYPNM3/7emRtjlsMgv/9VyTsyt/mK+8fgWeT6SoFaclXqn42dAIsvAarF5vNNWHzKSkKQ/8Hfk5ZWK7r9yliOsooyBjRhfkHP4Q2DkWXQi6FG/9r/IwbmkV5T7JSopHKn1pJwm9tb5Ot0oyN1Z2mPpKXHTxx2nlK08fKk1hEYA8WgVVWL5lgx0iTv+KdojJeU23ZDjmiubXOxVXJKKi2Wjuh2HLZOFLiSC7Tls5SMh4f+Pj6xUSrNjFqLGehRNB8lC0QSLNmkJJx/wSG3MnjE9T1CkPwJI0wH2lfzwETIiVqUxg0dfu5q39Gt+hwdcxkhhNvQ4TyrBceof3Mhs/IxFci1HmHr4FMZgXEEczPiGCx0HRwzAqDq2j9AVm1kwN0mRVLWLylgtoPNapF5cY4Y1wJh/e0BBwZj44YgZrDNqvD/9Hv7GFYdUQeDJuQ3EWI4HaKqavU1XjC/n41kT4L79kqGq0kLhdTZvgP3TA3fS0ozVz+5piZsoOtIvBUFoMKbNcmBL6YxxaUAusHB38XrS8dQMnQwJfUUkpRoGr5AUeWicvBTzyK9g77+yCkf5PAysL7r/JjcZgrbvRpMW9iyaxZvKO6ceZN2EwIxKwVFPuvFuiEPGCoagbMo+SpydLrXqBzNCDGFCrO/rkcwa2xhokQZ5CdZ0AsU3JfSqJ6n5I14YA+P/uAgfhPU84Tlw7cEFfp7AEE8ey4sP12PTt4Cods1GRgDOB5xvyiR5m+Bx8O5nBCNctU8BevfV5A08x6RHd5jcwPTMDSZJOedIZ1cGQ704lxbAzqZOP05ZxaOghzSdvFBHYqomATARyAADK4elP8Ly3IrUZKfWh23Xy20uBUmLS4Pfagu9+oyVa2iPgqRP3F2CTUsvJ7+RYnN8fFZbU/HVvxvcFFDKkiTqV5UBZ3Gz54JAKByi9hkKMZJvuGgcSYXFmw08UyoQyVdfTD1/dMkCHXcTGAKeROgArsvmRrQTLUOXioOHGK2QkjHuoYFgXciZoTJd6Fs5q1QX1G+p/e26hYsEf7QZD1nnIyl/SFkNtYYmmBhpBrxl9WbY0YpHWRuw2Ll/tj9mD8P4snVzJl4F9J+1arVeTb9E5r2ILH04qStjxQNwn3m4YNqxmaNbLAqW2TN6LidwuJRqS+NXbtqxoeDXpxeGWmxzSkWxjkyCkX4NQRme6q5SAcC+M7+9ETfA/EwrzQajKakCwYyeunP6ZFlxU2oMEn1Pz31zeStW74G406ZJFCl1wAXIoUKkWotYEpOuXB1uVNxJ63dpJEqfxBeptwIHNrPz8BllZoIcBoXwgfJ+8VAUnVPvRvexnw0Ma/WiGYuJO5y8QTvEYBigFmhUxY5RqzE8OcywN/8m4UYrlaniJO75XQ6KSo9+tWHlu+hMi0UVdiKQp7NelnoZUzNaIyBPVeOwK6GNp+FfHuPOoyhaWuNvTYFkvxscMQWDh+zeFCFkgwbXftiV23ywJ4+uwRqmg9k3KzwIQpzppt8DBBOMbrqwQM5Gb05sEwdKzMiAqOloaA/lr0KA+1pr0/+HiWoiIjHA/wir2nIuS3PeU/ji3O6ZwoxcR1SZ9FhtLC5S0FIzFhbBWcGVP/KpxOPSiUoAdWUpqKH++6Scz507iCcxYI6rdMBICPJZea7OcmeFw5mObJSiqpjg2UoWNIs+cFhyDSt6geV5qgi3FunmwwDoGSMgerFOZGX1m0dMCYo5XOruxO063dwENK9DbnVM9wYFREzh4vyU1WYYJ/LRRp6oxgjqP/X5a8/4Af6p6NWkQferzBmXme0zY/4nwMJm/wd1tIqSwGz+E3xPEAOoZlJit3XddD7/BT1pllzOx+8bmQtANQ/S6fZexc6qi3W+Q2xcmXTUhuS5mpHQRvcxZUN0S5+PL9lXWUAaRZhEH8hTdAcuNMMCuVNKTEGtSUKNi3O6KhSaTzck8csZ2vWRZ+d7mW8c4IKwXIYd25S/zIftPkwPzufjEvOHWVD1m+FjpDVUTV0DGDuHj6QnaEwLu/dEgdLQOg9E1Sro9XHJ8ykLAwtPu+pxqKDuFexqON1sKQm7rwbE1E68UCfA/erovrTCG+DBSNg0l4goDQvZN6uNlbyLpcZAwj2UclycvLpIZMgv4yRlpb3YuMftozorbcGVHt/VeDV3+Fdf1TP0iuaCsPi2G4XeGhsyF1ubVDxkoJhmniQ0/jSg/eYML9KLfnCFgISWkp91eauR3IQvED0nAPXK+6hPCYs+n3+hCZbiskmVMG2da+0EsZPonUeIY8EbfusQXjsK/eFDaosbPjEfQS0RKG7yj5GG69M7MeO1HmiUYocgygJHL6M1qzUDDwUSmr99V7Sdr2F3JjQAJY+F0yH33Iv3+C9M38eML7gTgmNu/r2bUMiPvpYbZ6v1/IaESirBHNa7mPKn4dEmYg7v/+HQgPN1G79jBQ1+soydfDC2r+h2Bl/KIc5KjMK7OH6nb1jLsNf0EHVe2KBiE51ox636uyG6Lho0t3J34L5QY/ilE3mikaF4HKXG1mG1rCevT1Vv6GavltxoQe/bMrpZvRggnBxSEPEeEzkEdOxTnPXHVjUYdw8JYvjB/o7Eegc3Ma+NUxLLnsK0kJlinPmUHzHGtrk5+CAbVzFOBqpyy3QVUnzTDfC/0XD94/okH+OB+i7g9lolhWIjSnfIb+Eq43ZXOWmwvjyV/qqD+t0e+7mTEM74qP/Ozt8nmC7mRpyu63OB4KnUzFc074SqoyPUAgM+/TJGFo6T44EHnQU4X4z6qannVqgw/U7zCpwcmXV1AubIrvOmkKHazJAR55ePjp5tLBsN8vAqs3NAHdcEHOR2xQ0lsNAFzSUuxFQCFYvXLZJdOj9p4fNq6p0HBGUik2YzaI4xySy91KzhQ0+q1hjxvImRwPRf76tChlRkhRCi74NXZ9qUNeIwP+s5p+3m5nwPdNOHgSLD79n7O9m1n1uDHiMntq4nkYwV5OZ1ENbXxFd4PgrlvavZsyUO4MqYlqqn1O8W/I1dEZq5dXhrbETLaZIbC2Kj/Aa/QM+fqUOHdf0tXAQ1huZ3cmWECWSXy/43j35+Mvq9xws7JKseriZ1pEWKc8qlzNrGPUGcVgOa9cPJYIJsGnJTAUsEcDOEVULO5x0rXBijc1lgXEzQQKhROf8zIV82w8eswc78YX11KYLWQRcgHNJElBxfXr72lS2RBSl07qTKorO2uUDZr3sFhYsvnhLZn0A94KRzJ/7DEGIAhW5ZWFpL8gEwu1aLA9MuWZzNwl8Oze9Y+bX+v9gywRVnoB5I/8kXTXU3141yRLYrIOOz6SOnyHNy4SieqzkBXharjfjqq1q6tklaEbA8Qfm2DaIPs7OTq/nvJBjKfO2H9bH2cCMh1+5gspfycu8f/cuuRmtDjyqZ7uCIMyjdV3a+p3fqmXsRx4C8lujezIFHnQiVTXLXuI1XrwN3+siYYj2HHTvESUx8DlOTXpak9qFRK+L3mgJ1WsD7F4cu1aJoFoYQnu+wGDMOjJM3kiBQWHCcvhJ/HRdxodOQp45YZaOTA22Nb4XKCVxqkbwMYFhzYQYIAnCW8FW14uf98jhUG2zrKhQQ0q0CEq0t5nXyvUyvR8DvD69LU+g3i+HFWQMQ8PqZuHD+sNKAV0+M6EJC0szq7rEr7B5bQ8BcNHzvDMc9eqB5ZCQdTf80Obn4uzjwpYU7SISdtV0QGa9D3Wrh2BDQtpBKxaNFV+/Cy2P/Sv+8s7Ud0Fd74X4+o/TNztWgETUapy+majNQ68Lq3ee0ZO48VEbTZYiH1Co4OlfWef82RWeyUXo7woM03PyapGfikTnQinoNq5z5veLpeMV3HCAMTaZmA1oGLAn7XS3XYsz+XK7VMQsc4XKrmDXOLU/pSXVNUq8dIqTba///3x6LiLS6xs1xuCAYSfcQ3+rQgmu7uvf3THKt5Ooo97TqcbRqxx7EASizaQCBQllG/rYxVapMLgtLbZS64w1MDBMXX+PQpBKNwqUKOf2DDRDUXQf9EhOS0Qj4nTmlA8dzSLz/G1d+Ud8MTy/6ghhdiLpeerGY/UlDOfiuqFsMUU5/UYlP+BAmgRLuNpvrUaLlVkrqDievNVEAwF+4CoM1MZTmjxjJMsKJq+u8Zd7tNCUFy6LiyYXRJQ4VyvEQFFaCGKsxIwQkk7EzZ6LTJq2hUuPhvAW+gQnSG6J+MszC+7QCRHcnqDdyNRJ6T9xyS87A6MDutbzKGvGktpbXqtzWtXb9HsfK2cBMomjN9a4y+TaJLnXxAeX/HWzmf4cR4vALt/P4w4qgKY04ml4ZdLOinFYS6cup3G/1ie4+t1eOnpBNlqGqs75ilzkT4+DsZQxNvaSKJ//6zIbbk/M7LOhFmRc/1R+kBtz7JFGdZm/COotIdvQoXpTqP/1uqEUmCb/QWoGLMwO5ANcHzxdY48IGP5+J+zKOTBFZ4Pid+GTM+Wq12MV/H86xEJptBa6T+p3kgpwLedManBHC2GgNrFpoN2xnrMz9WFWX/8/ygSBkavq2Uv7FdCsLEYLu9LLIvAU0bNRDtzYl+/vXmjpIvuJFYjmI0im6QEYqnIeMsNjXG4vIutIGHijeAG/9EDBozKV5cldkHbLxHh25vT+ZEzbhXlqvpzKJwcEgfNwLAKFeo0/pvEE10XDB+EXRTXtSzJozQKFFAJhMxYkVaCW+E9AL7tMeU8acxidHqzb6lX4691UsDpy/LLRmT+epgW56+5Cw8tB4kMUv6s9lh3eRKbyGs+H/4mQMaYzPTf2OOdokEn+zzgvoD3FqNKk8QqGAXVsqcGdXrT62fSPkR2vROFi68A6se86UxRUk4cajfPyCC4G5wDhD+zNq4jodQ4u4n/m37Lr36n4LIAAsVr02dFi9AiwA81MYs2rm4eDlDNmdMRvEKRHfBwW5DdMNp0jPFZMeARqF/wL4XBfd+EMLBfMzpH5GH6NaW+1vrvMdg+VxDzatk3MXgO3ro3P/DpcC6+Mo4MySJhKJhSR01SGGGp5hPWmrrUgrv3lDnP+HhcI3nt3YqBoVAVTBAQT5iuhTg8nvPtd8ZeYj6w1x6RqGUBrSku7+N1+BaasZvjTk64RoIDlL8brpEcJx3OmY7jLoZsswdtmhfC/G21llXhITOwmvRDDeTTPbyASOa16cF5/A1fZAidJpqju3wYAy9avPR1ya6eNp9K8XYrrtuxlqi+bDKwlfrYdR0RRiKRVTLOH85+ZY7XSmzRpfZBJjaTa81VDcJHpZnZnSQLASGYW9l51ZV/h7eVzTi3Hv6hUsgc/51AqJRTkpbFVLXXszoBL8nBX0u/0jBLT8nH+fJePbrwURT58OY+UieRjd1vs04w0VG5VN2U6MoGZkQzKN/ptz0Q366dxoTGmj7i1NQGHi9GgnquXFYdrCfZBmeb7s0T6yrdlZH5cZuwHFyIJ/kAtGsTg0xH5taAAq44BAk1CPk9KVVbqQzrCUiFdF/6gtlPQ8bHHc1G1W92MXGZ5HEHftyLYs8mbD/9xYRUWkHmlM0zC2ilJlnNgV4bfALpQghxOUoZL7VTqtCHIaQSXm+YUMnpkXybnV+A6xlm2CVy8fn0Xlm2XRa0+zzOa21JWWmixfiPMSCZ7qA4rS93VN3pkpF1s5TonQjisHf7iU9ZGvUPOAKZcR1pbeVf/Ul7OhepGCaId9wOtqo7pJ7yLcBZ0pFkOF28y4zEI/kcUNmutBHaQpBdNM8vjCS6HZRokkeo88TBAjGyG7SR+6vUgTcyK9Imalj0kuxz0wmK+byQU11AiJFk/ya5dNduRClcnU64yGu/ieWSeOos1t3ep+RPIWQ2pyTYVbZltTbsb7NiwSi3AV+8KLWk7LxCnfZUetEM8ThnsSoGH38/nyAwFguJp8FjvlHtcWZuU4hPva0rHfr0UhOOJ/F6vS62FW7KzkmRll2HEc7oUq4fyi5T70Vl7YVIfsPHUCdHesf9Lk7WNVWO75JDkYbMI8TOW8JKVtLY9d6UJRITO8oKo0xS+o99Yy04iniGHAaGj88kEWgwv0OrHdY/nr76DOGNS59hXCGXzTKUvDl9iKpLSWYN1lxIeyywdNpTkhay74w2jFT6NS8qkjo5CxA1yfSYwp6AJIZNKIeEK5PJAW7ORgWgwp0VgzYpqovMrWxbu+DGZ6Lhie1RAqpzm8VUzKJOH3mCzWuTOLsN3VT/dv2eeYe9UjbR8YTBsLz7q60VN1sU51k+um1f8JxD5pPhbhSC8rRaB454tmh6YUWrJI3+GWY0qeWioj/tbkYITOkJaeuGt4JrJvHA+l0Gu7kY7XOaa05alMnRWVCXqFgLIwSY4uF59Ue5SU4QKuc/HamDxbr0x6csCetXGoP7Qn1Bk/J9DsynO/UD6iZ1Hyrz+jit0hDCwi/E9OjgKTbB3ZQKQ/0ZOvevfNHG0NK4Aj3Cp7NpRk07RT1i/S0EL93Ag8GRgKI9CfpajKyK6+Jj/PI1KO5/85VAwz2AwzP8FTBb075IxCXv6T9RVvWT2tUaqxDS92zrGUbWzUYk9mSs82pECH+fkqsDt93VW++4YsR/dHCYcQSYTO/KaBMDj9LSD/J/+z20Kq8XvZUAIHtm9hRPP3ItbuAu2Hm5lkPs92pd7kCxgRs0xOVBnZ13ccdA0aunrwv9SdqElJRC3g+oCu+nXyCgmXUs9yMjTMAIHfxZV+aPKcZeUBWt057Xo85Ks1Ir5gzEHCWqZEhrLZMuF11ziGtFQUds/EESajhagzcKsxamcSZxGth4UII+adPhQkUnx2WyN+4YWR+r3f8MnkyGFuR4zjzxJS8WsQYR5PTyRaD9ixa6Mh741nBHbzfjXHskGDq179xaRNrCIB1z1xRfWfjqw2pHc1zk9xlPpL8sQWAIuETZZhbnmL54rceXVNRvUiKrrqIkeogsl0XXb17ylNb0f4GA9Wd44vffEG8FSZGHEL2fbaTGRcSiCeA8PmA/f6Hz8HCS76fXUHwgwkzSwlI71ekZ7Fapmlk/KC+Hs8hUcw3N2LN5LhkVYyizYFl/uPeVP5lsoJHhhfWvvSWruCUW1ZcJOeuTbrDgywJ/qG07gZJplnTvLcYdNaH0KMYOYMGX+rB4NGPFmQsNaIwlWrfCezxre8zXBrsMT+edVLbLqN1BqB76JH4BvZTqUIMfGwPGEn+EnmTV86fPBaYbFL3DFEhjB45CewkXEAtJxk4/Ms2pPXnaRqdky0HOYdcUcE2zcXq4vaIvW2/v0nHFJH2XXe22ueDmq/18XGtELSq85j9X8q0tcNSSKJIX8FTuJF/Pf8j5PhqG2u+osvsLxYrvvfeVJL+4tkcXcr9JV7v0ERmj/X6fM3NC4j6dS1+9Umr2oPavqiAydTZPLMNRGY23LO9zAVDly7jD+70G5TPPLdhRIl4WxcYjLnM+SNcJ26FOrkrISUtPObIz5Zb3AG612krnpy15RMW+1cQjlnWFI6538qky9axd2oJmHIHP08KyP0ubGO+TQNOYuv2uh17yCIvR8VcStw7o1g0NM60sk+8Tq7YfIBJrtp53GkvzXH7OA0p8/n/u1satf/VJhtR1l8Wa6Gmaug7haSpaCaYQax6ta0mkutlb+eAOSG1aobM81D9A4iS1RRlzBBoVX6tU1S6WE2N9ORY6DfeLRC4l9Rvr5h95XDWB2mR1d4WFudpsgVYwiTwT31ljskD8ZyDOlm5DkGh9N/UB/0AI5Xvb8ZBmai2hQ4BWMqFwYnzxwB26YHSOv9WgY3JXnvoN+2R4rqGVh/LLDMtpFP+SpMGJNWvbIl5SOodbCczW2RKleksPoUeGEzrjtKHVdtZA+kfqO+rVx/iclCqwoopepvJpSTDjT+b9GWylGRF8EDbGlw6eUzmJM95Ovoz+kwLX3c2fTjFeYEsE7vUZm3mqdGJuKh2w9/QGSaqRHs99aScGOdDqkFcACoqdbBoQqqjamhH6Q9ng39JCg3lrGJwd50Qk9ovnqBTr8MME7Ps2wiVfygUmPoUBJJfJWX5Nda0nuncbFkA=='));\n}\n//# sourceMappingURL=include.js.map","/**\n * MIT License\n *\n * Copyright (c) 2021 Andrew Raffensperger\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n *\n * This is a near carbon-copy of the original source (link below) with the\n * TypeScript typings added and a few tweaks to make it ES3-compatible.\n *\n * See: https://github.com/adraffy/ens-normalize.js\n */\nimport { toUtf8CodePoints } from \"@ethersproject/strings\";\nimport { getData } from './include.js';\nconst r = getData();\nimport { read_member_array, read_mapped_map, read_emoji_trie } from './decoder.js';\n// @TODO: This should be lazily loaded\nconst VALID = new Set(read_member_array(r));\nconst IGNORED = new Set(read_member_array(r));\nconst MAPPED = read_mapped_map(r);\nconst EMOJI_ROOT = read_emoji_trie(r);\n//const NFC_CHECK = new Set(read_member_array(r, Array.from(VALID.values()).sort((a, b) => a - b)));\n//const STOP = 0x2E;\nconst HYPHEN = 0x2D;\nconst UNDERSCORE = 0x5F;\nfunction explode_cp(name) {\n    return toUtf8CodePoints(name);\n}\nfunction filter_fe0f(cps) {\n    return cps.filter(cp => cp != 0xFE0F);\n}\nexport function ens_normalize_post_check(name) {\n    for (let label of name.split('.')) {\n        let cps = explode_cp(label);\n        try {\n            for (let i = cps.lastIndexOf(UNDERSCORE) - 1; i >= 0; i--) {\n                if (cps[i] !== UNDERSCORE) {\n                    throw new Error(`underscore only allowed at start`);\n                }\n            }\n            if (cps.length >= 4 && cps.every(cp => cp < 0x80) && cps[2] === HYPHEN && cps[3] === HYPHEN) {\n                throw new Error(`invalid label extension`);\n            }\n        }\n        catch (err) {\n            throw new Error(`Invalid label \"${label}\": ${err.message}`);\n        }\n    }\n    return name;\n}\nexport function ens_normalize(name) {\n    return ens_normalize_post_check(normalize(name, filter_fe0f));\n}\nfunction normalize(name, emoji_filter) {\n    let input = explode_cp(name).reverse(); // flip for pop\n    let output = [];\n    while (input.length) {\n        let emoji = consume_emoji_reversed(input);\n        if (emoji) {\n            output.push(...emoji_filter(emoji));\n            continue;\n        }\n        let cp = input.pop();\n        if (VALID.has(cp)) {\n            output.push(cp);\n            continue;\n        }\n        if (IGNORED.has(cp)) {\n            continue;\n        }\n        let cps = MAPPED[cp];\n        if (cps) {\n            output.push(...cps);\n            continue;\n        }\n        throw new Error(`Disallowed codepoint: 0x${cp.toString(16).toUpperCase()}`);\n    }\n    return ens_normalize_post_check(nfc(String.fromCodePoint(...output)));\n}\nfunction nfc(s) {\n    return s.normalize('NFC');\n}\nfunction consume_emoji_reversed(cps, eaten) {\n    var _a;\n    let node = EMOJI_ROOT;\n    let emoji;\n    let saved;\n    let stack = [];\n    let pos = cps.length;\n    if (eaten)\n        eaten.length = 0; // clear input buffer (if needed)\n    while (pos) {\n        let cp = cps[--pos];\n        node = (_a = node.branches.find(x => x.set.has(cp))) === null || _a === void 0 ? void 0 : _a.node;\n        if (!node)\n            break;\n        if (node.save) { // remember\n            saved = cp;\n        }\n        else if (node.check) { // check exclusion\n            if (cp === saved)\n                break;\n        }\n        stack.push(cp);\n        if (node.fe0f) {\n            stack.push(0xFE0F);\n            if (pos > 0 && cps[pos - 1] == 0xFE0F)\n                pos--; // consume optional FE0F\n        }\n        if (node.valid) { // this is a valid emoji (so far)\n            emoji = stack.slice(); // copy stack\n            if (node.valid == 2)\n                emoji.splice(1, 1); // delete FE0F at position 1 (RGI ZWJ don't follow spec!)\n            if (eaten)\n                eaten.push(...cps.slice(pos).reverse()); // copy input (if needed)\n            cps.length = pos; // truncate\n        }\n    }\n    return emoji;\n}\n//# sourceMappingURL=lib.js.map","import { concat, hexlify } from \"@ethersproject/bytes\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { ens_normalize } from \"./ens-normalize/lib\";\nconst Zeros = new Uint8Array(32);\nZeros.fill(0);\nfunction checkComponent(comp) {\n    if (comp.length === 0) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    return comp;\n}\nfunction ensNameSplit(name) {\n    const bytes = toUtf8Bytes(ens_normalize(name));\n    const comps = [];\n    if (name.length === 0) {\n        return comps;\n    }\n    let last = 0;\n    for (let i = 0; i < bytes.length; i++) {\n        const d = bytes[i];\n        // A separator (i.e. \".\"); copy this component\n        if (d === 0x2e) {\n            comps.push(checkComponent(bytes.slice(last, i)));\n            last = i + 1;\n        }\n    }\n    // There was a stray separator at the end of the name\n    if (last >= bytes.length) {\n        throw new Error(\"invalid ENS name; empty component\");\n    }\n    comps.push(checkComponent(bytes.slice(last)));\n    return comps;\n}\nexport function ensNormalize(name) {\n    return ensNameSplit(name).map((comp) => toUtf8String(comp)).join(\".\");\n}\nexport function isValidName(name) {\n    try {\n        return (ensNameSplit(name).length !== 0);\n    }\n    catch (error) { }\n    return false;\n}\nexport function namehash(name) {\n    /* istanbul ignore if */\n    if (typeof (name) !== \"string\") {\n        logger.throwArgumentError(\"invalid ENS name; not a string\", \"name\", name);\n    }\n    let result = Zeros;\n    const comps = ensNameSplit(name);\n    while (comps.length) {\n        result = keccak256(concat([result, keccak256(comps.pop())]));\n    }\n    return hexlify(result);\n}\nexport function dnsEncode(name) {\n    return hexlify(concat(ensNameSplit(name).map((comp) => {\n        // DNS does not allow components over 63 bytes in length\n        if (comp.length > 63) {\n            throw new Error(\"invalid DNS encoded entry; length exceeds 63 bytes\");\n        }\n        const bytes = new Uint8Array(comp.length + 1);\n        bytes.set(comp, 1);\n        bytes[0] = bytes.length - 1;\n        return bytes;\n    }))) + \"00\";\n}\n//# sourceMappingURL=namehash.js.map","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, hexConcat, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { deepCopy, defineReadOnly, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { id } from \"./id\";\nconst padding = new Uint8Array(32);\npadding.fill(0);\nconst NegativeOne = BigNumber.from(-1);\nconst Zero = BigNumber.from(0);\nconst One = BigNumber.from(1);\nconst MaxUint256 = BigNumber.from(\"0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\nfunction hexPadRight(value) {\n    const bytes = arrayify(value);\n    const padOffset = bytes.length % 32;\n    if (padOffset) {\n        return hexConcat([bytes, padding.slice(padOffset)]);\n    }\n    return hexlify(bytes);\n}\nconst hexTrue = hexZeroPad(One.toHexString(), 32);\nconst hexFalse = hexZeroPad(Zero.toHexString(), 32);\nconst domainFieldTypes = {\n    name: \"string\",\n    version: \"string\",\n    chainId: \"uint256\",\n    verifyingContract: \"address\",\n    salt: \"bytes32\"\n};\nconst domainFieldNames = [\n    \"name\", \"version\", \"chainId\", \"verifyingContract\", \"salt\"\n];\nfunction checkString(key) {\n    return function (value) {\n        if (typeof (value) !== \"string\") {\n            logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);\n        }\n        return value;\n    };\n}\nconst domainChecks = {\n    name: checkString(\"name\"),\n    version: checkString(\"version\"),\n    chainId: function (value) {\n        try {\n            return BigNumber.from(value).toString();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value for \"chainId\"`, \"domain.chainId\", value);\n    },\n    verifyingContract: function (value) {\n        try {\n            return getAddress(value).toLowerCase();\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"verifyingContract\"`, \"domain.verifyingContract\", value);\n    },\n    salt: function (value) {\n        try {\n            const bytes = arrayify(value);\n            if (bytes.length !== 32) {\n                throw new Error(\"bad length\");\n            }\n            return hexlify(bytes);\n        }\n        catch (error) { }\n        return logger.throwArgumentError(`invalid domain value \"salt\"`, \"domain.salt\", value);\n    }\n};\nfunction getBaseEncoder(type) {\n    // intXX and uintXX\n    {\n        const match = type.match(/^(u?)int(\\d*)$/);\n        if (match) {\n            const signed = (match[1] === \"\");\n            const width = parseInt(match[2] || \"256\");\n            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {\n                logger.throwArgumentError(\"invalid numeric width\", \"type\", type);\n            }\n            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);\n            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;\n            return function (value) {\n                const v = BigNumber.from(value);\n                if (v.lt(boundsLower) || v.gt(boundsUpper)) {\n                    logger.throwArgumentError(`value out-of-bounds for ${type}`, \"value\", value);\n                }\n                return hexZeroPad(v.toTwos(256).toHexString(), 32);\n            };\n        }\n    }\n    // bytesXX\n    {\n        const match = type.match(/^bytes(\\d+)$/);\n        if (match) {\n            const width = parseInt(match[1]);\n            if (width === 0 || width > 32 || match[1] !== String(width)) {\n                logger.throwArgumentError(\"invalid bytes width\", \"type\", type);\n            }\n            return function (value) {\n                const bytes = arrayify(value);\n                if (bytes.length !== width) {\n                    logger.throwArgumentError(`invalid length for ${type}`, \"value\", value);\n                }\n                return hexPadRight(value);\n            };\n        }\n    }\n    switch (type) {\n        case \"address\": return function (value) {\n            return hexZeroPad(getAddress(value), 32);\n        };\n        case \"bool\": return function (value) {\n            return ((!value) ? hexFalse : hexTrue);\n        };\n        case \"bytes\": return function (value) {\n            return keccak256(value);\n        };\n        case \"string\": return function (value) {\n            return id(value);\n        };\n    }\n    return null;\n}\nfunction encodeType(name, fields) {\n    return `${name}(${fields.map(({ name, type }) => (type + \" \" + name)).join(\",\")})`;\n}\nexport class TypedDataEncoder {\n    constructor(types) {\n        defineReadOnly(this, \"types\", Object.freeze(deepCopy(types)));\n        defineReadOnly(this, \"_encoderCache\", {});\n        defineReadOnly(this, \"_types\", {});\n        // Link struct types to their direct child structs\n        const links = {};\n        // Link structs to structs which contain them as a child\n        const parents = {};\n        // Link all subtypes within a given struct\n        const subtypes = {};\n        Object.keys(types).forEach((type) => {\n            links[type] = {};\n            parents[type] = [];\n            subtypes[type] = {};\n        });\n        for (const name in types) {\n            const uniqueNames = {};\n            types[name].forEach((field) => {\n                // Check each field has a unique name\n                if (uniqueNames[field.name]) {\n                    logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, \"types\", types);\n                }\n                uniqueNames[field.name] = true;\n                // Get the base type (drop any array specifiers)\n                const baseType = field.type.match(/^([^\\x5b]*)(\\x5b|$)/)[1];\n                if (baseType === name) {\n                    logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Is this a base encoding type?\n                const encoder = getBaseEncoder(baseType);\n                if (encoder) {\n                    return;\n                }\n                if (!parents[baseType]) {\n                    logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, \"types\", types);\n                }\n                // Add linkage\n                parents[baseType].push(name);\n                links[name][baseType] = true;\n            });\n        }\n        // Deduce the primary type\n        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));\n        if (primaryTypes.length === 0) {\n            logger.throwArgumentError(\"missing primary type\", \"types\", types);\n        }\n        else if (primaryTypes.length > 1) {\n            logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(\", \")}`, \"types\", types);\n        }\n        defineReadOnly(this, \"primaryType\", primaryTypes[0]);\n        // Check for circular type references\n        function checkCircular(type, found) {\n            if (found[type]) {\n                logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, \"types\", types);\n            }\n            found[type] = true;\n            Object.keys(links[type]).forEach((child) => {\n                if (!parents[child]) {\n                    return;\n                }\n                // Recursively check children\n                checkCircular(child, found);\n                // Mark all ancestors as having this decendant\n                Object.keys(found).forEach((subtype) => {\n                    subtypes[subtype][child] = true;\n                });\n            });\n            delete found[type];\n        }\n        checkCircular(this.primaryType, {});\n        // Compute each fully describe type\n        for (const name in subtypes) {\n            const st = Object.keys(subtypes[name]);\n            st.sort();\n            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join(\"\");\n        }\n    }\n    getEncoder(type) {\n        let encoder = this._encoderCache[type];\n        if (!encoder) {\n            encoder = this._encoderCache[type] = this._getEncoder(type);\n        }\n        return encoder;\n    }\n    _getEncoder(type) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return encoder;\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const subEncoder = this.getEncoder(subtype);\n            const length = parseInt(match[3]);\n            return (value) => {\n                if (length >= 0 && value.length !== length) {\n                    logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n                }\n                let result = value.map(subEncoder);\n                if (this._types[subtype]) {\n                    result = result.map(keccak256);\n                }\n                return keccak256(hexConcat(result));\n            };\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            const encodedType = id(this._types[type]);\n            return (value) => {\n                const values = fields.map(({ name, type }) => {\n                    const result = this.getEncoder(type)(value[name]);\n                    if (this._types[type]) {\n                        return keccak256(result);\n                    }\n                    return result;\n                });\n                values.unshift(encodedType);\n                return hexConcat(values);\n            };\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    encodeType(name) {\n        const result = this._types[name];\n        if (!result) {\n            logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, \"name\", name);\n        }\n        return result;\n    }\n    encodeData(type, value) {\n        return this.getEncoder(type)(value);\n    }\n    hashStruct(name, value) {\n        return keccak256(this.encodeData(name, value));\n    }\n    encode(value) {\n        return this.encodeData(this.primaryType, value);\n    }\n    hash(value) {\n        return this.hashStruct(this.primaryType, value);\n    }\n    _visit(type, value, callback) {\n        // Basic encoder type (address, bool, uint256, etc)\n        {\n            const encoder = getBaseEncoder(type);\n            if (encoder) {\n                return callback(type, value);\n            }\n        }\n        // Array\n        const match = type.match(/^(.*)(\\x5b(\\d*)\\x5d)$/);\n        if (match) {\n            const subtype = match[1];\n            const length = parseInt(match[3]);\n            if (length >= 0 && value.length !== length) {\n                logger.throwArgumentError(\"array length mismatch; expected length ${ arrayLength }\", \"value\", value);\n            }\n            return value.map((v) => this._visit(subtype, v, callback));\n        }\n        // Struct\n        const fields = this.types[type];\n        if (fields) {\n            return fields.reduce((accum, { name, type }) => {\n                accum[name] = this._visit(type, value[name], callback);\n                return accum;\n            }, {});\n        }\n        return logger.throwArgumentError(`unknown type: ${type}`, \"type\", type);\n    }\n    visit(value, callback) {\n        return this._visit(this.primaryType, value, callback);\n    }\n    static from(types) {\n        return new TypedDataEncoder(types);\n    }\n    static getPrimaryType(types) {\n        return TypedDataEncoder.from(types).primaryType;\n    }\n    static hashStruct(name, types, value) {\n        return TypedDataEncoder.from(types).hashStruct(name, value);\n    }\n    static hashDomain(domain) {\n        const domainFields = [];\n        for (const name in domain) {\n            const type = domainFieldTypes[name];\n            if (!type) {\n                logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, \"domain\", domain);\n            }\n            domainFields.push({ name, type });\n        }\n        domainFields.sort((a, b) => {\n            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);\n        });\n        return TypedDataEncoder.hashStruct(\"EIP712Domain\", { EIP712Domain: domainFields }, domain);\n    }\n    static encode(domain, types, value) {\n        return hexConcat([\n            \"0x1901\",\n            TypedDataEncoder.hashDomain(domain),\n            TypedDataEncoder.from(types).hash(value)\n        ]);\n    }\n    static hash(domain, types, value) {\n        return keccak256(TypedDataEncoder.encode(domain, types, value));\n    }\n    // Replaces all address types with ENS names with their looked up address\n    static resolveNames(domain, types, value, resolveName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Make a copy to isolate it from the object passed in\n            domain = shallowCopy(domain);\n            // Look up all ENS names\n            const ensCache = {};\n            // Do we need to look up the domain's verifyingContract?\n            if (domain.verifyingContract && !isHexString(domain.verifyingContract, 20)) {\n                ensCache[domain.verifyingContract] = \"0x\";\n            }\n            // We are going to use the encoder to visit all the base values\n            const encoder = TypedDataEncoder.from(types);\n            // Get a list of all the addresses\n            encoder.visit(value, (type, value) => {\n                if (type === \"address\" && !isHexString(value, 20)) {\n                    ensCache[value] = \"0x\";\n                }\n                return value;\n            });\n            // Lookup each name\n            for (const name in ensCache) {\n                ensCache[name] = yield resolveName(name);\n            }\n            // Replace the domain verifyingContract if needed\n            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {\n                domain.verifyingContract = ensCache[domain.verifyingContract];\n            }\n            // Replace all ENS names with their address\n            value = encoder.visit(value, (type, value) => {\n                if (type === \"address\" && ensCache[value]) {\n                    return ensCache[value];\n                }\n                return value;\n            });\n            return { domain, value };\n        });\n    }\n    static getPayload(domain, types, value) {\n        // Validate the domain fields\n        TypedDataEncoder.hashDomain(domain);\n        // Derive the EIP712Domain Struct reference type\n        const domainValues = {};\n        const domainTypes = [];\n        domainFieldNames.forEach((name) => {\n            const value = domain[name];\n            if (value == null) {\n                return;\n            }\n            domainValues[name] = domainChecks[name](value);\n            domainTypes.push({ name, type: domainFieldTypes[name] });\n        });\n        const encoder = TypedDataEncoder.from(types);\n        const typesWithDomain = shallowCopy(types);\n        if (typesWithDomain.EIP712Domain) {\n            logger.throwArgumentError(\"types must not contain EIP712Domain type\", \"types.EIP712Domain\", types);\n        }\n        else {\n            typesWithDomain.EIP712Domain = domainTypes;\n        }\n        // Validate the data structures and types\n        encoder.encode(value);\n        return {\n            types: typesWithDomain,\n            domain: domainValues,\n            primaryType: encoder.primaryType,\n            message: encoder.visit(value, (type, value) => {\n                // bytes\n                if (type.match(/^bytes(\\d*)/)) {\n                    return hexlify(arrayify(value));\n                }\n                // uint or int\n                if (type.match(/^u?int/)) {\n                    return BigNumber.from(value).toString();\n                }\n                switch (type) {\n                    case \"address\":\n                        return value.toLowerCase();\n                    case \"bool\":\n                        return !!value;\n                    case \"string\":\n                        if (typeof (value) !== \"string\") {\n                            logger.throwArgumentError(`invalid string`, \"value\", value);\n                        }\n                        return value;\n                }\n                return logger.throwArgumentError(\"unsupported type\", \"type\", type);\n            })\n        };\n    }\n}\n//# sourceMappingURL=typed-data.js.map","\"use strict\";\nimport { getAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexDataSlice, hexlify, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { id } from \"@ethersproject/hash\";\nimport { keccak256 } from \"@ethersproject/keccak256\";\nimport { defineReadOnly, Description, getStatic } from \"@ethersproject/properties\";\nimport { defaultAbiCoder } from \"./abi-coder\";\nimport { checkResultErrors } from \"./coders/abstract-coder\";\nimport { ConstructorFragment, EventFragment, FormatTypes, Fragment, FunctionFragment, ParamType } from \"./fragments\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport { checkResultErrors };\nexport class LogDescription extends Description {\n}\nexport class TransactionDescription extends Description {\n}\nexport class ErrorDescription extends Description {\n}\nexport class Indexed extends Description {\n    static isIndexed(value) {\n        return !!(value && value._isIndexed);\n    }\n}\nconst BuiltinErrors = {\n    \"0x08c379a0\": { signature: \"Error(string)\", name: \"Error\", inputs: [\"string\"], reason: true },\n    \"0x4e487b71\": { signature: \"Panic(uint256)\", name: \"Panic\", inputs: [\"uint256\"] }\n};\nfunction wrapAccessError(property, error) {\n    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);\n    wrap.error = error;\n    return wrap;\n}\n/*\nfunction checkNames(fragment: Fragment, type: \"input\" | \"output\", params: Array<ParamType>): void {\n    params.reduce((accum, param) => {\n        if (param.name) {\n            if (accum[param.name]) {\n                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format(\"full\") }`, \"fragment\", fragment);\n            }\n            accum[param.name] = true;\n        }\n        return accum;\n    }, <{ [ name: string ]: boolean }>{ });\n}\n*/\nexport class Interface {\n    constructor(fragments) {\n        let abi = [];\n        if (typeof (fragments) === \"string\") {\n            abi = JSON.parse(fragments);\n        }\n        else {\n            abi = fragments;\n        }\n        defineReadOnly(this, \"fragments\", abi.map((fragment) => {\n            return Fragment.from(fragment);\n        }).filter((fragment) => (fragment != null)));\n        defineReadOnly(this, \"_abiCoder\", getStatic(new.target, \"getAbiCoder\")());\n        defineReadOnly(this, \"functions\", {});\n        defineReadOnly(this, \"errors\", {});\n        defineReadOnly(this, \"events\", {});\n        defineReadOnly(this, \"structs\", {});\n        // Add all fragments by their signature\n        this.fragments.forEach((fragment) => {\n            let bucket = null;\n            switch (fragment.type) {\n                case \"constructor\":\n                    if (this.deploy) {\n                        logger.warn(\"duplicate definition - constructor\");\n                        return;\n                    }\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    defineReadOnly(this, \"deploy\", fragment);\n                    return;\n                case \"function\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    //checkNames(fragment, \"output\", (<FunctionFragment>fragment).outputs);\n                    bucket = this.functions;\n                    break;\n                case \"event\":\n                    //checkNames(fragment, \"input\", fragment.inputs);\n                    bucket = this.events;\n                    break;\n                case \"error\":\n                    bucket = this.errors;\n                    break;\n                default:\n                    return;\n            }\n            let signature = fragment.format();\n            if (bucket[signature]) {\n                logger.warn(\"duplicate definition - \" + signature);\n                return;\n            }\n            bucket[signature] = fragment;\n        });\n        // If we do not have a constructor add a default\n        if (!this.deploy) {\n            defineReadOnly(this, \"deploy\", ConstructorFragment.from({\n                payable: false,\n                type: \"constructor\"\n            }));\n        }\n        defineReadOnly(this, \"_isInterface\", true);\n    }\n    format(format) {\n        if (!format) {\n            format = FormatTypes.full;\n        }\n        if (format === FormatTypes.sighash) {\n            logger.throwArgumentError(\"interface does not support formatting sighash\", \"format\", format);\n        }\n        const abi = this.fragments.map((fragment) => fragment.format(format));\n        // We need to re-bundle the JSON fragments a bit\n        if (format === FormatTypes.json) {\n            return JSON.stringify(abi.map((j) => JSON.parse(j)));\n        }\n        return abi;\n    }\n    // Sub-classes can override these to handle other blockchains\n    static getAbiCoder() {\n        return defaultAbiCoder;\n    }\n    static getAddress(address) {\n        return getAddress(address);\n    }\n    static getSighash(fragment) {\n        return hexDataSlice(id(fragment.format()), 0, 4);\n    }\n    static getEventTopic(eventFragment) {\n        return id(eventFragment.format());\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getFunction(nameOrSignatureOrSighash) {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            for (const name in this.functions) {\n                if (nameOrSignatureOrSighash === this.getSighash(name)) {\n                    return this.functions[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching function\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.functions).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching function\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching functions\", \"name\", name);\n            }\n            return this.functions[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.functions[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching function\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n    // Find an event definition by any means necessary (unless it is ambiguous)\n    getEvent(nameOrSignatureOrTopic) {\n        if (isHexString(nameOrSignatureOrTopic)) {\n            const topichash = nameOrSignatureOrTopic.toLowerCase();\n            for (const name in this.events) {\n                if (topichash === this.getEventTopic(name)) {\n                    return this.events[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching event\", \"topichash\", topichash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrTopic.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrTopic.trim();\n            const matching = Object.keys(this.events).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching event\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching events\", \"name\", name);\n            }\n            return this.events[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.events[EventFragment.fromString(nameOrSignatureOrTopic).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching event\", \"signature\", nameOrSignatureOrTopic);\n        }\n        return result;\n    }\n    // Find a function definition by any means necessary (unless it is ambiguous)\n    getError(nameOrSignatureOrSighash) {\n        if (isHexString(nameOrSignatureOrSighash)) {\n            const getSighash = getStatic(this.constructor, \"getSighash\");\n            for (const name in this.errors) {\n                const error = this.errors[name];\n                if (nameOrSignatureOrSighash === getSighash(error)) {\n                    return this.errors[name];\n                }\n            }\n            logger.throwArgumentError(\"no matching error\", \"sighash\", nameOrSignatureOrSighash);\n        }\n        // It is a bare name, look up the function (will return null if ambiguous)\n        if (nameOrSignatureOrSighash.indexOf(\"(\") === -1) {\n            const name = nameOrSignatureOrSighash.trim();\n            const matching = Object.keys(this.errors).filter((f) => (f.split(\"(\" /* fix:) */)[0] === name));\n            if (matching.length === 0) {\n                logger.throwArgumentError(\"no matching error\", \"name\", name);\n            }\n            else if (matching.length > 1) {\n                logger.throwArgumentError(\"multiple matching errors\", \"name\", name);\n            }\n            return this.errors[matching[0]];\n        }\n        // Normalize the signature and lookup the function\n        const result = this.errors[FunctionFragment.fromString(nameOrSignatureOrSighash).format()];\n        if (!result) {\n            logger.throwArgumentError(\"no matching error\", \"signature\", nameOrSignatureOrSighash);\n        }\n        return result;\n    }\n    // Get the sighash (the bytes4 selector) used by Solidity to identify a function\n    getSighash(fragment) {\n        if (typeof (fragment) === \"string\") {\n            try {\n                fragment = this.getFunction(fragment);\n            }\n            catch (error) {\n                try {\n                    fragment = this.getError(fragment);\n                }\n                catch (_) {\n                    throw error;\n                }\n            }\n        }\n        return getStatic(this.constructor, \"getSighash\")(fragment);\n    }\n    // Get the topic (the bytes32 hash) used by Solidity to identify an event\n    getEventTopic(eventFragment) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        return getStatic(this.constructor, \"getEventTopic\")(eventFragment);\n    }\n    _decodeParams(params, data) {\n        return this._abiCoder.decode(params, data);\n    }\n    _encodeParams(params, values) {\n        return this._abiCoder.encode(params, values);\n    }\n    encodeDeploy(values) {\n        return this._encodeParams(this.deploy.inputs, values || []);\n    }\n    decodeErrorResult(fragment, data) {\n        if (typeof (fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n        const bytes = arrayify(data);\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(fragment)) {\n            logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, \"data\", hexlify(bytes));\n        }\n        return this._decodeParams(fragment.inputs, bytes.slice(4));\n    }\n    encodeErrorResult(fragment, values) {\n        if (typeof (fragment) === \"string\") {\n            fragment = this.getError(fragment);\n        }\n        return hexlify(concat([\n            this.getSighash(fragment),\n            this._encodeParams(fragment.inputs, values || [])\n        ]));\n    }\n    // Decode the data for a function call (e.g. tx.data)\n    decodeFunctionData(functionFragment, data) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        const bytes = arrayify(data);\n        if (hexlify(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {\n            logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, \"data\", hexlify(bytes));\n        }\n        return this._decodeParams(functionFragment.inputs, bytes.slice(4));\n    }\n    // Encode the data for a function call (e.g. tx.data)\n    encodeFunctionData(functionFragment, values) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return hexlify(concat([\n            this.getSighash(functionFragment),\n            this._encodeParams(functionFragment.inputs, values || [])\n        ]));\n    }\n    // Decode the result from a function call (e.g. from eth_call)\n    decodeFunctionResult(functionFragment, data) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        let bytes = arrayify(data);\n        let reason = null;\n        let message = \"\";\n        let errorArgs = null;\n        let errorName = null;\n        let errorSignature = null;\n        switch (bytes.length % this._abiCoder._getWordSize()) {\n            case 0:\n                try {\n                    return this._abiCoder.decode(functionFragment.outputs, bytes);\n                }\n                catch (error) { }\n                break;\n            case 4: {\n                const selector = hexlify(bytes.slice(0, 4));\n                const builtin = BuiltinErrors[selector];\n                if (builtin) {\n                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));\n                    errorName = builtin.name;\n                    errorSignature = builtin.signature;\n                    if (builtin.reason) {\n                        reason = errorArgs[0];\n                    }\n                    if (errorName === \"Error\") {\n                        message = `; VM Exception while processing transaction: reverted with reason string ${JSON.stringify(errorArgs[0])}`;\n                    }\n                    else if (errorName === \"Panic\") {\n                        message = `; VM Exception while processing transaction: reverted with panic code ${errorArgs[0]}`;\n                    }\n                }\n                else {\n                    try {\n                        const error = this.getError(selector);\n                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));\n                        errorName = error.name;\n                        errorSignature = error.format();\n                    }\n                    catch (error) { }\n                }\n                break;\n            }\n        }\n        return logger.throwError(\"call revert exception\" + message, Logger.errors.CALL_EXCEPTION, {\n            method: functionFragment.format(),\n            data: hexlify(data), errorArgs, errorName, errorSignature, reason\n        });\n    }\n    // Encode the result for a function call (e.g. for eth_call)\n    encodeFunctionResult(functionFragment, values) {\n        if (typeof (functionFragment) === \"string\") {\n            functionFragment = this.getFunction(functionFragment);\n        }\n        return hexlify(this._abiCoder.encode(functionFragment.outputs, values || []));\n    }\n    // Create the filter for the event with search criteria (e.g. for eth_filterLog)\n    encodeFilterTopics(eventFragment, values) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (values.length > eventFragment.inputs.length) {\n            logger.throwError(\"too many arguments for \" + eventFragment.format(), Logger.errors.UNEXPECTED_ARGUMENT, {\n                argument: \"values\",\n                value: values\n            });\n        }\n        let topics = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        const encodeTopic = (param, value) => {\n            if (param.type === \"string\") {\n                return id(value);\n            }\n            else if (param.type === \"bytes\") {\n                return keccak256(hexlify(value));\n            }\n            if (param.type === \"bool\" && typeof (value) === \"boolean\") {\n                value = (value ? \"0x01\" : \"0x00\");\n            }\n            if (param.type.match(/^u?int/)) {\n                value = BigNumber.from(value).toHexString();\n            }\n            // Check addresses are valid\n            if (param.type === \"address\") {\n                this._abiCoder.encode([\"address\"], [value]);\n            }\n            return hexZeroPad(hexlify(value), 32);\n        };\n        values.forEach((value, index) => {\n            let param = eventFragment.inputs[index];\n            if (!param.indexed) {\n                if (value != null) {\n                    logger.throwArgumentError(\"cannot filter non-indexed parameters; must be null\", (\"contract.\" + param.name), value);\n                }\n                return;\n            }\n            if (value == null) {\n                topics.push(null);\n            }\n            else if (param.baseType === \"array\" || param.baseType === \"tuple\") {\n                logger.throwArgumentError(\"filtering with tuples or arrays not supported\", (\"contract.\" + param.name), value);\n            }\n            else if (Array.isArray(value)) {\n                topics.push(value.map((value) => encodeTopic(param, value)));\n            }\n            else {\n                topics.push(encodeTopic(param, value));\n            }\n        });\n        // Trim off trailing nulls\n        while (topics.length && topics[topics.length - 1] === null) {\n            topics.pop();\n        }\n        return topics;\n    }\n    encodeEventLog(eventFragment, values) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        const topics = [];\n        const dataTypes = [];\n        const dataValues = [];\n        if (!eventFragment.anonymous) {\n            topics.push(this.getEventTopic(eventFragment));\n        }\n        if (values.length !== eventFragment.inputs.length) {\n            logger.throwArgumentError(\"event arguments/values mismatch\", \"values\", values);\n        }\n        eventFragment.inputs.forEach((param, index) => {\n            const value = values[index];\n            if (param.indexed) {\n                if (param.type === \"string\") {\n                    topics.push(id(value));\n                }\n                else if (param.type === \"bytes\") {\n                    topics.push(keccak256(value));\n                }\n                else if (param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    // @TODO\n                    throw new Error(\"not implemented\");\n                }\n                else {\n                    topics.push(this._abiCoder.encode([param.type], [value]));\n                }\n            }\n            else {\n                dataTypes.push(param);\n                dataValues.push(value);\n            }\n        });\n        return {\n            data: this._abiCoder.encode(dataTypes, dataValues),\n            topics: topics\n        };\n    }\n    // Decode a filter for the event and the search criteria\n    decodeEventLog(eventFragment, data, topics) {\n        if (typeof (eventFragment) === \"string\") {\n            eventFragment = this.getEvent(eventFragment);\n        }\n        if (topics != null && !eventFragment.anonymous) {\n            let topicHash = this.getEventTopic(eventFragment);\n            if (!isHexString(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {\n                logger.throwError(\"fragment/topic mismatch\", Logger.errors.INVALID_ARGUMENT, { argument: \"topics[0]\", expected: topicHash, value: topics[0] });\n            }\n            topics = topics.slice(1);\n        }\n        let indexed = [];\n        let nonIndexed = [];\n        let dynamic = [];\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (param.type === \"string\" || param.type === \"bytes\" || param.baseType === \"tuple\" || param.baseType === \"array\") {\n                    indexed.push(ParamType.fromObject({ type: \"bytes32\", name: param.name }));\n                    dynamic.push(true);\n                }\n                else {\n                    indexed.push(param);\n                    dynamic.push(false);\n                }\n            }\n            else {\n                nonIndexed.push(param);\n                dynamic.push(false);\n            }\n        });\n        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, concat(topics)) : null;\n        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);\n        let result = [];\n        let nonIndexedIndex = 0, indexedIndex = 0;\n        eventFragment.inputs.forEach((param, index) => {\n            if (param.indexed) {\n                if (resultIndexed == null) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: null });\n                }\n                else if (dynamic[index]) {\n                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });\n                }\n                else {\n                    try {\n                        result[index] = resultIndexed[indexedIndex++];\n                    }\n                    catch (error) {\n                        result[index] = error;\n                    }\n                }\n            }\n            else {\n                try {\n                    result[index] = resultNonIndexed[nonIndexedIndex++];\n                }\n                catch (error) {\n                    result[index] = error;\n                }\n            }\n            // Add the keyword argument if named and safe\n            if (param.name && result[param.name] == null) {\n                const value = result[index];\n                // Make error named values throw on access\n                if (value instanceof Error) {\n                    Object.defineProperty(result, param.name, {\n                        enumerable: true,\n                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }\n                    });\n                }\n                else {\n                    result[param.name] = value;\n                }\n            }\n        });\n        // Make all error indexed values throw on access\n        for (let i = 0; i < result.length; i++) {\n            const value = result[i];\n            if (value instanceof Error) {\n                Object.defineProperty(result, i, {\n                    enumerable: true,\n                    get: () => { throw wrapAccessError(`index ${i}`, value); }\n                });\n            }\n        }\n        return Object.freeze(result);\n    }\n    // Given a transaction, find the matching function fragment (if any) and\n    // determine all its properties and call parameters\n    parseTransaction(tx) {\n        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new TransactionDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + tx.data.substring(10)),\n            functionFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n            value: BigNumber.from(tx.value || \"0\"),\n        });\n    }\n    // @TODO\n    //parseCallResult(data: BytesLike): ??\n    // Given an event log, find the matching event fragment (if any) and\n    // determine all its properties and values\n    parseLog(log) {\n        let fragment = this.getEvent(log.topics[0]);\n        if (!fragment || fragment.anonymous) {\n            return null;\n        }\n        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?\n        //        Probably not, because just because it is the only event in the ABI does\n        //        not mean we have the full ABI; maybe just a fragment?\n        return new LogDescription({\n            eventFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            topic: this.getEventTopic(fragment),\n            args: this.decodeEventLog(fragment, log.data, log.topics)\n        });\n    }\n    parseError(data) {\n        const hexData = hexlify(data);\n        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());\n        if (!fragment) {\n            return null;\n        }\n        return new ErrorDescription({\n            args: this._abiCoder.decode(fragment.inputs, \"0x\" + hexData.substring(10)),\n            errorFragment: fragment,\n            name: fragment.name,\n            signature: fragment.format(),\n            sighash: this.getSighash(fragment),\n        });\n    }\n    /*\n    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {\n        if (Interface.isInterface(value)) {\n            return value;\n        }\n        if (typeof(value) === \"string\") {\n            return new Interface(JSON.parse(value));\n        }\n        return new Interface(value);\n    }\n    */\n    static isInterface(value) {\n        return !!(value && value._isInterface);\n    }\n}\n//# sourceMappingURL=interface.js.map","export const version = \"abstract-provider/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { isHexString } from \"@ethersproject/bytes\";\nimport { Description, defineReadOnly, resolveProperties } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\n;\n//export type CallTransactionable = {\n//    call(transaction: TransactionRequest): Promise<TransactionResponse>;\n//};\nexport class ForkEvent extends Description {\n    static isForkEvent(value) {\n        return !!(value && value._isForkEvent);\n    }\n}\nexport class BlockForkEvent extends ForkEvent {\n    constructor(blockHash, expiry) {\n        if (!isHexString(blockHash, 32)) {\n            logger.throwArgumentError(\"invalid blockHash\", \"blockHash\", blockHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isBlockForkEvent: true,\n            expiry: (expiry || 0),\n            blockHash: blockHash\n        });\n    }\n}\nexport class TransactionForkEvent extends ForkEvent {\n    constructor(hash, expiry) {\n        if (!isHexString(hash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"hash\", hash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionForkEvent: true,\n            expiry: (expiry || 0),\n            hash: hash\n        });\n    }\n}\nexport class TransactionOrderForkEvent extends ForkEvent {\n    constructor(beforeHash, afterHash, expiry) {\n        if (!isHexString(beforeHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"beforeHash\", beforeHash);\n        }\n        if (!isHexString(afterHash, 32)) {\n            logger.throwArgumentError(\"invalid transaction hash\", \"afterHash\", afterHash);\n        }\n        super({\n            _isForkEvent: true,\n            _isTransactionOrderForkEvent: true,\n            expiry: (expiry || 0),\n            beforeHash: beforeHash,\n            afterHash: afterHash\n        });\n    }\n}\n///////////////////////////////\n// Exported Abstracts\nexport class Provider {\n    constructor() {\n        logger.checkAbstract(new.target, Provider);\n        defineReadOnly(this, \"_isProvider\", true);\n    }\n    getFeeData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const { block, gasPrice } = yield resolveProperties({\n                block: this.getBlock(\"latest\"),\n                gasPrice: this.getGasPrice().catch((error) => {\n                    // @TODO: Why is this now failing on Calaveras?\n                    //console.log(error);\n                    return null;\n                })\n            });\n            let lastBaseFeePerGas = null, maxFeePerGas = null, maxPriorityFeePerGas = null;\n            if (block && block.baseFeePerGas) {\n                // We may want to compute this more accurately in the future,\n                // using the formula \"check if the base fee is correct\".\n                // See: https://eips.ethereum.org/EIPS/eip-1559\n                lastBaseFeePerGas = block.baseFeePerGas;\n                maxPriorityFeePerGas = BigNumber.from(\"1500000000\");\n                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);\n            }\n            return { lastBaseFeePerGas, maxFeePerGas, maxPriorityFeePerGas, gasPrice };\n        });\n    }\n    // Alias for \"on\"\n    addListener(eventName, listener) {\n        return this.on(eventName, listener);\n    }\n    // Alias for \"off\"\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n    static isProvider(value) {\n        return !!(value && value._isProvider);\n    }\n}\n//# sourceMappingURL=index.js.map","export const version = \"abstract-signer/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { defineReadOnly, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nconst allowedTransactionKeys = [\n    \"accessList\", \"ccipReadEnabled\", \"chainId\", \"customData\", \"data\", \"from\", \"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"to\", \"type\", \"value\"\n];\nconst forwardErrors = [\n    Logger.errors.INSUFFICIENT_FUNDS,\n    Logger.errors.NONCE_EXPIRED,\n    Logger.errors.REPLACEMENT_UNDERPRICED,\n];\n;\n;\nexport class Signer {\n    ///////////////////\n    // Sub-classes MUST call super\n    constructor() {\n        logger.checkAbstract(new.target, Signer);\n        defineReadOnly(this, \"_isSigner\", true);\n    }\n    ///////////////////\n    // Sub-classes MAY override these\n    getBalance(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getBalance\");\n            return yield this.provider.getBalance(this.getAddress(), blockTag);\n        });\n    }\n    getTransactionCount(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getTransactionCount\");\n            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);\n        });\n    }\n    // Populates \"from\" if unspecified, and estimates the gas for the transaction\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"estimateGas\");\n            const tx = yield resolveProperties(this.checkTransaction(transaction));\n            return yield this.provider.estimateGas(tx);\n        });\n    }\n    // Populates \"from\" if unspecified, and calls with the transaction\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"call\");\n            const tx = yield resolveProperties(this.checkTransaction(transaction));\n            return yield this.provider.call(tx, blockTag);\n        });\n    }\n    // Populates all fields in a transaction, signs it and sends it to the network\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"sendTransaction\");\n            const tx = yield this.populateTransaction(transaction);\n            const signedTx = yield this.signTransaction(tx);\n            return yield this.provider.sendTransaction(signedTx);\n        });\n    }\n    getChainId() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getChainId\");\n            const network = yield this.provider.getNetwork();\n            return network.chainId;\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getGasPrice\");\n            return yield this.provider.getGasPrice();\n        });\n    }\n    getFeeData() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"getFeeData\");\n            return yield this.provider.getFeeData();\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            this._checkProvider(\"resolveName\");\n            return yield this.provider.resolveName(name);\n        });\n    }\n    // Checks a transaction does not contain invalid keys and if\n    // no \"from\" is provided, populates it.\n    // - does NOT require a provider\n    // - adds \"from\" is not present\n    // - returns a COPY (safe to mutate the result)\n    // By default called from: (overriding these prevents it)\n    //   - call\n    //   - estimateGas\n    //   - populateTransaction (and therefor sendTransaction)\n    checkTransaction(transaction) {\n        for (const key in transaction) {\n            if (allowedTransactionKeys.indexOf(key) === -1) {\n                logger.throwArgumentError(\"invalid transaction key: \" + key, \"transaction\", transaction);\n            }\n        }\n        const tx = shallowCopy(transaction);\n        if (tx.from == null) {\n            tx.from = this.getAddress();\n        }\n        else {\n            // Make sure any provided address matches this signer\n            tx.from = Promise.all([\n                Promise.resolve(tx.from),\n                this.getAddress()\n            ]).then((result) => {\n                if (result[0].toLowerCase() !== result[1].toLowerCase()) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n                return result[0];\n            });\n        }\n        return tx;\n    }\n    // Populates ALL keys for a transaction and checks that \"from\" matches\n    // this Signer. Should be used by sendTransaction but NOT by signTransaction.\n    // By default called from: (overriding these prevents it)\n    //   - sendTransaction\n    //\n    // Notes:\n    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas\n    populateTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const tx = yield resolveProperties(this.checkTransaction(transaction));\n            if (tx.to != null) {\n                tx.to = Promise.resolve(tx.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                    if (to == null) {\n                        return null;\n                    }\n                    const address = yield this.resolveName(to);\n                    if (address == null) {\n                        logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                    }\n                    return address;\n                }));\n                // Prevent this error from causing an UnhandledPromiseException\n                tx.to.catch((error) => { });\n            }\n            // Do not allow mixing pre-eip-1559 and eip-1559 properties\n            const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);\n            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {\n                logger.throwArgumentError(\"eip-1559 transaction do not support gasPrice\", \"transaction\", transaction);\n            }\n            else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {\n                logger.throwArgumentError(\"pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas\", \"transaction\", transaction);\n            }\n            if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {\n                // Fully-formed EIP-1559 transaction (skip getFeeData)\n                tx.type = 2;\n            }\n            else if (tx.type === 0 || tx.type === 1) {\n                // Explicit Legacy or EIP-2930 transaction\n                // Populate missing gasPrice\n                if (tx.gasPrice == null) {\n                    tx.gasPrice = this.getGasPrice();\n                }\n            }\n            else {\n                // We need to get fee data to determine things\n                const feeData = yield this.getFeeData();\n                if (tx.type == null) {\n                    // We need to auto-detect the intended type of this transaction...\n                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {\n                        // The network supports EIP-1559!\n                        // Upgrade transaction from null to eip-1559\n                        tx.type = 2;\n                        if (tx.gasPrice != null) {\n                            // Using legacy gasPrice property on an eip-1559 network,\n                            // so use gasPrice as both fee properties\n                            const gasPrice = tx.gasPrice;\n                            delete tx.gasPrice;\n                            tx.maxFeePerGas = gasPrice;\n                            tx.maxPriorityFeePerGas = gasPrice;\n                        }\n                        else {\n                            // Populate missing fee data\n                            if (tx.maxFeePerGas == null) {\n                                tx.maxFeePerGas = feeData.maxFeePerGas;\n                            }\n                            if (tx.maxPriorityFeePerGas == null) {\n                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                            }\n                        }\n                    }\n                    else if (feeData.gasPrice != null) {\n                        // Network doesn't support EIP-1559...\n                        // ...but they are trying to use EIP-1559 properties\n                        if (hasEip1559) {\n                            logger.throwError(\"network does not support EIP-1559\", Logger.errors.UNSUPPORTED_OPERATION, {\n                                operation: \"populateTransaction\"\n                            });\n                        }\n                        // Populate missing fee data\n                        if (tx.gasPrice == null) {\n                            tx.gasPrice = feeData.gasPrice;\n                        }\n                        // Explicitly set untyped transaction to legacy\n                        tx.type = 0;\n                    }\n                    else {\n                        // getFeeData has failed us.\n                        logger.throwError(\"failed to get consistent fee data\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"signer.getFeeData\"\n                        });\n                    }\n                }\n                else if (tx.type === 2) {\n                    // Explicitly using EIP-1559\n                    // Populate missing fee data\n                    if (tx.maxFeePerGas == null) {\n                        tx.maxFeePerGas = feeData.maxFeePerGas;\n                    }\n                    if (tx.maxPriorityFeePerGas == null) {\n                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;\n                    }\n                }\n            }\n            if (tx.nonce == null) {\n                tx.nonce = this.getTransactionCount(\"pending\");\n            }\n            if (tx.gasLimit == null) {\n                tx.gasLimit = this.estimateGas(tx).catch((error) => {\n                    if (forwardErrors.indexOf(error.code) >= 0) {\n                        throw error;\n                    }\n                    return logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                        error: error,\n                        tx: tx\n                    });\n                });\n            }\n            if (tx.chainId == null) {\n                tx.chainId = this.getChainId();\n            }\n            else {\n                tx.chainId = Promise.all([\n                    Promise.resolve(tx.chainId),\n                    this.getChainId()\n                ]).then((results) => {\n                    if (results[1] !== 0 && results[0] !== results[1]) {\n                        logger.throwArgumentError(\"chainId address mismatch\", \"transaction\", transaction);\n                    }\n                    return results[0];\n                });\n            }\n            return yield resolveProperties(tx);\n        });\n    }\n    ///////////////////\n    // Sub-classes SHOULD leave these alone\n    _checkProvider(operation) {\n        if (!this.provider) {\n            logger.throwError(\"missing provider\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: (operation || \"_checkProvider\")\n            });\n        }\n    }\n    static isSigner(value) {\n        return !!(value && value._isSigner);\n    }\n}\nexport class VoidSigner extends Signer {\n    constructor(address, provider) {\n        super();\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"provider\", provider || null);\n    }\n    getAddress() {\n        return Promise.resolve(this.address);\n    }\n    _fail(message, operation) {\n        return Promise.resolve().then(() => {\n            logger.throwError(message, Logger.errors.UNSUPPORTED_OPERATION, { operation: operation });\n        });\n    }\n    signMessage(message) {\n        return this._fail(\"VoidSigner cannot sign messages\", \"signMessage\");\n    }\n    signTransaction(transaction) {\n        return this._fail(\"VoidSigner cannot sign transactions\", \"signTransaction\");\n    }\n    _signTypedData(domain, types, value) {\n        return this._fail(\"VoidSigner cannot sign typed data\", \"signTypedData\");\n    }\n    connect(provider) {\n        return new VoidSigner(this.address, provider);\n    }\n}\n//# sourceMappingURL=index.js.map","export const version = \"contracts/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { checkResultErrors, Indexed, Interface } from \"@ethersproject/abi\";\nimport { Provider } from \"@ethersproject/abstract-provider\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexlify, isBytes, isHexString } from \"@ethersproject/bytes\";\nimport { defineReadOnly, deepCopy, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\n;\n///////////////////////////////\nconst allowedTransactionKeys = {\n    chainId: true, data: true, from: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true,\n    customData: true,\n    ccipReadEnabled: true\n};\nfunction resolveName(resolver, nameOrPromise) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const name = yield nameOrPromise;\n        if (typeof (name) !== \"string\") {\n            logger.throwArgumentError(\"invalid address or ENS name\", \"name\", name);\n        }\n        // If it is already an address, just use it (after adding checksum)\n        try {\n            return getAddress(name);\n        }\n        catch (error) { }\n        if (!resolver) {\n            logger.throwError(\"a provider or signer is needed to resolve ENS names\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"resolveName\"\n            });\n        }\n        const address = yield resolver.resolveName(name);\n        if (address == null) {\n            logger.throwArgumentError(\"resolver or addr is not configured for ENS name\", \"name\", name);\n        }\n        return address;\n    });\n}\n// Recursively replaces ENS names with promises to resolve the name and resolves all properties\nfunction resolveAddresses(resolver, value, paramType) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (Array.isArray(paramType)) {\n            return yield Promise.all(paramType.map((paramType, index) => {\n                return resolveAddresses(resolver, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);\n            }));\n        }\n        if (paramType.type === \"address\") {\n            return yield resolveName(resolver, value);\n        }\n        if (paramType.type === \"tuple\") {\n            return yield resolveAddresses(resolver, value, paramType.components);\n        }\n        if (paramType.baseType === \"array\") {\n            if (!Array.isArray(value)) {\n                return Promise.reject(logger.makeError(\"invalid value for array\", Logger.errors.INVALID_ARGUMENT, {\n                    argument: \"value\",\n                    value\n                }));\n            }\n            return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));\n        }\n        return value;\n    });\n}\nfunction populateTransaction(contract, fragment, args) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // If an extra argument is given, it is overrides\n        let overrides = {};\n        if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n            overrides = shallowCopy(args.pop());\n        }\n        // Make sure the parameter count matches\n        logger.checkArgumentCount(args.length, fragment.inputs.length, \"passed to contract\");\n        // Populate \"from\" override (allow promises)\n        if (contract.signer) {\n            if (overrides.from) {\n                // Contracts with a Signer are from the Signer's frame-of-reference;\n                // but we allow overriding \"from\" if it matches the signer\n                overrides.from = resolveProperties({\n                    override: resolveName(contract.signer, overrides.from),\n                    signer: contract.signer.getAddress()\n                }).then((check) => __awaiter(this, void 0, void 0, function* () {\n                    if (getAddress(check.signer) !== check.override) {\n                        logger.throwError(\"Contract with a Signer cannot override from\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            operation: \"overrides.from\"\n                        });\n                    }\n                    return check.override;\n                }));\n            }\n            else {\n                overrides.from = contract.signer.getAddress();\n            }\n        }\n        else if (overrides.from) {\n            overrides.from = resolveName(contract.provider, overrides.from);\n            //} else {\n            // Contracts without a signer can override \"from\", and if\n            // unspecified the zero address is used\n            //overrides.from = AddressZero;\n        }\n        // Wait for all dependencies to be resolved (prefer the signer over the provider)\n        const resolved = yield resolveProperties({\n            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),\n            address: contract.resolvedAddress,\n            overrides: (resolveProperties(overrides) || {})\n        });\n        // The ABI coded transaction\n        const data = contract.interface.encodeFunctionData(fragment, resolved.args);\n        const tx = {\n            data: data,\n            to: resolved.address\n        };\n        // Resolved Overrides\n        const ro = resolved.overrides;\n        // Populate simple overrides\n        if (ro.nonce != null) {\n            tx.nonce = BigNumber.from(ro.nonce).toNumber();\n        }\n        if (ro.gasLimit != null) {\n            tx.gasLimit = BigNumber.from(ro.gasLimit);\n        }\n        if (ro.gasPrice != null) {\n            tx.gasPrice = BigNumber.from(ro.gasPrice);\n        }\n        if (ro.maxFeePerGas != null) {\n            tx.maxFeePerGas = BigNumber.from(ro.maxFeePerGas);\n        }\n        if (ro.maxPriorityFeePerGas != null) {\n            tx.maxPriorityFeePerGas = BigNumber.from(ro.maxPriorityFeePerGas);\n        }\n        if (ro.from != null) {\n            tx.from = ro.from;\n        }\n        if (ro.type != null) {\n            tx.type = ro.type;\n        }\n        if (ro.accessList != null) {\n            tx.accessList = accessListify(ro.accessList);\n        }\n        // If there was no \"gasLimit\" override, but the ABI specifies a default, use it\n        if (tx.gasLimit == null && fragment.gas != null) {\n            // Compute the intrinsic gas cost for this transaction\n            // @TODO: This is based on the yellow paper as of Petersburg; this is something\n            // we may wish to parameterize in v6 as part of the Network object. Since this\n            // is always a non-nil to address, we can ignore G_create, but may wish to add\n            // similar logic to the ContractFactory.\n            let intrinsic = 21000;\n            const bytes = arrayify(data);\n            for (let i = 0; i < bytes.length; i++) {\n                intrinsic += 4;\n                if (bytes[i]) {\n                    intrinsic += 64;\n                }\n            }\n            tx.gasLimit = BigNumber.from(fragment.gas).add(intrinsic);\n        }\n        // Populate \"value\" override\n        if (ro.value) {\n            const roValue = BigNumber.from(ro.value);\n            if (!roValue.isZero() && !fragment.payable) {\n                logger.throwError(\"non-payable method cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: overrides.value\n                });\n            }\n            tx.value = roValue;\n        }\n        if (ro.customData) {\n            tx.customData = shallowCopy(ro.customData);\n        }\n        if (ro.ccipReadEnabled) {\n            tx.ccipReadEnabled = !!ro.ccipReadEnabled;\n        }\n        // Remove the overrides\n        delete overrides.nonce;\n        delete overrides.gasLimit;\n        delete overrides.gasPrice;\n        delete overrides.from;\n        delete overrides.value;\n        delete overrides.type;\n        delete overrides.accessList;\n        delete overrides.maxFeePerGas;\n        delete overrides.maxPriorityFeePerGas;\n        delete overrides.customData;\n        delete overrides.ccipReadEnabled;\n        // Make sure there are no stray overrides, which may indicate a\n        // typo or using an unsupported key.\n        const leftovers = Object.keys(overrides).filter((key) => (overrides[key] != null));\n        if (leftovers.length) {\n            logger.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(\",\")}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"overrides\",\n                overrides: leftovers\n            });\n        }\n        return tx;\n    });\n}\nfunction buildPopulate(contract, fragment) {\n    return function (...args) {\n        return populateTransaction(contract, fragment, args);\n    };\n}\nfunction buildEstimate(contract, fragment) {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return function (...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!signerOrProvider) {\n                logger.throwError(\"estimate require a provider or signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"estimateGas\"\n                });\n            }\n            const tx = yield populateTransaction(contract, fragment, args);\n            return yield signerOrProvider.estimateGas(tx);\n        });\n    };\n}\nfunction addContractWait(contract, tx) {\n    const wait = tx.wait.bind(tx);\n    tx.wait = (confirmations) => {\n        return wait(confirmations).then((receipt) => {\n            receipt.events = receipt.logs.map((log) => {\n                let event = deepCopy(log);\n                let parsed = null;\n                try {\n                    parsed = contract.interface.parseLog(log);\n                }\n                catch (e) { }\n                // Successfully parsed the event log; include it\n                if (parsed) {\n                    event.args = parsed.args;\n                    event.decode = (data, topics) => {\n                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);\n                    };\n                    event.event = parsed.name;\n                    event.eventSignature = parsed.signature;\n                }\n                // Useful operations\n                event.removeListener = () => { return contract.provider; };\n                event.getBlock = () => {\n                    return contract.provider.getBlock(receipt.blockHash);\n                };\n                event.getTransaction = () => {\n                    return contract.provider.getTransaction(receipt.transactionHash);\n                };\n                event.getTransactionReceipt = () => {\n                    return Promise.resolve(receipt);\n                };\n                return event;\n            });\n            return receipt;\n        });\n    };\n}\nfunction buildCall(contract, fragment, collapseSimple) {\n    const signerOrProvider = (contract.signer || contract.provider);\n    return function (...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Extract the \"blockTag\" override if present\n            let blockTag = undefined;\n            if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n                const overrides = shallowCopy(args.pop());\n                if (overrides.blockTag != null) {\n                    blockTag = yield overrides.blockTag;\n                }\n                delete overrides.blockTag;\n                args.push(overrides);\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed(blockTag);\n            }\n            // Call a node and get the result\n            const tx = yield populateTransaction(contract, fragment, args);\n            const result = yield signerOrProvider.call(tx, blockTag);\n            try {\n                let value = contract.interface.decodeFunctionResult(fragment, result);\n                if (collapseSimple && fragment.outputs.length === 1) {\n                    value = value[0];\n                }\n                return value;\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    error.address = contract.address;\n                    error.args = args;\n                    error.transaction = tx;\n                }\n                throw error;\n            }\n        });\n    };\n}\nfunction buildSend(contract, fragment) {\n    return function (...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (!contract.signer) {\n                logger.throwError(\"sending a transaction requires a signer\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"sendTransaction\"\n                });\n            }\n            // If the contract was just deployed, wait until it is mined\n            if (contract.deployTransaction != null) {\n                yield contract._deployed();\n            }\n            const txRequest = yield populateTransaction(contract, fragment, args);\n            const tx = yield contract.signer.sendTransaction(txRequest);\n            // Tweak the tx.wait so the receipt has extra properties\n            addContractWait(contract, tx);\n            return tx;\n        });\n    };\n}\nfunction buildDefault(contract, fragment, collapseSimple) {\n    if (fragment.constant) {\n        return buildCall(contract, fragment, collapseSimple);\n    }\n    return buildSend(contract, fragment);\n}\nfunction getEventTag(filter) {\n    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {\n        return \"*\";\n    }\n    return (filter.address || \"*\") + \"@\" + (filter.topics ? filter.topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            return topic.join(\"|\");\n        }\n        return topic;\n    }).join(\":\") : \"\");\n}\nclass RunningEvent {\n    constructor(tag, filter) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"filter\", filter);\n        this._listeners = [];\n    }\n    addListener(listener, once) {\n        this._listeners.push({ listener: listener, once: once });\n    }\n    removeListener(listener) {\n        let done = false;\n        this._listeners = this._listeners.filter((item) => {\n            if (done || item.listener !== listener) {\n                return true;\n            }\n            done = true;\n            return false;\n        });\n    }\n    removeAllListeners() {\n        this._listeners = [];\n    }\n    listeners() {\n        return this._listeners.map((i) => i.listener);\n    }\n    listenerCount() {\n        return this._listeners.length;\n    }\n    run(args) {\n        const listenerCount = this.listenerCount();\n        this._listeners = this._listeners.filter((item) => {\n            const argsCopy = args.slice();\n            // Call the callback in the next event loop\n            setTimeout(() => {\n                item.listener.apply(this, argsCopy);\n            }, 0);\n            // Reschedule it if it not \"once\"\n            return !(item.once);\n        });\n        return listenerCount;\n    }\n    prepareEvent(event) {\n    }\n    // Returns the array that will be applied to an emit\n    getEmit(event) {\n        return [event];\n    }\n}\nclass ErrorRunningEvent extends RunningEvent {\n    constructor() {\n        super(\"error\", null);\n    }\n}\n// @TODO Fragment should inherit Wildcard? and just override getEmit?\n//       or have a common abstract super class, with enough constructor\n//       options to configure both.\n// A Fragment Event will populate all the properties that Wildcard\n// will, and additionally dereference the arguments when emitting\nclass FragmentRunningEvent extends RunningEvent {\n    constructor(address, contractInterface, fragment, topics) {\n        const filter = {\n            address: address\n        };\n        let topic = contractInterface.getEventTopic(fragment);\n        if (topics) {\n            if (topic !== topics[0]) {\n                logger.throwArgumentError(\"topic mismatch\", \"topics\", topics);\n            }\n            filter.topics = topics.slice();\n        }\n        else {\n            filter.topics = [topic];\n        }\n        super(getEventTag(filter), filter);\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n        defineReadOnly(this, \"fragment\", fragment);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        event.event = this.fragment.name;\n        event.eventSignature = this.fragment.format();\n        event.decode = (data, topics) => {\n            return this.interface.decodeEventLog(this.fragment, data, topics);\n        };\n        try {\n            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);\n        }\n        catch (error) {\n            event.args = null;\n            event.decodeError = error;\n        }\n    }\n    getEmit(event) {\n        const errors = checkResultErrors(event.args);\n        if (errors.length) {\n            throw errors[0].error;\n        }\n        const args = (event.args || []).slice();\n        args.push(event);\n        return args;\n    }\n}\n// A Wildcard Event will attempt to populate:\n//  - event            The name of the event name\n//  - eventSignature   The full signature of the event\n//  - decode           A function to decode data and topics\n//  - args             The decoded data and topics\nclass WildcardRunningEvent extends RunningEvent {\n    constructor(address, contractInterface) {\n        super(\"*\", { address: address });\n        defineReadOnly(this, \"address\", address);\n        defineReadOnly(this, \"interface\", contractInterface);\n    }\n    prepareEvent(event) {\n        super.prepareEvent(event);\n        try {\n            const parsed = this.interface.parseLog(event);\n            event.event = parsed.name;\n            event.eventSignature = parsed.signature;\n            event.decode = (data, topics) => {\n                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);\n            };\n            event.args = parsed.args;\n        }\n        catch (error) {\n            // No matching event\n        }\n    }\n}\nexport class BaseContract {\n    constructor(addressOrName, contractInterface, signerOrProvider) {\n        // @TODO: Maybe still check the addressOrName looks like a valid address or name?\n        //address = getAddress(address);\n        defineReadOnly(this, \"interface\", getStatic(new.target, \"getInterface\")(contractInterface));\n        if (signerOrProvider == null) {\n            defineReadOnly(this, \"provider\", null);\n            defineReadOnly(this, \"signer\", null);\n        }\n        else if (Signer.isSigner(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider.provider || null);\n            defineReadOnly(this, \"signer\", signerOrProvider);\n        }\n        else if (Provider.isProvider(signerOrProvider)) {\n            defineReadOnly(this, \"provider\", signerOrProvider);\n            defineReadOnly(this, \"signer\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid signer or provider\", \"signerOrProvider\", signerOrProvider);\n        }\n        defineReadOnly(this, \"callStatic\", {});\n        defineReadOnly(this, \"estimateGas\", {});\n        defineReadOnly(this, \"functions\", {});\n        defineReadOnly(this, \"populateTransaction\", {});\n        defineReadOnly(this, \"filters\", {});\n        {\n            const uniqueFilters = {};\n            Object.keys(this.interface.events).forEach((eventSignature) => {\n                const event = this.interface.events[eventSignature];\n                defineReadOnly(this.filters, eventSignature, (...args) => {\n                    return {\n                        address: this.address,\n                        topics: this.interface.encodeFilterTopics(event, args)\n                    };\n                });\n                if (!uniqueFilters[event.name]) {\n                    uniqueFilters[event.name] = [];\n                }\n                uniqueFilters[event.name].push(eventSignature);\n            });\n            Object.keys(uniqueFilters).forEach((name) => {\n                const filters = uniqueFilters[name];\n                if (filters.length === 1) {\n                    defineReadOnly(this.filters, name, this.filters[filters[0]]);\n                }\n                else {\n                    logger.warn(`Duplicate definition of ${name} (${filters.join(\", \")})`);\n                }\n            });\n        }\n        defineReadOnly(this, \"_runningEvents\", {});\n        defineReadOnly(this, \"_wrappedEmits\", {});\n        if (addressOrName == null) {\n            logger.throwArgumentError(\"invalid contract address or ENS name\", \"addressOrName\", addressOrName);\n        }\n        defineReadOnly(this, \"address\", addressOrName);\n        if (this.provider) {\n            defineReadOnly(this, \"resolvedAddress\", resolveName(this.provider, addressOrName));\n        }\n        else {\n            try {\n                defineReadOnly(this, \"resolvedAddress\", Promise.resolve(getAddress(addressOrName)));\n            }\n            catch (error) {\n                // Without a provider, we cannot use ENS names\n                logger.throwError(\"provider is required to use ENS name as contract address\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"new Contract\"\n                });\n            }\n        }\n        // Swallow bad ENS names to prevent Unhandled Exceptions\n        this.resolvedAddress.catch((e) => { });\n        const uniqueNames = {};\n        const uniqueSignatures = {};\n        Object.keys(this.interface.functions).forEach((signature) => {\n            const fragment = this.interface.functions[signature];\n            // Check that the signature is unique; if not the ABI generation has\n            // not been cleaned or may be incorrectly generated\n            if (uniqueSignatures[signature]) {\n                logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);\n                return;\n            }\n            uniqueSignatures[signature] = true;\n            // Track unique names; we only expose bare named functions if they\n            // are ambiguous\n            {\n                const name = fragment.name;\n                if (!uniqueNames[`%${name}`]) {\n                    uniqueNames[`%${name}`] = [];\n                }\n                uniqueNames[`%${name}`].push(signature);\n            }\n            if (this[signature] == null) {\n                defineReadOnly(this, signature, buildDefault(this, fragment, true));\n            }\n            // We do not collapse simple calls on this bucket, which allows\n            // frameworks to safely use this without introspection as well as\n            // allows decoding error recovery.\n            if (this.functions[signature] == null) {\n                defineReadOnly(this.functions, signature, buildDefault(this, fragment, false));\n            }\n            if (this.callStatic[signature] == null) {\n                defineReadOnly(this.callStatic, signature, buildCall(this, fragment, true));\n            }\n            if (this.populateTransaction[signature] == null) {\n                defineReadOnly(this.populateTransaction, signature, buildPopulate(this, fragment));\n            }\n            if (this.estimateGas[signature] == null) {\n                defineReadOnly(this.estimateGas, signature, buildEstimate(this, fragment));\n            }\n        });\n        Object.keys(uniqueNames).forEach((name) => {\n            // Ambiguous names to not get attached as bare names\n            const signatures = uniqueNames[name];\n            if (signatures.length > 1) {\n                return;\n            }\n            // Strip off the leading \"%\" used for prototype protection\n            name = name.substring(1);\n            const signature = signatures[0];\n            // If overwriting a member property that is null, swallow the error\n            try {\n                if (this[name] == null) {\n                    defineReadOnly(this, name, this[signature]);\n                }\n            }\n            catch (e) { }\n            if (this.functions[name] == null) {\n                defineReadOnly(this.functions, name, this.functions[signature]);\n            }\n            if (this.callStatic[name] == null) {\n                defineReadOnly(this.callStatic, name, this.callStatic[signature]);\n            }\n            if (this.populateTransaction[name] == null) {\n                defineReadOnly(this.populateTransaction, name, this.populateTransaction[signature]);\n            }\n            if (this.estimateGas[name] == null) {\n                defineReadOnly(this.estimateGas, name, this.estimateGas[signature]);\n            }\n        });\n    }\n    static getContractAddress(transaction) {\n        return getContractAddress(transaction);\n    }\n    static getInterface(contractInterface) {\n        if (Interface.isInterface(contractInterface)) {\n            return contractInterface;\n        }\n        return new Interface(contractInterface);\n    }\n    // @TODO: Allow timeout?\n    deployed() {\n        return this._deployed();\n    }\n    _deployed(blockTag) {\n        if (!this._deployedPromise) {\n            // If we were just deployed, we know the transaction we should occur in\n            if (this.deployTransaction) {\n                this._deployedPromise = this.deployTransaction.wait().then(() => {\n                    return this;\n                });\n            }\n            else {\n                // @TODO: Once we allow a timeout to be passed in, we will wait\n                // up to that many blocks for getCode\n                // Otherwise, poll for our code to be deployed\n                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {\n                    if (code === \"0x\") {\n                        logger.throwError(\"contract not deployed\", Logger.errors.UNSUPPORTED_OPERATION, {\n                            contractAddress: this.address,\n                            operation: \"getDeployed\"\n                        });\n                    }\n                    return this;\n                });\n            }\n        }\n        return this._deployedPromise;\n    }\n    // @TODO:\n    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>\n    // @TODO:\n    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>\n    fallback(overrides) {\n        if (!this.signer) {\n            logger.throwError(\"sending a transactions require a signer\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"sendTransaction(fallback)\" });\n        }\n        const tx = shallowCopy(overrides || {});\n        [\"from\", \"to\"].forEach(function (key) {\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n        });\n        tx.to = this.resolvedAddress;\n        return this.deployed().then(() => {\n            return this.signer.sendTransaction(tx);\n        });\n    }\n    // Reconnect to a different signer or provider\n    connect(signerOrProvider) {\n        if (typeof (signerOrProvider) === \"string\") {\n            signerOrProvider = new VoidSigner(signerOrProvider, this.provider);\n        }\n        const contract = new (this.constructor)(this.address, this.interface, signerOrProvider);\n        if (this.deployTransaction) {\n            defineReadOnly(contract, \"deployTransaction\", this.deployTransaction);\n        }\n        return contract;\n    }\n    // Re-attach to a different on-chain instance of this contract\n    attach(addressOrName) {\n        return new (this.constructor)(addressOrName, this.interface, this.signer || this.provider);\n    }\n    static isIndexed(value) {\n        return Indexed.isIndexed(value);\n    }\n    _normalizeRunningEvent(runningEvent) {\n        // Already have an instance of this event running; we can re-use it\n        if (this._runningEvents[runningEvent.tag]) {\n            return this._runningEvents[runningEvent.tag];\n        }\n        return runningEvent;\n    }\n    _getRunningEvent(eventName) {\n        if (typeof (eventName) === \"string\") {\n            // Listen for \"error\" events (if your contract has an error event, include\n            // the full signature to bypass this special event keyword)\n            if (eventName === \"error\") {\n                return this._normalizeRunningEvent(new ErrorRunningEvent());\n            }\n            // Listen for any event that is registered\n            if (eventName === \"event\") {\n                return this._normalizeRunningEvent(new RunningEvent(\"event\", null));\n            }\n            // Listen for any event\n            if (eventName === \"*\") {\n                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n            }\n            // Get the event Fragment (throws if ambiguous/unknown event)\n            const fragment = this.interface.getEvent(eventName);\n            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));\n        }\n        // We have topics to filter by...\n        if (eventName.topics && eventName.topics.length > 0) {\n            // Is it a known topichash? (throws if no matching topichash)\n            try {\n                const topic = eventName.topics[0];\n                if (typeof (topic) !== \"string\") {\n                    throw new Error(\"invalid topic\"); // @TODO: May happen for anonymous events\n                }\n                const fragment = this.interface.getEvent(topic);\n                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));\n            }\n            catch (error) { }\n            // Filter by the unknown topichash\n            const filter = {\n                address: this.address,\n                topics: eventName.topics\n            };\n            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));\n        }\n        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));\n    }\n    _checkRunningEvents(runningEvent) {\n        if (runningEvent.listenerCount() === 0) {\n            delete this._runningEvents[runningEvent.tag];\n            // If we have a poller for this, remove it\n            const emit = this._wrappedEmits[runningEvent.tag];\n            if (emit && runningEvent.filter) {\n                this.provider.off(runningEvent.filter, emit);\n                delete this._wrappedEmits[runningEvent.tag];\n            }\n        }\n    }\n    // Subclasses can override this to gracefully recover\n    // from parse errors if they wish\n    _wrapEvent(runningEvent, log, listener) {\n        const event = deepCopy(log);\n        event.removeListener = () => {\n            if (!listener) {\n                return;\n            }\n            runningEvent.removeListener(listener);\n            this._checkRunningEvents(runningEvent);\n        };\n        event.getBlock = () => { return this.provider.getBlock(log.blockHash); };\n        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); };\n        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); };\n        // This may throw if the topics and data mismatch the signature\n        runningEvent.prepareEvent(event);\n        return event;\n    }\n    _addEventListener(runningEvent, listener, once) {\n        if (!this.provider) {\n            logger.throwError(\"events require a provider or a signer with a provider\", Logger.errors.UNSUPPORTED_OPERATION, { operation: \"once\" });\n        }\n        runningEvent.addListener(listener, once);\n        // Track this running event and its listeners (may already be there; but no hard in updating)\n        this._runningEvents[runningEvent.tag] = runningEvent;\n        // If we are not polling the provider, start polling\n        if (!this._wrappedEmits[runningEvent.tag]) {\n            const wrappedEmit = (log) => {\n                let event = this._wrapEvent(runningEvent, log, listener);\n                // Try to emit the result for the parameterized event...\n                if (event.decodeError == null) {\n                    try {\n                        const args = runningEvent.getEmit(event);\n                        this.emit(runningEvent.filter, ...args);\n                    }\n                    catch (error) {\n                        event.decodeError = error.error;\n                    }\n                }\n                // Always emit \"event\" for fragment-base events\n                if (runningEvent.filter != null) {\n                    this.emit(\"event\", event);\n                }\n                // Emit \"error\" if there was an error\n                if (event.decodeError != null) {\n                    this.emit(\"error\", event.decodeError, event);\n                }\n            };\n            this._wrappedEmits[runningEvent.tag] = wrappedEmit;\n            // Special events, like \"error\" do not have a filter\n            if (runningEvent.filter != null) {\n                this.provider.on(runningEvent.filter, wrappedEmit);\n            }\n        }\n    }\n    queryFilter(event, fromBlockOrBlockhash, toBlock) {\n        const runningEvent = this._getRunningEvent(event);\n        const filter = shallowCopy(runningEvent.filter);\n        if (typeof (fromBlockOrBlockhash) === \"string\" && isHexString(fromBlockOrBlockhash, 32)) {\n            if (toBlock != null) {\n                logger.throwArgumentError(\"cannot specify toBlock with blockhash\", \"toBlock\", toBlock);\n            }\n            filter.blockHash = fromBlockOrBlockhash;\n        }\n        else {\n            filter.fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash : 0);\n            filter.toBlock = ((toBlock != null) ? toBlock : \"latest\");\n        }\n        return this.provider.getLogs(filter).then((logs) => {\n            return logs.map((log) => this._wrapEvent(runningEvent, log, null));\n        });\n    }\n    on(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, false);\n        return this;\n    }\n    once(event, listener) {\n        this._addEventListener(this._getRunningEvent(event), listener, true);\n        return this;\n    }\n    emit(eventName, ...args) {\n        if (!this.provider) {\n            return false;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        const result = (runningEvent.run(args) > 0);\n        // May have drained all the \"once\" events; check for living events\n        this._checkRunningEvents(runningEvent);\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!this.provider) {\n            return 0;\n        }\n        if (eventName == null) {\n            return Object.keys(this._runningEvents).reduce((accum, key) => {\n                return accum + this._runningEvents[key].listenerCount();\n            }, 0);\n        }\n        return this._getRunningEvent(eventName).listenerCount();\n    }\n    listeners(eventName) {\n        if (!this.provider) {\n            return [];\n        }\n        if (eventName == null) {\n            const result = [];\n            for (let tag in this._runningEvents) {\n                this._runningEvents[tag].listeners().forEach((listener) => {\n                    result.push(listener);\n                });\n            }\n            return result;\n        }\n        return this._getRunningEvent(eventName).listeners();\n    }\n    removeAllListeners(eventName) {\n        if (!this.provider) {\n            return this;\n        }\n        if (eventName == null) {\n            for (const tag in this._runningEvents) {\n                const runningEvent = this._runningEvents[tag];\n                runningEvent.removeAllListeners();\n                this._checkRunningEvents(runningEvent);\n            }\n            return this;\n        }\n        // Delete any listeners\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeAllListeners();\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    off(eventName, listener) {\n        if (!this.provider) {\n            return this;\n        }\n        const runningEvent = this._getRunningEvent(eventName);\n        runningEvent.removeListener(listener);\n        this._checkRunningEvents(runningEvent);\n        return this;\n    }\n    removeListener(eventName, listener) {\n        return this.off(eventName, listener);\n    }\n}\nexport class Contract extends BaseContract {\n}\nexport class ContractFactory {\n    constructor(contractInterface, bytecode, signer) {\n        let bytecodeHex = null;\n        if (typeof (bytecode) === \"string\") {\n            bytecodeHex = bytecode;\n        }\n        else if (isBytes(bytecode)) {\n            bytecodeHex = hexlify(bytecode);\n        }\n        else if (bytecode && typeof (bytecode.object) === \"string\") {\n            // Allow the bytecode object from the Solidity compiler\n            bytecodeHex = bytecode.object;\n        }\n        else {\n            // Crash in the next verification step\n            bytecodeHex = \"!\";\n        }\n        // Make sure it is 0x prefixed\n        if (bytecodeHex.substring(0, 2) !== \"0x\") {\n            bytecodeHex = \"0x\" + bytecodeHex;\n        }\n        // Make sure the final result is valid bytecode\n        if (!isHexString(bytecodeHex) || (bytecodeHex.length % 2)) {\n            logger.throwArgumentError(\"invalid bytecode\", \"bytecode\", bytecode);\n        }\n        // If we have a signer, make sure it is valid\n        if (signer && !Signer.isSigner(signer)) {\n            logger.throwArgumentError(\"invalid signer\", \"signer\", signer);\n        }\n        defineReadOnly(this, \"bytecode\", bytecodeHex);\n        defineReadOnly(this, \"interface\", getStatic(new.target, \"getInterface\")(contractInterface));\n        defineReadOnly(this, \"signer\", signer || null);\n    }\n    // @TODO: Future; rename to populateTransaction?\n    getDeployTransaction(...args) {\n        let tx = {};\n        // If we have 1 additional argument, we allow transaction overrides\n        if (args.length === this.interface.deploy.inputs.length + 1 && typeof (args[args.length - 1]) === \"object\") {\n            tx = shallowCopy(args.pop());\n            for (const key in tx) {\n                if (!allowedTransactionKeys[key]) {\n                    throw new Error(\"unknown transaction override \" + key);\n                }\n            }\n        }\n        // Do not allow these to be overridden in a deployment transaction\n        [\"data\", \"from\", \"to\"].forEach((key) => {\n            if (tx[key] == null) {\n                return;\n            }\n            logger.throwError(\"cannot override \" + key, Logger.errors.UNSUPPORTED_OPERATION, { operation: key });\n        });\n        if (tx.value) {\n            const value = BigNumber.from(tx.value);\n            if (!value.isZero() && !this.interface.deploy.payable) {\n                logger.throwError(\"non-payable constructor cannot override value\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"overrides.value\",\n                    value: tx.value\n                });\n            }\n        }\n        // Make sure the call matches the constructor signature\n        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n        // Set the data to the bytecode + the encoded constructor arguments\n        tx.data = hexlify(concat([\n            this.bytecode,\n            this.interface.encodeDeploy(args)\n        ]));\n        return tx;\n    }\n    deploy(...args) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let overrides = {};\n            // If 1 extra parameter was passed in, it contains overrides\n            if (args.length === this.interface.deploy.inputs.length + 1) {\n                overrides = args.pop();\n            }\n            // Make sure the call matches the constructor signature\n            logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, \" in Contract constructor\");\n            // Resolve ENS names and promises in the arguments\n            const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);\n            params.push(overrides);\n            // Get the deployment transaction (with optional overrides)\n            const unsignedTx = this.getDeployTransaction(...params);\n            // Send the deployment transaction\n            const tx = yield this.signer.sendTransaction(unsignedTx);\n            const address = getStatic(this.constructor, \"getContractAddress\")(tx);\n            const contract = getStatic(this.constructor, \"getContract\")(address, this.interface, this.signer);\n            // Add the modified wait that wraps events\n            addContractWait(contract, tx);\n            defineReadOnly(contract, \"deployTransaction\", tx);\n            return contract;\n        });\n    }\n    attach(address) {\n        return (this.constructor).getContract(address, this.interface, this.signer);\n    }\n    connect(signer) {\n        return new (this.constructor)(this.interface, this.bytecode, signer);\n    }\n    static fromSolidity(compilerOutput, signer) {\n        if (compilerOutput == null) {\n            logger.throwError(\"missing compiler output\", Logger.errors.MISSING_ARGUMENT, { argument: \"compilerOutput\" });\n        }\n        if (typeof (compilerOutput) === \"string\") {\n            compilerOutput = JSON.parse(compilerOutput);\n        }\n        const abi = compilerOutput.abi;\n        let bytecode = null;\n        if (compilerOutput.bytecode) {\n            bytecode = compilerOutput.bytecode;\n        }\n        else if (compilerOutput.evm && compilerOutput.evm.bytecode) {\n            bytecode = compilerOutput.evm.bytecode;\n        }\n        return new this(abi, bytecode, signer);\n    }\n    static getInterface(contractInterface) {\n        return Contract.getInterface(contractInterface);\n    }\n    static getContractAddress(tx) {\n        return getContractAddress(tx);\n    }\n    static getContract(address, contractInterface, signer) {\n        return new Contract(address, contractInterface, signer);\n    }\n}\n//# sourceMappingURL=index.js.map","/**\n * var basex = require(\"base-x\");\n *\n * This implementation is heavily based on base-x. The main reason to\n * deviate was to prevent the dependency of Buffer.\n *\n * Contributors:\n *\n * base-x encoding\n * Forked from https://github.com/cryptocoinjs/bs58\n * Originally written by Mike Hearn for BitcoinJ\n * Copyright (c) 2011 Google Inc\n * Ported to JavaScript by Stefan Thomas\n * Merged Buffer refactorings from base58-native by Stephen Pair\n * Copyright (c) 2013 BitPay Inc\n *\n * The MIT License (MIT)\n *\n * Copyright base-x contributors (c) 2016\n *\n * Permission is hereby granted, free of charge, to any person obtaining a\n * copy of this software and associated documentation files (the \"Software\"),\n * to deal in the Software without restriction, including without limitation\n * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n * and/or sell copies of the Software, and to permit persons to whom the\n * Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n *\n */\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { defineReadOnly } from \"@ethersproject/properties\";\nexport class BaseX {\n    constructor(alphabet) {\n        defineReadOnly(this, \"alphabet\", alphabet);\n        defineReadOnly(this, \"base\", alphabet.length);\n        defineReadOnly(this, \"_alphabetMap\", {});\n        defineReadOnly(this, \"_leader\", alphabet.charAt(0));\n        // pre-compute lookup table\n        for (let i = 0; i < alphabet.length; i++) {\n            this._alphabetMap[alphabet.charAt(i)] = i;\n        }\n    }\n    encode(value) {\n        let source = arrayify(value);\n        if (source.length === 0) {\n            return \"\";\n        }\n        let digits = [0];\n        for (let i = 0; i < source.length; ++i) {\n            let carry = source[i];\n            for (let j = 0; j < digits.length; ++j) {\n                carry += digits[j] << 8;\n                digits[j] = carry % this.base;\n                carry = (carry / this.base) | 0;\n            }\n            while (carry > 0) {\n                digits.push(carry % this.base);\n                carry = (carry / this.base) | 0;\n            }\n        }\n        let string = \"\";\n        // deal with leading zeros\n        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {\n            string += this._leader;\n        }\n        // convert digits to a string\n        for (let q = digits.length - 1; q >= 0; --q) {\n            string += this.alphabet[digits[q]];\n        }\n        return string;\n    }\n    decode(value) {\n        if (typeof (value) !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        let bytes = [];\n        if (value.length === 0) {\n            return new Uint8Array(bytes);\n        }\n        bytes.push(0);\n        for (let i = 0; i < value.length; i++) {\n            let byte = this._alphabetMap[value[i]];\n            if (byte === undefined) {\n                throw new Error(\"Non-base\" + this.base + \" character\");\n            }\n            let carry = byte;\n            for (let j = 0; j < bytes.length; ++j) {\n                carry += bytes[j] * this.base;\n                bytes[j] = carry & 0xff;\n                carry >>= 8;\n            }\n            while (carry > 0) {\n                bytes.push(carry & 0xff);\n                carry >>= 8;\n            }\n        }\n        // deal with leading zeros\n        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {\n            bytes.push(0);\n        }\n        return arrayify(new Uint8Array(bytes.reverse()));\n    }\n}\nconst Base32 = new BaseX(\"abcdefghijklmnopqrstuvwxyz234567\");\nconst Base58 = new BaseX(\"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\");\nexport { Base32, Base58 };\n//console.log(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\"))\n//console.log(Base58.encode(Base58.decode(\"Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj\")))\n//# sourceMappingURL=index.js.map","export const version = \"sha2/5.7.0\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport hash from \"hash.js\";\n//const _ripemd160 = _hash.ripemd160;\nimport { arrayify } from \"@ethersproject/bytes\";\nimport { SupportedAlgorithm } from \"./types\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport function ripemd160(data) {\n    return \"0x\" + (hash.ripemd160().update(arrayify(data)).digest(\"hex\"));\n}\nexport function sha256(data) {\n    return \"0x\" + (hash.sha256().update(arrayify(data)).digest(\"hex\"));\n}\nexport function sha512(data) {\n    return \"0x\" + (hash.sha512().update(arrayify(data)).digest(\"hex\"));\n}\nexport function computeHmac(algorithm, key, data) {\n    if (!SupportedAlgorithm[algorithm]) {\n        logger.throwError(\"unsupported algorithm \" + algorithm, Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"hmac\",\n            algorithm: algorithm\n        });\n    }\n    return \"0x\" + hash.hmac(hash[algorithm], arrayify(key)).update(arrayify(data)).digest(\"hex\");\n}\n//# sourceMappingURL=sha2.js.map","export const version = \"networks/5.7.1\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n;\nfunction isRenetworkable(value) {\n    return (value && typeof (value.renetwork) === \"function\");\n}\nfunction ethDefaultProvider(network) {\n    const func = function (providers, options) {\n        if (options == null) {\n            options = {};\n        }\n        const providerList = [];\n        if (providers.InfuraProvider && options.infura !== \"-\") {\n            try {\n                providerList.push(new providers.InfuraProvider(network, options.infura));\n            }\n            catch (error) { }\n        }\n        if (providers.EtherscanProvider && options.etherscan !== \"-\") {\n            try {\n                providerList.push(new providers.EtherscanProvider(network, options.etherscan));\n            }\n            catch (error) { }\n        }\n        if (providers.AlchemyProvider && options.alchemy !== \"-\") {\n            try {\n                providerList.push(new providers.AlchemyProvider(network, options.alchemy));\n            }\n            catch (error) { }\n        }\n        if (providers.PocketProvider && options.pocket !== \"-\") {\n            // These networks are currently faulty on Pocket as their\n            // network does not handle the Berlin hardfork, which is\n            // live on these ones.\n            // @TODO: This goes away once Pocket has upgraded their nodes\n            const skip = [\"goerli\", \"ropsten\", \"rinkeby\", \"sepolia\"];\n            try {\n                const provider = new providers.PocketProvider(network, options.pocket);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providers.CloudflareProvider && options.cloudflare !== \"-\") {\n            try {\n                providerList.push(new providers.CloudflareProvider(network));\n            }\n            catch (error) { }\n        }\n        if (providers.AnkrProvider && options.ankr !== \"-\") {\n            try {\n                const skip = [\"ropsten\"];\n                const provider = new providers.AnkrProvider(network, options.ankr);\n                if (provider.network && skip.indexOf(provider.network.name) === -1) {\n                    providerList.push(provider);\n                }\n            }\n            catch (error) { }\n        }\n        if (providerList.length === 0) {\n            return null;\n        }\n        if (providers.FallbackProvider) {\n            let quorum = 1;\n            if (options.quorum != null) {\n                quorum = options.quorum;\n            }\n            else if (network === \"homestead\") {\n                quorum = 2;\n            }\n            return new providers.FallbackProvider(providerList, quorum);\n        }\n        return providerList[0];\n    };\n    func.renetwork = function (network) {\n        return ethDefaultProvider(network);\n    };\n    return func;\n}\nfunction etcDefaultProvider(url, network) {\n    const func = function (providers, options) {\n        if (providers.JsonRpcProvider) {\n            return new providers.JsonRpcProvider(url, network);\n        }\n        return null;\n    };\n    func.renetwork = function (network) {\n        return etcDefaultProvider(url, network);\n    };\n    return func;\n}\nconst homestead = {\n    chainId: 1,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"homestead\",\n    _defaultProvider: ethDefaultProvider(\"homestead\")\n};\nconst ropsten = {\n    chainId: 3,\n    ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n    name: \"ropsten\",\n    _defaultProvider: ethDefaultProvider(\"ropsten\")\n};\nconst classicMordor = {\n    chainId: 63,\n    name: \"classicMordor\",\n    _defaultProvider: etcDefaultProvider(\"https://www.ethercluster.com/mordor\", \"classicMordor\")\n};\n// See: https://chainlist.org\nconst networks = {\n    unspecified: { chainId: 0, name: \"unspecified\" },\n    homestead: homestead,\n    mainnet: homestead,\n    morden: { chainId: 2, name: \"morden\" },\n    ropsten: ropsten,\n    testnet: ropsten,\n    rinkeby: {\n        chainId: 4,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"rinkeby\",\n        _defaultProvider: ethDefaultProvider(\"rinkeby\")\n    },\n    kovan: {\n        chainId: 42,\n        name: \"kovan\",\n        _defaultProvider: ethDefaultProvider(\"kovan\")\n    },\n    goerli: {\n        chainId: 5,\n        ensAddress: \"0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e\",\n        name: \"goerli\",\n        _defaultProvider: ethDefaultProvider(\"goerli\")\n    },\n    kintsugi: { chainId: 1337702, name: \"kintsugi\" },\n    sepolia: {\n        chainId: 11155111,\n        name: \"sepolia\",\n        _defaultProvider: ethDefaultProvider(\"sepolia\")\n    },\n    // ETC (See: #351)\n    classic: {\n        chainId: 61,\n        name: \"classic\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/etc\", \"classic\")\n    },\n    classicMorden: { chainId: 62, name: \"classicMorden\" },\n    classicMordor: classicMordor,\n    classicTestnet: classicMordor,\n    classicKotti: {\n        chainId: 6,\n        name: \"classicKotti\",\n        _defaultProvider: etcDefaultProvider(\"https:/\\/www.ethercluster.com/kotti\", \"classicKotti\")\n    },\n    xdai: { chainId: 100, name: \"xdai\" },\n    matic: {\n        chainId: 137,\n        name: \"matic\",\n        _defaultProvider: ethDefaultProvider(\"matic\")\n    },\n    maticmum: { chainId: 80001, name: \"maticmum\" },\n    optimism: {\n        chainId: 10,\n        name: \"optimism\",\n        _defaultProvider: ethDefaultProvider(\"optimism\")\n    },\n    \"optimism-kovan\": { chainId: 69, name: \"optimism-kovan\" },\n    \"optimism-goerli\": { chainId: 420, name: \"optimism-goerli\" },\n    arbitrum: { chainId: 42161, name: \"arbitrum\" },\n    \"arbitrum-rinkeby\": { chainId: 421611, name: \"arbitrum-rinkeby\" },\n    \"arbitrum-goerli\": { chainId: 421613, name: \"arbitrum-goerli\" },\n    bnb: { chainId: 56, name: \"bnb\" },\n    bnbt: { chainId: 97, name: \"bnbt\" },\n};\n/**\n *  getNetwork\n *\n *  Converts a named common networks or chain ID (network ID) to a Network\n *  and verifies a network is a valid Network..\n */\nexport function getNetwork(network) {\n    // No network (null)\n    if (network == null) {\n        return null;\n    }\n    if (typeof (network) === \"number\") {\n        for (const name in networks) {\n            const standard = networks[name];\n            if (standard.chainId === network) {\n                return {\n                    name: standard.name,\n                    chainId: standard.chainId,\n                    ensAddress: (standard.ensAddress || null),\n                    _defaultProvider: (standard._defaultProvider || null)\n                };\n            }\n        }\n        return {\n            chainId: network,\n            name: \"unknown\"\n        };\n    }\n    if (typeof (network) === \"string\") {\n        const standard = networks[network];\n        if (standard == null) {\n            return null;\n        }\n        return {\n            name: standard.name,\n            chainId: standard.chainId,\n            ensAddress: standard.ensAddress,\n            _defaultProvider: (standard._defaultProvider || null)\n        };\n    }\n    const standard = networks[network.name];\n    // Not a standard network; check that it is a valid network in general\n    if (!standard) {\n        if (typeof (network.chainId) !== \"number\") {\n            logger.throwArgumentError(\"invalid network chainId\", \"network\", network);\n        }\n        return network;\n    }\n    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)\n    if (network.chainId !== 0 && network.chainId !== standard.chainId) {\n        logger.throwArgumentError(\"network chainId mismatch\", \"network\", network);\n    }\n    // @TODO: In the next major version add an attach function to a defaultProvider\n    // class and move the _defaultProvider internal to this file (extend Network)\n    let defaultProvider = network._defaultProvider || null;\n    if (defaultProvider == null && standard._defaultProvider) {\n        if (isRenetworkable(standard._defaultProvider)) {\n            defaultProvider = standard._defaultProvider.renetwork(network);\n        }\n        else {\n            defaultProvider = standard._defaultProvider;\n        }\n    }\n    // Standard Network (allow overriding the ENS address)\n    return {\n        name: network.name,\n        chainId: standard.chainId,\n        ensAddress: (network.ensAddress || standard.ensAddress || null),\n        _defaultProvider: defaultProvider\n    };\n}\n//# sourceMappingURL=index.js.map","export const version = \"web/5.7.1\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { arrayify } from \"@ethersproject/bytes\";\nexport function getUrl(href, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (options == null) {\n            options = {};\n        }\n        const request = {\n            method: (options.method || \"GET\"),\n            headers: (options.headers || {}),\n            body: (options.body || undefined),\n        };\n        if (options.skipFetchSetup !== true) {\n            request.mode = \"cors\"; // no-cors, cors, *same-origin\n            request.cache = \"no-cache\"; // *default, no-cache, reload, force-cache, only-if-cached\n            request.credentials = \"same-origin\"; // include, *same-origin, omit\n            request.redirect = \"follow\"; // manual, *follow, error\n            request.referrer = \"client\"; // no-referrer, *client\n        }\n        ;\n        if (options.fetchOptions != null) {\n            const opts = options.fetchOptions;\n            if (opts.mode) {\n                request.mode = (opts.mode);\n            }\n            if (opts.cache) {\n                request.cache = (opts.cache);\n            }\n            if (opts.credentials) {\n                request.credentials = (opts.credentials);\n            }\n            if (opts.redirect) {\n                request.redirect = (opts.redirect);\n            }\n            if (opts.referrer) {\n                request.referrer = opts.referrer;\n            }\n        }\n        const response = yield fetch(href, request);\n        const body = yield response.arrayBuffer();\n        const headers = {};\n        if (response.headers.forEach) {\n            response.headers.forEach((value, key) => {\n                headers[key.toLowerCase()] = value;\n            });\n        }\n        else {\n            ((response.headers).keys)().forEach((key) => {\n                headers[key.toLowerCase()] = response.headers.get(key);\n            });\n        }\n        return {\n            headers: headers,\n            statusCode: response.status,\n            statusMessage: response.statusText,\n            body: arrayify(new Uint8Array(body)),\n        };\n    });\n}\n//# sourceMappingURL=geturl.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { decode as base64Decode, encode as base64Encode } from \"@ethersproject/base64\";\nimport { hexlify, isBytesLike } from \"@ethersproject/bytes\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { getUrl } from \"./geturl\";\nfunction staller(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\nfunction bodyify(value, type) {\n    if (value == null) {\n        return null;\n    }\n    if (typeof (value) === \"string\") {\n        return value;\n    }\n    if (isBytesLike(value)) {\n        if (type && (type.split(\"/\")[0] === \"text\" || type.split(\";\")[0].trim() === \"application/json\")) {\n            try {\n                return toUtf8String(value);\n            }\n            catch (error) { }\n            ;\n        }\n        return hexlify(value);\n    }\n    return value;\n}\nfunction unpercent(value) {\n    return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {\n        return String.fromCharCode(parseInt(code, 16));\n    }));\n}\n// This API is still a work in progress; the future changes will likely be:\n// - ConnectionInfo => FetchDataRequest<T = any>\n// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }\n//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)\n// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T\n// For this reason, it should be considered internal until the API is finalized\nexport function _fetchData(connection, body, processFunc) {\n    // How many times to retry in the event of a throttle\n    const attemptLimit = (typeof (connection) === \"object\" && connection.throttleLimit != null) ? connection.throttleLimit : 12;\n    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0), \"invalid connection throttle limit\", \"connection.throttleLimit\", attemptLimit);\n    const throttleCallback = ((typeof (connection) === \"object\") ? connection.throttleCallback : null);\n    const throttleSlotInterval = ((typeof (connection) === \"object\" && typeof (connection.throttleSlotInterval) === \"number\") ? connection.throttleSlotInterval : 100);\n    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0), \"invalid connection throttle slot interval\", \"connection.throttleSlotInterval\", throttleSlotInterval);\n    const errorPassThrough = ((typeof (connection) === \"object\") ? !!(connection.errorPassThrough) : false);\n    const headers = {};\n    let url = null;\n    // @TODO: Allow ConnectionInfo to override some of these values\n    const options = {\n        method: \"GET\",\n    };\n    let allow304 = false;\n    let timeout = 2 * 60 * 1000;\n    if (typeof (connection) === \"string\") {\n        url = connection;\n    }\n    else if (typeof (connection) === \"object\") {\n        if (connection == null || connection.url == null) {\n            logger.throwArgumentError(\"missing URL\", \"connection.url\", connection);\n        }\n        url = connection.url;\n        if (typeof (connection.timeout) === \"number\" && connection.timeout > 0) {\n            timeout = connection.timeout;\n        }\n        if (connection.headers) {\n            for (const key in connection.headers) {\n                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };\n                if ([\"if-none-match\", \"if-modified-since\"].indexOf(key.toLowerCase()) >= 0) {\n                    allow304 = true;\n                }\n            }\n        }\n        options.allowGzip = !!connection.allowGzip;\n        if (connection.user != null && connection.password != null) {\n            if (url.substring(0, 6) !== \"https:\" && connection.allowInsecureAuthentication !== true) {\n                logger.throwError(\"basic authentication requires a secure https url\", Logger.errors.INVALID_ARGUMENT, { argument: \"url\", url: url, user: connection.user, password: \"[REDACTED]\" });\n            }\n            const authorization = connection.user + \":\" + connection.password;\n            headers[\"authorization\"] = {\n                key: \"Authorization\",\n                value: \"Basic \" + base64Encode(toUtf8Bytes(authorization))\n            };\n        }\n        if (connection.skipFetchSetup != null) {\n            options.skipFetchSetup = !!connection.skipFetchSetup;\n        }\n        if (connection.fetchOptions != null) {\n            options.fetchOptions = shallowCopy(connection.fetchOptions);\n        }\n    }\n    const reData = new RegExp(\"^data:([^;:]*)?(;base64)?,(.*)$\", \"i\");\n    const dataMatch = ((url) ? url.match(reData) : null);\n    if (dataMatch) {\n        try {\n            const response = {\n                statusCode: 200,\n                statusMessage: \"OK\",\n                headers: { \"content-type\": (dataMatch[1] || \"text/plain\") },\n                body: (dataMatch[2] ? base64Decode(dataMatch[3]) : unpercent(dataMatch[3]))\n            };\n            let result = response.body;\n            if (processFunc) {\n                result = processFunc(response.body, response);\n            }\n            return Promise.resolve(result);\n        }\n        catch (error) {\n            logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                body: bodyify(dataMatch[1], dataMatch[2]),\n                error: error,\n                requestBody: null,\n                requestMethod: \"GET\",\n                url: url\n            });\n        }\n    }\n    if (body) {\n        options.method = \"POST\";\n        options.body = body;\n        if (headers[\"content-type\"] == null) {\n            headers[\"content-type\"] = { key: \"Content-Type\", value: \"application/octet-stream\" };\n        }\n        if (headers[\"content-length\"] == null) {\n            headers[\"content-length\"] = { key: \"Content-Length\", value: String(body.length) };\n        }\n    }\n    const flatHeaders = {};\n    Object.keys(headers).forEach((key) => {\n        const header = headers[key];\n        flatHeaders[header.key] = header.value;\n    });\n    options.headers = flatHeaders;\n    const runningTimeout = (function () {\n        let timer = null;\n        const promise = new Promise(function (resolve, reject) {\n            if (timeout) {\n                timer = setTimeout(() => {\n                    if (timer == null) {\n                        return;\n                    }\n                    timer = null;\n                    reject(logger.makeError(\"timeout\", Logger.errors.TIMEOUT, {\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        timeout: timeout,\n                        url: url\n                    }));\n                }, timeout);\n            }\n        });\n        const cancel = function () {\n            if (timer == null) {\n                return;\n            }\n            clearTimeout(timer);\n            timer = null;\n        };\n        return { promise, cancel };\n    })();\n    const runningFetch = (function () {\n        return __awaiter(this, void 0, void 0, function* () {\n            for (let attempt = 0; attempt < attemptLimit; attempt++) {\n                let response = null;\n                try {\n                    response = yield getUrl(url, options);\n                    if (attempt < attemptLimit) {\n                        if (response.statusCode === 301 || response.statusCode === 302) {\n                            // Redirection; for now we only support absolute locataions\n                            const location = response.headers.location || \"\";\n                            if (options.method === \"GET\" && location.match(/^https:/)) {\n                                url = response.headers.location;\n                                continue;\n                            }\n                        }\n                        else if (response.statusCode === 429) {\n                            // Exponential back-off throttling\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                let stall = 0;\n                                const retryAfter = response.headers[\"retry-after\"];\n                                if (typeof (retryAfter) === \"string\" && retryAfter.match(/^[1-9][0-9]*$/)) {\n                                    stall = parseInt(retryAfter) * 1000;\n                                }\n                                else {\n                                    stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                }\n                                //console.log(\"Stalling 429\");\n                                yield staller(stall);\n                                continue;\n                            }\n                        }\n                    }\n                }\n                catch (error) {\n                    response = error.response;\n                    if (response == null) {\n                        runningTimeout.cancel();\n                        logger.throwError(\"missing response\", Logger.errors.SERVER_ERROR, {\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            serverError: error,\n                            url: url\n                        });\n                    }\n                }\n                let body = response.body;\n                if (allow304 && response.statusCode === 304) {\n                    body = null;\n                }\n                else if (!errorPassThrough && (response.statusCode < 200 || response.statusCode >= 300)) {\n                    runningTimeout.cancel();\n                    logger.throwError(\"bad response\", Logger.errors.SERVER_ERROR, {\n                        status: response.statusCode,\n                        headers: response.headers,\n                        body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                        requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                        requestMethod: options.method,\n                        url: url\n                    });\n                }\n                if (processFunc) {\n                    try {\n                        const result = yield processFunc(body, response);\n                        runningTimeout.cancel();\n                        return result;\n                    }\n                    catch (error) {\n                        // Allow the processFunc to trigger a throttle\n                        if (error.throttleRetry && attempt < attemptLimit) {\n                            let tryAgain = true;\n                            if (throttleCallback) {\n                                tryAgain = yield throttleCallback(attempt, url);\n                            }\n                            if (tryAgain) {\n                                const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                                //console.log(\"Stalling callback\");\n                                yield staller(timeout);\n                                continue;\n                            }\n                        }\n                        runningTimeout.cancel();\n                        logger.throwError(\"processing response error\", Logger.errors.SERVER_ERROR, {\n                            body: bodyify(body, ((response.headers) ? response.headers[\"content-type\"] : null)),\n                            error: error,\n                            requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                            requestMethod: options.method,\n                            url: url\n                        });\n                    }\n                }\n                runningTimeout.cancel();\n                // If we had a processFunc, it either returned a T or threw above.\n                // The \"body\" is now a Uint8Array.\n                return body;\n            }\n            return logger.throwError(\"failed response\", Logger.errors.SERVER_ERROR, {\n                requestBody: bodyify(options.body, flatHeaders[\"content-type\"]),\n                requestMethod: options.method,\n                url: url\n            });\n        });\n    })();\n    return Promise.race([runningTimeout.promise, runningFetch]);\n}\nexport function fetchJson(connection, json, processFunc) {\n    let processJsonFunc = (value, response) => {\n        let result = null;\n        if (value != null) {\n            try {\n                result = JSON.parse(toUtf8String(value));\n            }\n            catch (error) {\n                logger.throwError(\"invalid JSON\", Logger.errors.SERVER_ERROR, {\n                    body: value,\n                    error: error\n                });\n            }\n        }\n        if (processFunc) {\n            result = processFunc(result, response);\n        }\n        return result;\n    };\n    // If we have json to send, we must\n    // - add content-type of application/json (unless already overridden)\n    // - convert the json to bytes\n    let body = null;\n    if (json != null) {\n        body = toUtf8Bytes(json);\n        // Create a connection with the content-type set for JSON\n        const updated = (typeof (connection) === \"string\") ? ({ url: connection }) : shallowCopy(connection);\n        if (updated.headers) {\n            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === \"content-type\")).length) !== 0;\n            if (!hasContentType) {\n                updated.headers = shallowCopy(updated.headers);\n                updated.headers[\"content-type\"] = \"application/json\";\n            }\n        }\n        else {\n            updated.headers = { \"content-type\": \"application/json\" };\n        }\n        connection = updated;\n    }\n    return _fetchData(connection, body, processJsonFunc);\n}\nexport function poll(func, options) {\n    if (!options) {\n        options = {};\n    }\n    options = shallowCopy(options);\n    if (options.floor == null) {\n        options.floor = 0;\n    }\n    if (options.ceiling == null) {\n        options.ceiling = 10000;\n    }\n    if (options.interval == null) {\n        options.interval = 250;\n    }\n    return new Promise(function (resolve, reject) {\n        let timer = null;\n        let done = false;\n        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.\n        const cancel = () => {\n            if (done) {\n                return false;\n            }\n            done = true;\n            if (timer) {\n                clearTimeout(timer);\n            }\n            return true;\n        };\n        if (options.timeout) {\n            timer = setTimeout(() => {\n                if (cancel()) {\n                    reject(new Error(\"timeout\"));\n                }\n            }, options.timeout);\n        }\n        const retryLimit = options.retryLimit;\n        let attempt = 0;\n        function check() {\n            return func().then(function (result) {\n                // If we have a result, or are allowed null then we're done\n                if (result !== undefined) {\n                    if (cancel()) {\n                        resolve(result);\n                    }\n                }\n                else if (options.oncePoll) {\n                    options.oncePoll.once(\"poll\", check);\n                }\n                else if (options.onceBlock) {\n                    options.onceBlock.once(\"block\", check);\n                    // Otherwise, exponential back-off (up to 10s) our next request\n                }\n                else if (!done) {\n                    attempt++;\n                    if (attempt > retryLimit) {\n                        if (cancel()) {\n                            reject(new Error(\"retry limit reached\"));\n                        }\n                        return;\n                    }\n                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));\n                    if (timeout < options.floor) {\n                        timeout = options.floor;\n                    }\n                    if (timeout > options.ceiling) {\n                        timeout = options.ceiling;\n                    }\n                    setTimeout(check, timeout);\n                }\n                return null;\n            }, function (error) {\n                if (cancel()) {\n                    reject(error);\n                }\n            });\n        }\n        check();\n    });\n}\n//# sourceMappingURL=index.js.map","'use strict'\nvar ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'\n\n// pre-compute lookup table\nvar ALPHABET_MAP = {}\nfor (var z = 0; z < ALPHABET.length; z++) {\n  var x = ALPHABET.charAt(z)\n\n  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')\n  ALPHABET_MAP[x] = z\n}\n\nfunction polymodStep (pre) {\n  var b = pre >> 25\n  return ((pre & 0x1FFFFFF) << 5) ^\n    (-((b >> 0) & 1) & 0x3b6a57b2) ^\n    (-((b >> 1) & 1) & 0x26508e6d) ^\n    (-((b >> 2) & 1) & 0x1ea119fa) ^\n    (-((b >> 3) & 1) & 0x3d4233dd) ^\n    (-((b >> 4) & 1) & 0x2a1462b3)\n}\n\nfunction prefixChk (prefix) {\n  var chk = 1\n  for (var i = 0; i < prefix.length; ++i) {\n    var c = prefix.charCodeAt(i)\n    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'\n\n    chk = polymodStep(chk) ^ (c >> 5)\n  }\n  chk = polymodStep(chk)\n\n  for (i = 0; i < prefix.length; ++i) {\n    var v = prefix.charCodeAt(i)\n    chk = polymodStep(chk) ^ (v & 0x1f)\n  }\n  return chk\n}\n\nfunction encode (prefix, words, LIMIT) {\n  LIMIT = LIMIT || 90\n  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')\n\n  prefix = prefix.toLowerCase()\n\n  // determine chk mod\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') throw new Error(chk)\n\n  var result = prefix + '1'\n  for (var i = 0; i < words.length; ++i) {\n    var x = words[i]\n    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')\n\n    chk = polymodStep(chk) ^ x\n    result += ALPHABET.charAt(x)\n  }\n\n  for (i = 0; i < 6; ++i) {\n    chk = polymodStep(chk)\n  }\n  chk ^= 1\n\n  for (i = 0; i < 6; ++i) {\n    var v = (chk >> ((5 - i) * 5)) & 0x1f\n    result += ALPHABET.charAt(v)\n  }\n\n  return result\n}\n\nfunction __decode (str, LIMIT) {\n  LIMIT = LIMIT || 90\n  if (str.length < 8) return str + ' too short'\n  if (str.length > LIMIT) return 'Exceeds length limit'\n\n  // don't allow mixed case\n  var lowered = str.toLowerCase()\n  var uppered = str.toUpperCase()\n  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str\n  str = lowered\n\n  var split = str.lastIndexOf('1')\n  if (split === -1) return 'No separator character for ' + str\n  if (split === 0) return 'Missing prefix for ' + str\n\n  var prefix = str.slice(0, split)\n  var wordChars = str.slice(split + 1)\n  if (wordChars.length < 6) return 'Data too short'\n\n  var chk = prefixChk(prefix)\n  if (typeof chk === 'string') return chk\n\n  var words = []\n  for (var i = 0; i < wordChars.length; ++i) {\n    var c = wordChars.charAt(i)\n    var v = ALPHABET_MAP[c]\n    if (v === undefined) return 'Unknown character ' + c\n    chk = polymodStep(chk) ^ v\n\n    // not in the checksum?\n    if (i + 6 >= wordChars.length) continue\n    words.push(v)\n  }\n\n  if (chk !== 1) return 'Invalid checksum for ' + str\n  return { prefix: prefix, words: words }\n}\n\nfunction decodeUnsafe () {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n}\n\nfunction decode (str) {\n  var res = __decode.apply(null, arguments)\n  if (typeof res === 'object') return res\n\n  throw new Error(res)\n}\n\nfunction convert (data, inBits, outBits, pad) {\n  var value = 0\n  var bits = 0\n  var maxV = (1 << outBits) - 1\n\n  var result = []\n  for (var i = 0; i < data.length; ++i) {\n    value = (value << inBits) | data[i]\n    bits += inBits\n\n    while (bits >= outBits) {\n      bits -= outBits\n      result.push((value >> bits) & maxV)\n    }\n  }\n\n  if (pad) {\n    if (bits > 0) {\n      result.push((value << (outBits - bits)) & maxV)\n    }\n  } else {\n    if (bits >= inBits) return 'Excess padding'\n    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'\n  }\n\n  return result\n}\n\nfunction toWordsUnsafe (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n}\n\nfunction toWords (bytes) {\n  var res = convert(bytes, 8, 5, true)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nfunction fromWordsUnsafe (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n}\n\nfunction fromWords (words) {\n  var res = convert(words, 5, 8, false)\n  if (Array.isArray(res)) return res\n\n  throw new Error(res)\n}\n\nmodule.exports = {\n  decodeUnsafe: decodeUnsafe,\n  decode: decode,\n  encode: encode,\n  toWordsUnsafe: toWordsUnsafe,\n  toWords: toWords,\n  fromWordsUnsafe: fromWordsUnsafe,\n  fromWords: fromWords\n}\n","export const version = \"providers/5.7.2\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { getAddress, getContractAddress } from \"@ethersproject/address\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexDataLength, hexDataSlice, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { AddressZero } from \"@ethersproject/constants\";\nimport { shallowCopy } from \"@ethersproject/properties\";\nimport { accessListify, parse as parseTransaction } from \"@ethersproject/transactions\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nexport class Formatter {\n    constructor() {\n        this.formats = this.getDefaultFormats();\n    }\n    getDefaultFormats() {\n        const formats = ({});\n        const address = this.address.bind(this);\n        const bigNumber = this.bigNumber.bind(this);\n        const blockTag = this.blockTag.bind(this);\n        const data = this.data.bind(this);\n        const hash = this.hash.bind(this);\n        const hex = this.hex.bind(this);\n        const number = this.number.bind(this);\n        const type = this.type.bind(this);\n        const strictData = (v) => { return this.data(v, true); };\n        formats.transaction = {\n            hash: hash,\n            type: type,\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n            blockHash: Formatter.allowNull(hash, null),\n            blockNumber: Formatter.allowNull(number, null),\n            transactionIndex: Formatter.allowNull(number, null),\n            confirmations: Formatter.allowNull(number, null),\n            from: address,\n            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)\n            // must be set\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            gasLimit: bigNumber,\n            to: Formatter.allowNull(address, null),\n            value: bigNumber,\n            nonce: number,\n            data: data,\n            r: Formatter.allowNull(this.uint256),\n            s: Formatter.allowNull(this.uint256),\n            v: Formatter.allowNull(number),\n            creates: Formatter.allowNull(address, null),\n            raw: Formatter.allowNull(data),\n        };\n        formats.transactionRequest = {\n            from: Formatter.allowNull(address),\n            nonce: Formatter.allowNull(number),\n            gasLimit: Formatter.allowNull(bigNumber),\n            gasPrice: Formatter.allowNull(bigNumber),\n            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),\n            maxFeePerGas: Formatter.allowNull(bigNumber),\n            to: Formatter.allowNull(address),\n            value: Formatter.allowNull(bigNumber),\n            data: Formatter.allowNull(strictData),\n            type: Formatter.allowNull(number),\n            accessList: Formatter.allowNull(this.accessList.bind(this), null),\n        };\n        formats.receiptLog = {\n            transactionIndex: number,\n            blockNumber: number,\n            transactionHash: hash,\n            address: address,\n            topics: Formatter.arrayOf(hash),\n            data: data,\n            logIndex: number,\n            blockHash: hash,\n        };\n        formats.receipt = {\n            to: Formatter.allowNull(this.address, null),\n            from: Formatter.allowNull(this.address, null),\n            contractAddress: Formatter.allowNull(address, null),\n            transactionIndex: number,\n            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt\n            root: Formatter.allowNull(hex),\n            gasUsed: bigNumber,\n            logsBloom: Formatter.allowNull(data),\n            blockHash: hash,\n            transactionHash: hash,\n            logs: Formatter.arrayOf(this.receiptLog.bind(this)),\n            blockNumber: number,\n            confirmations: Formatter.allowNull(number, null),\n            cumulativeGasUsed: bigNumber,\n            effectiveGasPrice: Formatter.allowNull(bigNumber),\n            status: Formatter.allowNull(number),\n            type: type\n        };\n        formats.block = {\n            hash: Formatter.allowNull(hash),\n            parentHash: hash,\n            number: number,\n            timestamp: number,\n            nonce: Formatter.allowNull(hex),\n            difficulty: this.difficulty.bind(this),\n            gasLimit: bigNumber,\n            gasUsed: bigNumber,\n            miner: Formatter.allowNull(address),\n            extraData: data,\n            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),\n            baseFeePerGas: Formatter.allowNull(bigNumber)\n        };\n        formats.blockWithTransactions = shallowCopy(formats.block);\n        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));\n        formats.filter = {\n            fromBlock: Formatter.allowNull(blockTag, undefined),\n            toBlock: Formatter.allowNull(blockTag, undefined),\n            blockHash: Formatter.allowNull(hash, undefined),\n            address: Formatter.allowNull(address, undefined),\n            topics: Formatter.allowNull(this.topics.bind(this), undefined),\n        };\n        formats.filterLog = {\n            blockNumber: Formatter.allowNull(number),\n            blockHash: Formatter.allowNull(hash),\n            transactionIndex: number,\n            removed: Formatter.allowNull(this.boolean.bind(this)),\n            address: address,\n            data: Formatter.allowFalsish(data, \"0x\"),\n            topics: Formatter.arrayOf(hash),\n            transactionHash: hash,\n            logIndex: number,\n        };\n        return formats;\n    }\n    accessList(accessList) {\n        return accessListify(accessList || []);\n    }\n    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number\n    // Strict! Used on input.\n    number(number) {\n        if (number === \"0x\") {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    type(number) {\n        if (number === \"0x\" || number == null) {\n            return 0;\n        }\n        return BigNumber.from(number).toNumber();\n    }\n    // Strict! Used on input.\n    bigNumber(value) {\n        return BigNumber.from(value);\n    }\n    // Requires a boolean, \"true\" or  \"false\"; returns a boolean\n    boolean(value) {\n        if (typeof (value) === \"boolean\") {\n            return value;\n        }\n        if (typeof (value) === \"string\") {\n            value = value.toLowerCase();\n            if (value === \"true\") {\n                return true;\n            }\n            if (value === \"false\") {\n                return false;\n            }\n        }\n        throw new Error(\"invalid boolean - \" + value);\n    }\n    hex(value, strict) {\n        if (typeof (value) === \"string\") {\n            if (!strict && value.substring(0, 2) !== \"0x\") {\n                value = \"0x\" + value;\n            }\n            if (isHexString(value)) {\n                return value.toLowerCase();\n            }\n        }\n        return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n    }\n    data(value, strict) {\n        const result = this.hex(value, strict);\n        if ((result.length % 2) !== 0) {\n            throw new Error(\"invalid data; odd-length - \" + value);\n        }\n        return result;\n    }\n    // Requires an address\n    // Strict! Used on input.\n    address(value) {\n        return getAddress(value);\n    }\n    callAddress(value) {\n        if (!isHexString(value, 32)) {\n            return null;\n        }\n        const address = getAddress(hexDataSlice(value, 12));\n        return (address === AddressZero) ? null : address;\n    }\n    contractAddress(value) {\n        return getContractAddress(value);\n    }\n    // Strict! Used on input.\n    blockTag(blockTag) {\n        if (blockTag == null) {\n            return \"latest\";\n        }\n        if (blockTag === \"earliest\") {\n            return \"0x0\";\n        }\n        switch (blockTag) {\n            case \"earliest\": return \"0x0\";\n            case \"latest\":\n            case \"pending\":\n            case \"safe\":\n            case \"finalized\":\n                return blockTag;\n        }\n        if (typeof (blockTag) === \"number\" || isHexString(blockTag)) {\n            return hexValue(blockTag);\n        }\n        throw new Error(\"invalid blockTag\");\n    }\n    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.\n    hash(value, strict) {\n        const result = this.hex(value, strict);\n        if (hexDataLength(result) !== 32) {\n            return logger.throwArgumentError(\"invalid hash\", \"value\", value);\n        }\n        return result;\n    }\n    // Returns the difficulty as a number, or if too large (i.e. PoA network) null\n    difficulty(value) {\n        if (value == null) {\n            return null;\n        }\n        const v = BigNumber.from(value);\n        try {\n            return v.toNumber();\n        }\n        catch (error) { }\n        return null;\n    }\n    uint256(value) {\n        if (!isHexString(value)) {\n            throw new Error(\"invalid uint256\");\n        }\n        return hexZeroPad(value, 32);\n    }\n    _block(value, format) {\n        if (value.author != null && value.miner == null) {\n            value.miner = value.author;\n        }\n        // The difficulty may need to come from _difficulty in recursed blocks\n        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;\n        const result = Formatter.check(format, value);\n        result._difficulty = ((difficulty == null) ? null : BigNumber.from(difficulty));\n        return result;\n    }\n    block(value) {\n        return this._block(value, this.formats.block);\n    }\n    blockWithTransactions(value) {\n        return this._block(value, this.formats.blockWithTransactions);\n    }\n    // Strict! Used on input.\n    transactionRequest(value) {\n        return Formatter.check(this.formats.transactionRequest, value);\n    }\n    transactionResponse(transaction) {\n        // Rename gas to gasLimit\n        if (transaction.gas != null && transaction.gasLimit == null) {\n            transaction.gasLimit = transaction.gas;\n        }\n        // Some clients (TestRPC) do strange things like return 0x0 for the\n        // 0 address; correct this to be a real address\n        if (transaction.to && BigNumber.from(transaction.to).isZero()) {\n            transaction.to = \"0x0000000000000000000000000000000000000000\";\n        }\n        // Rename input to data\n        if (transaction.input != null && transaction.data == null) {\n            transaction.data = transaction.input;\n        }\n        // If to and creates are empty, populate the creates from the transaction\n        if (transaction.to == null && transaction.creates == null) {\n            transaction.creates = this.contractAddress(transaction);\n        }\n        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {\n            transaction.accessList = [];\n        }\n        const result = Formatter.check(this.formats.transaction, transaction);\n        if (transaction.chainId != null) {\n            let chainId = transaction.chainId;\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            result.chainId = chainId;\n        }\n        else {\n            let chainId = transaction.networkId;\n            // geth-etc returns chainId\n            if (chainId == null && result.v == null) {\n                chainId = transaction.chainId;\n            }\n            if (isHexString(chainId)) {\n                chainId = BigNumber.from(chainId).toNumber();\n            }\n            if (typeof (chainId) !== \"number\" && result.v != null) {\n                chainId = (result.v - 35) / 2;\n                if (chainId < 0) {\n                    chainId = 0;\n                }\n                chainId = parseInt(chainId);\n            }\n            if (typeof (chainId) !== \"number\") {\n                chainId = 0;\n            }\n            result.chainId = chainId;\n        }\n        // 0x0000... should actually be null\n        if (result.blockHash && result.blockHash.replace(/0/g, \"\") === \"x\") {\n            result.blockHash = null;\n        }\n        return result;\n    }\n    transaction(value) {\n        return parseTransaction(value);\n    }\n    receiptLog(value) {\n        return Formatter.check(this.formats.receiptLog, value);\n    }\n    receipt(value) {\n        const result = Formatter.check(this.formats.receipt, value);\n        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it\n        if (result.root != null) {\n            if (result.root.length <= 4) {\n                // Could be 0x00, 0x0, 0x01 or 0x1\n                const value = BigNumber.from(result.root).toNumber();\n                if (value === 0 || value === 1) {\n                    // Make sure if both are specified, they match\n                    if (result.status != null && (result.status !== value)) {\n                        logger.throwArgumentError(\"alt-root-status/status mismatch\", \"value\", { root: result.root, status: result.status });\n                    }\n                    result.status = value;\n                    delete result.root;\n                }\n                else {\n                    logger.throwArgumentError(\"invalid alt-root-status\", \"value.root\", result.root);\n                }\n            }\n            else if (result.root.length !== 66) {\n                // Must be a valid bytes32\n                logger.throwArgumentError(\"invalid root hash\", \"value.root\", result.root);\n            }\n        }\n        if (result.status != null) {\n            result.byzantium = true;\n        }\n        return result;\n    }\n    topics(value) {\n        if (Array.isArray(value)) {\n            return value.map((v) => this.topics(v));\n        }\n        else if (value != null) {\n            return this.hash(value, true);\n        }\n        return null;\n    }\n    filter(value) {\n        return Formatter.check(this.formats.filter, value);\n    }\n    filterLog(value) {\n        return Formatter.check(this.formats.filterLog, value);\n    }\n    static check(format, object) {\n        const result = {};\n        for (const key in format) {\n            try {\n                const value = format[key](object[key]);\n                if (value !== undefined) {\n                    result[key] = value;\n                }\n            }\n            catch (error) {\n                error.checkKey = key;\n                error.checkValue = object[key];\n                throw error;\n            }\n        }\n        return result;\n    }\n    // if value is null-ish, nullValue is returned\n    static allowNull(format, nullValue) {\n        return (function (value) {\n            if (value == null) {\n                return nullValue;\n            }\n            return format(value);\n        });\n    }\n    // If value is false-ish, replaceValue is returned\n    static allowFalsish(format, replaceValue) {\n        return (function (value) {\n            if (!value) {\n                return replaceValue;\n            }\n            return format(value);\n        });\n    }\n    // Requires an Array satisfying check\n    static arrayOf(format) {\n        return (function (array) {\n            if (!Array.isArray(array)) {\n                throw new Error(\"not an array\");\n            }\n            const result = [];\n            array.forEach(function (value) {\n                result.push(format(value));\n            });\n            return result;\n        });\n    }\n}\nexport function isCommunityResourcable(value) {\n    return (value && typeof (value.isCommunityResource) === \"function\");\n}\nexport function isCommunityResource(value) {\n    return (isCommunityResourcable(value) && value.isCommunityResource());\n}\n// Show the throttle message only once\nlet throttleMessage = false;\nexport function showThrottleMessage() {\n    if (throttleMessage) {\n        return;\n    }\n    throttleMessage = true;\n    console.log(\"========= NOTICE =========\");\n    console.log(\"Request-Rate Exceeded  (this message will not be repeated)\");\n    console.log(\"\");\n    console.log(\"The default API keys for each service are provided as a highly-throttled,\");\n    console.log(\"community resource for low-traffic projects and early prototyping.\");\n    console.log(\"\");\n    console.log(\"While your application will continue to function, we highly recommended\");\n    console.log(\"signing up for your own API keys to improve performance, increase your\");\n    console.log(\"request rate/limit and enable other perks, such as metrics and advanced APIs.\");\n    console.log(\"\");\n    console.log(\"For more details: https:/\\/docs.ethers.io/api-keys/\");\n    console.log(\"==========================\");\n}\n//# sourceMappingURL=formatter.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ForkEvent, Provider } from \"@ethersproject/abstract-provider\";\nimport { encode as base64Encode } from \"@ethersproject/base64\";\nimport { Base58 } from \"@ethersproject/basex\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { arrayify, concat, hexConcat, hexDataLength, hexDataSlice, hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { HashZero } from \"@ethersproject/constants\";\nimport { dnsEncode, namehash } from \"@ethersproject/hash\";\nimport { getNetwork } from \"@ethersproject/networks\";\nimport { defineReadOnly, getStatic, resolveProperties } from \"@ethersproject/properties\";\nimport { sha256 } from \"@ethersproject/sha2\";\nimport { toUtf8Bytes, toUtf8String } from \"@ethersproject/strings\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport bech32 from \"bech32\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { Formatter } from \"./formatter\";\nconst MAX_CCIP_REDIRECTS = 10;\n//////////////////////////////\n// Event Serializeing\nfunction checkTopic(topic) {\n    if (topic == null) {\n        return \"null\";\n    }\n    if (hexDataLength(topic) !== 32) {\n        logger.throwArgumentError(\"invalid topic\", \"topic\", topic);\n    }\n    return topic.toLowerCase();\n}\nfunction serializeTopics(topics) {\n    // Remove trailing null AND-topics; they are redundant\n    topics = topics.slice();\n    while (topics.length > 0 && topics[topics.length - 1] == null) {\n        topics.pop();\n    }\n    return topics.map((topic) => {\n        if (Array.isArray(topic)) {\n            // Only track unique OR-topics\n            const unique = {};\n            topic.forEach((topic) => {\n                unique[checkTopic(topic)] = true;\n            });\n            // The order of OR-topics does not matter\n            const sorted = Object.keys(unique);\n            sorted.sort();\n            return sorted.join(\"|\");\n        }\n        else {\n            return checkTopic(topic);\n        }\n    }).join(\"&\");\n}\nfunction deserializeTopics(data) {\n    if (data === \"\") {\n        return [];\n    }\n    return data.split(/&/g).map((topic) => {\n        if (topic === \"\") {\n            return [];\n        }\n        const comps = topic.split(\"|\").map((topic) => {\n            return ((topic === \"null\") ? null : topic);\n        });\n        return ((comps.length === 1) ? comps[0] : comps);\n    });\n}\nfunction getEventTag(eventName) {\n    if (typeof (eventName) === \"string\") {\n        eventName = eventName.toLowerCase();\n        if (hexDataLength(eventName) === 32) {\n            return \"tx:\" + eventName;\n        }\n        if (eventName.indexOf(\":\") === -1) {\n            return eventName;\n        }\n    }\n    else if (Array.isArray(eventName)) {\n        return \"filter:*:\" + serializeTopics(eventName);\n    }\n    else if (ForkEvent.isForkEvent(eventName)) {\n        logger.warn(\"not implemented\");\n        throw new Error(\"not implemented\");\n    }\n    else if (eventName && typeof (eventName) === \"object\") {\n        return \"filter:\" + (eventName.address || \"*\") + \":\" + serializeTopics(eventName.topics || []);\n    }\n    throw new Error(\"invalid event - \" + eventName);\n}\n//////////////////////////////\n// Helper Object\nfunction getTime() {\n    return (new Date()).getTime();\n}\nfunction stall(duration) {\n    return new Promise((resolve) => {\n        setTimeout(resolve, duration);\n    });\n}\n//////////////////////////////\n// Provider Object\n/**\n *  EventType\n *   - \"block\"\n *   - \"poll\"\n *   - \"didPoll\"\n *   - \"pending\"\n *   - \"error\"\n *   - \"network\"\n *   - filter\n *   - topics array\n *   - transaction hash\n */\nconst PollableEvents = [\"block\", \"network\", \"pending\", \"poll\"];\nexport class Event {\n    constructor(tag, listener, once) {\n        defineReadOnly(this, \"tag\", tag);\n        defineReadOnly(this, \"listener\", listener);\n        defineReadOnly(this, \"once\", once);\n        this._lastBlockNumber = -2;\n        this._inflight = false;\n    }\n    get event() {\n        switch (this.type) {\n            case \"tx\":\n                return this.hash;\n            case \"filter\":\n                return this.filter;\n        }\n        return this.tag;\n    }\n    get type() {\n        return this.tag.split(\":\")[0];\n    }\n    get hash() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"tx\") {\n            return null;\n        }\n        return comps[1];\n    }\n    get filter() {\n        const comps = this.tag.split(\":\");\n        if (comps[0] !== \"filter\") {\n            return null;\n        }\n        const address = comps[1];\n        const topics = deserializeTopics(comps[2]);\n        const filter = {};\n        if (topics.length > 0) {\n            filter.topics = topics;\n        }\n        if (address && address !== \"*\") {\n            filter.address = address;\n        }\n        return filter;\n    }\n    pollable() {\n        return (this.tag.indexOf(\":\") >= 0 || PollableEvents.indexOf(this.tag) >= 0);\n    }\n}\n;\n// https://github.com/satoshilabs/slips/blob/master/slip-0044.md\nconst coinInfos = {\n    \"0\": { symbol: \"btc\", p2pkh: 0x00, p2sh: 0x05, prefix: \"bc\" },\n    \"2\": { symbol: \"ltc\", p2pkh: 0x30, p2sh: 0x32, prefix: \"ltc\" },\n    \"3\": { symbol: \"doge\", p2pkh: 0x1e, p2sh: 0x16 },\n    \"60\": { symbol: \"eth\", ilk: \"eth\" },\n    \"61\": { symbol: \"etc\", ilk: \"eth\" },\n    \"700\": { symbol: \"xdai\", ilk: \"eth\" },\n};\nfunction bytes32ify(value) {\n    return hexZeroPad(BigNumber.from(value).toHexString(), 32);\n}\n// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)\nfunction base58Encode(data) {\n    return Base58.encode(concat([data, hexDataSlice(sha256(sha256(data)), 0, 4)]));\n}\nconst matcherIpfs = new RegExp(\"^(ipfs):/\\/(.*)$\", \"i\");\nconst matchers = [\n    new RegExp(\"^(https):/\\/(.*)$\", \"i\"),\n    new RegExp(\"^(data):(.*)$\", \"i\"),\n    matcherIpfs,\n    new RegExp(\"^eip155:[0-9]+/(erc[0-9]+):(.*)$\", \"i\"),\n];\nfunction _parseString(result, start) {\n    try {\n        return toUtf8String(_parseBytes(result, start));\n    }\n    catch (error) { }\n    return null;\n}\nfunction _parseBytes(result, start) {\n    if (result === \"0x\") {\n        return null;\n    }\n    const offset = BigNumber.from(hexDataSlice(result, start, start + 32)).toNumber();\n    const length = BigNumber.from(hexDataSlice(result, offset, offset + 32)).toNumber();\n    return hexDataSlice(result, offset + 32, offset + 32 + length);\n}\n// Trim off the ipfs:// prefix and return the default gateway URL\nfunction getIpfsLink(link) {\n    if (link.match(/^ipfs:\\/\\/ipfs\\//i)) {\n        link = link.substring(12);\n    }\n    else if (link.match(/^ipfs:\\/\\//i)) {\n        link = link.substring(7);\n    }\n    else {\n        logger.throwArgumentError(\"unsupported IPFS format\", \"link\", link);\n    }\n    return `https:/\\/gateway.ipfs.io/ipfs/${link}`;\n}\nfunction numPad(value) {\n    const result = arrayify(value);\n    if (result.length > 32) {\n        throw new Error(\"internal; should not happen\");\n    }\n    const padded = new Uint8Array(32);\n    padded.set(result, 32 - result.length);\n    return padded;\n}\nfunction bytesPad(value) {\n    if ((value.length % 32) === 0) {\n        return value;\n    }\n    const result = new Uint8Array(Math.ceil(value.length / 32) * 32);\n    result.set(value);\n    return result;\n}\n// ABI Encodes a series of (bytes, bytes, ...)\nfunction encodeBytes(datas) {\n    const result = [];\n    let byteCount = 0;\n    // Add place-holders for pointers as we add items\n    for (let i = 0; i < datas.length; i++) {\n        result.push(null);\n        byteCount += 32;\n    }\n    for (let i = 0; i < datas.length; i++) {\n        const data = arrayify(datas[i]);\n        // Update the bytes offset\n        result[i] = numPad(byteCount);\n        // The length and padded value of data\n        result.push(numPad(data.length));\n        result.push(bytesPad(data));\n        byteCount += 32 + Math.ceil(data.length / 32) * 32;\n    }\n    return hexConcat(result);\n}\nexport class Resolver {\n    // The resolvedAddress is only for creating a ReverseLookup resolver\n    constructor(provider, address, name, resolvedAddress) {\n        defineReadOnly(this, \"provider\", provider);\n        defineReadOnly(this, \"name\", name);\n        defineReadOnly(this, \"address\", provider.formatter.address(address));\n        defineReadOnly(this, \"_resolvedAddress\", resolvedAddress);\n    }\n    supportsWildcard() {\n        if (!this._supportsEip2544) {\n            // supportsInterface(bytes4 = selector(\"resolve(bytes,bytes)\"))\n            this._supportsEip2544 = this.provider.call({\n                to: this.address,\n                data: \"0x01ffc9a79061b92300000000000000000000000000000000000000000000000000000000\"\n            }).then((result) => {\n                return BigNumber.from(result).eq(1);\n            }).catch((error) => {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return false;\n                }\n                // Rethrow the error: link is down, etc. Let future attempts retry.\n                this._supportsEip2544 = null;\n                throw error;\n            });\n        }\n        return this._supportsEip2544;\n    }\n    _fetch(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // e.g. keccak256(\"addr(bytes32,uint256)\")\n            const tx = {\n                to: this.address,\n                ccipReadEnabled: true,\n                data: hexConcat([selector, namehash(this.name), (parameters || \"0x\")])\n            };\n            // Wildcard support; use EIP-2544 to resolve the request\n            let parseBytes = false;\n            if (yield this.supportsWildcard()) {\n                parseBytes = true;\n                // selector(\"resolve(bytes,bytes)\")\n                tx.data = hexConcat([\"0x9061b923\", encodeBytes([dnsEncode(this.name), tx.data])]);\n            }\n            try {\n                let result = yield this.provider.call(tx);\n                if ((arrayify(result).length % 32) === 4) {\n                    logger.throwError(\"resolver threw error\", Logger.errors.CALL_EXCEPTION, {\n                        transaction: tx, data: result\n                    });\n                }\n                if (parseBytes) {\n                    result = _parseBytes(result, 0);\n                }\n                return result;\n            }\n            catch (error) {\n                if (error.code === Logger.errors.CALL_EXCEPTION) {\n                    return null;\n                }\n                throw error;\n            }\n        });\n    }\n    _fetchBytes(selector, parameters) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const result = yield this._fetch(selector, parameters);\n            if (result != null) {\n                return _parseBytes(result, 0);\n            }\n            return null;\n        });\n    }\n    _getAddress(coinType, hexBytes) {\n        const coinInfo = coinInfos[String(coinType)];\n        if (coinInfo == null) {\n            logger.throwError(`unsupported coin type: ${coinType}`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: `getAddress(${coinType})`\n            });\n        }\n        if (coinInfo.ilk === \"eth\") {\n            return this.provider.formatter.address(hexBytes);\n        }\n        const bytes = arrayify(hexBytes);\n        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG\n        if (coinInfo.p2pkh != null) {\n            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);\n            if (p2pkh) {\n                const length = parseInt(p2pkh[1], 16);\n                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2pkh], (\"0x\" + p2pkh[2])]));\n                }\n            }\n        }\n        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL\n        if (coinInfo.p2sh != null) {\n            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);\n            if (p2sh) {\n                const length = parseInt(p2sh[1], 16);\n                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {\n                    return base58Encode(concat([[coinInfo.p2sh], (\"0x\" + p2sh[2])]));\n                }\n            }\n        }\n        // Bech32\n        if (coinInfo.prefix != null) {\n            const length = bytes[1];\n            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program\n            let version = bytes[0];\n            if (version === 0x00) {\n                if (length !== 20 && length !== 32) {\n                    version = -1;\n                }\n            }\n            else {\n                version = -1;\n            }\n            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {\n                const words = bech32.toWords(bytes.slice(2));\n                words.unshift(version);\n                return bech32.encode(coinInfo.prefix, words);\n            }\n        }\n        return null;\n    }\n    getAddress(coinType) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (coinType == null) {\n                coinType = 60;\n            }\n            // If Ethereum, use the standard `addr(bytes32)`\n            if (coinType === 60) {\n                try {\n                    // keccak256(\"addr(bytes32)\")\n                    const result = yield this._fetch(\"0x3b3b57de\");\n                    // No address\n                    if (result === \"0x\" || result === HashZero) {\n                        return null;\n                    }\n                    return this.provider.formatter.callAddress(result);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.CALL_EXCEPTION) {\n                        return null;\n                    }\n                    throw error;\n                }\n            }\n            // keccak256(\"addr(bytes32,uint256\")\n            const hexBytes = yield this._fetchBytes(\"0xf1cb7e06\", bytes32ify(coinType));\n            // No address\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // Compute the address\n            const address = this._getAddress(coinType, hexBytes);\n            if (address == null) {\n                logger.throwError(`invalid or unsupported coin data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `getAddress(${coinType})`,\n                    coinType: coinType,\n                    data: hexBytes\n                });\n            }\n            return address;\n        });\n    }\n    getAvatar() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const linkage = [{ type: \"name\", content: this.name }];\n            try {\n                // test data for ricmoo.eth\n                //const avatar = \"eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233\";\n                const avatar = yield this.getText(\"avatar\");\n                if (avatar == null) {\n                    return null;\n                }\n                for (let i = 0; i < matchers.length; i++) {\n                    const match = avatar.match(matchers[i]);\n                    if (match == null) {\n                        continue;\n                    }\n                    const scheme = match[1].toLowerCase();\n                    switch (scheme) {\n                        case \"https\":\n                            linkage.push({ type: \"url\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"data\":\n                            linkage.push({ type: \"data\", content: avatar });\n                            return { linkage, url: avatar };\n                        case \"ipfs\":\n                            linkage.push({ type: \"ipfs\", content: avatar });\n                            return { linkage, url: getIpfsLink(avatar) };\n                        case \"erc721\":\n                        case \"erc1155\": {\n                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)\n                            const selector = (scheme === \"erc721\") ? \"0xc87b56dd\" : \"0x0e89341c\";\n                            linkage.push({ type: scheme, content: avatar });\n                            // The owner of this name\n                            const owner = (this._resolvedAddress || (yield this.getAddress()));\n                            const comps = (match[2] || \"\").split(\"/\");\n                            if (comps.length !== 2) {\n                                return null;\n                            }\n                            const addr = yield this.provider.formatter.address(comps[0]);\n                            const tokenId = hexZeroPad(BigNumber.from(comps[1]).toHexString(), 32);\n                            // Check that this account owns the token\n                            if (scheme === \"erc721\") {\n                                // ownerOf(uint256 tokenId)\n                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x6352211e\", tokenId])\n                                }));\n                                if (owner !== tokenOwner) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"owner\", content: tokenOwner });\n                            }\n                            else if (scheme === \"erc1155\") {\n                                // balanceOf(address owner, uint256 tokenId)\n                                const balance = BigNumber.from(yield this.provider.call({\n                                    to: addr, data: hexConcat([\"0x00fdd58e\", hexZeroPad(owner, 32), tokenId])\n                                }));\n                                if (balance.isZero()) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"balance\", content: balance.toString() });\n                            }\n                            // Call the token contract for the metadata URL\n                            const tx = {\n                                to: this.provider.formatter.address(comps[0]),\n                                data: hexConcat([selector, tokenId])\n                            };\n                            let metadataUrl = _parseString(yield this.provider.call(tx), 0);\n                            if (metadataUrl == null) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata-url-base\", content: metadataUrl });\n                            // ERC-1155 allows a generic {id} in the URL\n                            if (scheme === \"erc1155\") {\n                                metadataUrl = metadataUrl.replace(\"{id}\", tokenId.substring(2));\n                                linkage.push({ type: \"metadata-url-expanded\", content: metadataUrl });\n                            }\n                            // Transform IPFS metadata links\n                            if (metadataUrl.match(/^ipfs:/i)) {\n                                metadataUrl = getIpfsLink(metadataUrl);\n                            }\n                            linkage.push({ type: \"metadata-url\", content: metadataUrl });\n                            // Get the token metadata\n                            const metadata = yield fetchJson(metadataUrl);\n                            if (!metadata) {\n                                return null;\n                            }\n                            linkage.push({ type: \"metadata\", content: JSON.stringify(metadata) });\n                            // Pull the image URL out\n                            let imageUrl = metadata.image;\n                            if (typeof (imageUrl) !== \"string\") {\n                                return null;\n                            }\n                            if (imageUrl.match(/^(https:\\/\\/|data:)/i)) {\n                                // Allow\n                            }\n                            else {\n                                // Transform IPFS link to gateway\n                                const ipfs = imageUrl.match(matcherIpfs);\n                                if (ipfs == null) {\n                                    return null;\n                                }\n                                linkage.push({ type: \"url-ipfs\", content: imageUrl });\n                                imageUrl = getIpfsLink(imageUrl);\n                            }\n                            linkage.push({ type: \"url\", content: imageUrl });\n                            return { linkage, url: imageUrl };\n                        }\n                    }\n                }\n            }\n            catch (error) { }\n            return null;\n        });\n    }\n    getContentHash() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // keccak256(\"contenthash()\")\n            const hexBytes = yield this._fetchBytes(\"0xbc1c58d1\");\n            // No contenthash\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            // IPFS (CID: 1, Type: DAG-PB)\n            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipfs) {\n                const length = parseInt(ipfs[3], 16);\n                if (ipfs[4].length === length * 2) {\n                    return \"ipfs:/\\/\" + Base58.encode(\"0x\" + ipfs[1]);\n                }\n            }\n            // IPNS (CID: 1, Type: libp2p-key)\n            const ipns = hexBytes.match(/^0xe5010172(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);\n            if (ipns) {\n                const length = parseInt(ipns[3], 16);\n                if (ipns[4].length === length * 2) {\n                    return \"ipns:/\\/\" + Base58.encode(\"0x\" + ipns[1]);\n                }\n            }\n            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)\n            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);\n            if (swarm) {\n                if (swarm[1].length === (32 * 2)) {\n                    return \"bzz:/\\/\" + swarm[1];\n                }\n            }\n            const skynet = hexBytes.match(/^0x90b2c605([0-9a-f]*)$/);\n            if (skynet) {\n                if (skynet[1].length === (34 * 2)) {\n                    // URL Safe base64; https://datatracker.ietf.org/doc/html/rfc4648#section-5\n                    const urlSafe = { \"=\": \"\", \"+\": \"-\", \"/\": \"_\" };\n                    const hash = base64Encode(\"0x\" + skynet[1]).replace(/[=+\\/]/g, (a) => (urlSafe[a]));\n                    return \"sia:/\\/\" + hash;\n                }\n            }\n            return logger.throwError(`invalid or unsupported content hash data`, Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"getContentHash()\",\n                data: hexBytes\n            });\n        });\n    }\n    getText(key) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // The key encoded as parameter to fetchBytes\n            let keyBytes = toUtf8Bytes(key);\n            // The nodehash consumes the first slot, so the string pointer targets\n            // offset 64, with the length at offset 64 and data starting at offset 96\n            keyBytes = concat([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);\n            // Pad to word-size (32 bytes)\n            if ((keyBytes.length % 32) !== 0) {\n                keyBytes = concat([keyBytes, hexZeroPad(\"0x\", 32 - (key.length % 32))]);\n            }\n            const hexBytes = yield this._fetchBytes(\"0x59d1d43c\", hexlify(keyBytes));\n            if (hexBytes == null || hexBytes === \"0x\") {\n                return null;\n            }\n            return toUtf8String(hexBytes);\n        });\n    }\n}\nlet defaultFormatter = null;\nlet nextPollId = 1;\nexport class BaseProvider extends Provider {\n    /**\n     *  ready\n     *\n     *  A Promise<Network> that resolves only once the provider is ready.\n     *\n     *  Sub-classes that call the super with a network without a chainId\n     *  MUST set this. Standard named networks have a known chainId.\n     *\n     */\n    constructor(network) {\n        super();\n        // Events being listened to\n        this._events = [];\n        this._emitted = { block: -2 };\n        this.disableCcipRead = false;\n        this.formatter = new.target.getFormatter();\n        // If network is any, this Provider allows the underlying\n        // network to change dynamically, and we auto-detect the\n        // current network\n        defineReadOnly(this, \"anyNetwork\", (network === \"any\"));\n        if (this.anyNetwork) {\n            network = this.detectNetwork();\n        }\n        if (network instanceof Promise) {\n            this._networkPromise = network;\n            // Squash any \"unhandled promise\" errors; that do not need to be handled\n            network.catch((error) => { });\n            // Trigger initial network setting (async)\n            this._ready().catch((error) => { });\n        }\n        else {\n            const knownNetwork = getStatic(new.target, \"getNetwork\")(network);\n            if (knownNetwork) {\n                defineReadOnly(this, \"_network\", knownNetwork);\n                this.emit(\"network\", knownNetwork, null);\n            }\n            else {\n                logger.throwArgumentError(\"invalid network\", \"network\", network);\n            }\n        }\n        this._maxInternalBlockNumber = -1024;\n        this._lastBlockNumber = -2;\n        this._maxFilterBlockRange = 10;\n        this._pollingInterval = 4000;\n        this._fastQueryDate = 0;\n    }\n    _ready() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._network == null) {\n                let network = null;\n                if (this._networkPromise) {\n                    try {\n                        network = yield this._networkPromise;\n                    }\n                    catch (error) { }\n                }\n                // Try the Provider's network detection (this MUST throw if it cannot)\n                if (network == null) {\n                    network = yield this.detectNetwork();\n                }\n                // This should never happen; every Provider sub-class should have\n                // suggested a network by here (or have thrown).\n                if (!network) {\n                    logger.throwError(\"no network detected\", Logger.errors.UNKNOWN_ERROR, {});\n                }\n                // Possible this call stacked so do not call defineReadOnly again\n                if (this._network == null) {\n                    if (this.anyNetwork) {\n                        this._network = network;\n                    }\n                    else {\n                        defineReadOnly(this, \"_network\", network);\n                    }\n                    this.emit(\"network\", network, null);\n                }\n            }\n            return this._network;\n        });\n    }\n    // This will always return the most recently established network.\n    // For \"any\", this can change (a \"network\" event is emitted before\n    // any change is reflected); otherwise this cannot change\n    get ready() {\n        return poll(() => {\n            return this._ready().then((network) => {\n                return network;\n            }, (error) => {\n                // If the network isn't running yet, we will wait\n                if (error.code === Logger.errors.NETWORK_ERROR && error.event === \"noNetwork\") {\n                    return undefined;\n                }\n                throw error;\n            });\n        });\n    }\n    // @TODO: Remove this and just create a singleton formatter\n    static getFormatter() {\n        if (defaultFormatter == null) {\n            defaultFormatter = new Formatter();\n        }\n        return defaultFormatter;\n    }\n    // @TODO: Remove this and just use getNetwork\n    static getNetwork(network) {\n        return getNetwork((network == null) ? \"homestead\" : network);\n    }\n    ccipReadFetch(tx, calldata, urls) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.disableCcipRead || urls.length === 0) {\n                return null;\n            }\n            const sender = tx.to.toLowerCase();\n            const data = calldata.toLowerCase();\n            const errorMessages = [];\n            for (let i = 0; i < urls.length; i++) {\n                const url = urls[i];\n                // URL expansion\n                const href = url.replace(\"{sender}\", sender).replace(\"{data}\", data);\n                // If no {data} is present, use POST; otherwise GET\n                const json = (url.indexOf(\"{data}\") >= 0) ? null : JSON.stringify({ data, sender });\n                const result = yield fetchJson({ url: href, errorPassThrough: true }, json, (value, response) => {\n                    value.status = response.statusCode;\n                    return value;\n                });\n                if (result.data) {\n                    return result.data;\n                }\n                const errorMessage = (result.message || \"unknown error\");\n                // 4xx indicates the result is not present; stop\n                if (result.status >= 400 && result.status < 500) {\n                    return logger.throwError(`response not found during CCIP fetch: ${errorMessage}`, Logger.errors.SERVER_ERROR, { url, errorMessage });\n                }\n                // 5xx indicates server issue; try the next url\n                errorMessages.push(errorMessage);\n            }\n            return logger.throwError(`error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(\", \")}`, Logger.errors.SERVER_ERROR, {\n                urls, errorMessages\n            });\n        });\n    }\n    // Fetches the blockNumber, but will reuse any result that is less\n    // than maxAge old or has been requested since the last request\n    _getInternalBlockNumber(maxAge) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this._ready();\n            // Allowing stale data up to maxAge old\n            if (maxAge > 0) {\n                // While there are pending internal block requests...\n                while (this._internalBlockNumber) {\n                    // ...\"remember\" which fetch we started with\n                    const internalBlockNumber = this._internalBlockNumber;\n                    try {\n                        // Check the result is not too stale\n                        const result = yield internalBlockNumber;\n                        if ((getTime() - result.respTime) <= maxAge) {\n                            return result.blockNumber;\n                        }\n                        // Too old; fetch a new value\n                        break;\n                    }\n                    catch (error) {\n                        // The fetch rejected; if we are the first to get the\n                        // rejection, drop through so we replace it with a new\n                        // fetch; all others blocked will then get that fetch\n                        // which won't match the one they \"remembered\" and loop\n                        if (this._internalBlockNumber === internalBlockNumber) {\n                            break;\n                        }\n                    }\n                }\n            }\n            const reqTime = getTime();\n            const checkInternalBlockNumber = resolveProperties({\n                blockNumber: this.perform(\"getBlockNumber\", {}),\n                networkError: this.getNetwork().then((network) => (null), (error) => (error))\n            }).then(({ blockNumber, networkError }) => {\n                if (networkError) {\n                    // Unremember this bad internal block number\n                    if (this._internalBlockNumber === checkInternalBlockNumber) {\n                        this._internalBlockNumber = null;\n                    }\n                    throw networkError;\n                }\n                const respTime = getTime();\n                blockNumber = BigNumber.from(blockNumber).toNumber();\n                if (blockNumber < this._maxInternalBlockNumber) {\n                    blockNumber = this._maxInternalBlockNumber;\n                }\n                this._maxInternalBlockNumber = blockNumber;\n                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?\n                return { blockNumber, reqTime, respTime };\n            });\n            this._internalBlockNumber = checkInternalBlockNumber;\n            // Swallow unhandled exceptions; if needed they are handled else where\n            checkInternalBlockNumber.catch((error) => {\n                // Don't null the dead (rejected) fetch, if it has already been updated\n                if (this._internalBlockNumber === checkInternalBlockNumber) {\n                    this._internalBlockNumber = null;\n                }\n            });\n            return (yield checkInternalBlockNumber).blockNumber;\n        });\n    }\n    poll() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const pollId = nextPollId++;\n            // Track all running promises, so we can trigger a post-poll once they are complete\n            const runners = [];\n            let blockNumber = null;\n            try {\n                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);\n            }\n            catch (error) {\n                this.emit(\"error\", error);\n                return;\n            }\n            this._setFastBlockNumber(blockNumber);\n            // Emit a poll event after we have the latest (fast) block number\n            this.emit(\"poll\", pollId, blockNumber);\n            // If the block has not changed, meh.\n            if (blockNumber === this._lastBlockNumber) {\n                this.emit(\"didPoll\", pollId);\n                return;\n            }\n            // First polling cycle, trigger a \"block\" events\n            if (this._emitted.block === -2) {\n                this._emitted.block = blockNumber - 1;\n            }\n            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {\n                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);\n                this.emit(\"error\", logger.makeError(\"network block skew detected\", Logger.errors.NETWORK_ERROR, {\n                    blockNumber: blockNumber,\n                    event: \"blockSkew\",\n                    previousBlockNumber: this._emitted.block\n                }));\n                this.emit(\"block\", blockNumber);\n            }\n            else {\n                // Notify all listener for each block that has passed\n                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {\n                    this.emit(\"block\", i);\n                }\n            }\n            // The emitted block was updated, check for obsolete events\n            if (this._emitted.block !== blockNumber) {\n                this._emitted.block = blockNumber;\n                Object.keys(this._emitted).forEach((key) => {\n                    // The block event does not expire\n                    if (key === \"block\") {\n                        return;\n                    }\n                    // The block we were at when we emitted this event\n                    const eventBlockNumber = this._emitted[key];\n                    // We cannot garbage collect pending transactions or blocks here\n                    // They should be garbage collected by the Provider when setting\n                    // \"pending\" events\n                    if (eventBlockNumber === \"pending\") {\n                        return;\n                    }\n                    // Evict any transaction hashes or block hashes over 12 blocks\n                    // old, since they should not return null anyways\n                    if (blockNumber - eventBlockNumber > 12) {\n                        delete this._emitted[key];\n                    }\n                });\n            }\n            // First polling cycle\n            if (this._lastBlockNumber === -2) {\n                this._lastBlockNumber = blockNumber - 1;\n            }\n            // Find all transaction hashes we are waiting on\n            this._events.forEach((event) => {\n                switch (event.type) {\n                    case \"tx\": {\n                        const hash = event.hash;\n                        let runner = this.getTransactionReceipt(hash).then((receipt) => {\n                            if (!receipt || receipt.blockNumber == null) {\n                                return null;\n                            }\n                            this._emitted[\"t:\" + hash] = receipt.blockNumber;\n                            this.emit(hash, receipt);\n                            return null;\n                        }).catch((error) => { this.emit(\"error\", error); });\n                        runners.push(runner);\n                        break;\n                    }\n                    case \"filter\": {\n                        // We only allow a single getLogs to be in-flight at a time\n                        if (!event._inflight) {\n                            event._inflight = true;\n                            // This is the first filter for this event, so we want to\n                            // restrict events to events that happened no earlier than now\n                            if (event._lastBlockNumber === -2) {\n                                event._lastBlockNumber = blockNumber - 1;\n                            }\n                            // Filter from the last *known* event; due to load-balancing\n                            // and some nodes returning updated block numbers before\n                            // indexing events, a logs result with 0 entries cannot be\n                            // trusted and we must retry a range which includes it again\n                            const filter = event.filter;\n                            filter.fromBlock = event._lastBlockNumber + 1;\n                            filter.toBlock = blockNumber;\n                            // Prevent fitler ranges from growing too wild, since it is quite\n                            // likely there just haven't been any events to move the lastBlockNumber.\n                            const minFromBlock = filter.toBlock - this._maxFilterBlockRange;\n                            if (minFromBlock > filter.fromBlock) {\n                                filter.fromBlock = minFromBlock;\n                            }\n                            if (filter.fromBlock < 0) {\n                                filter.fromBlock = 0;\n                            }\n                            const runner = this.getLogs(filter).then((logs) => {\n                                // Allow the next getLogs\n                                event._inflight = false;\n                                if (logs.length === 0) {\n                                    return;\n                                }\n                                logs.forEach((log) => {\n                                    // Only when we get an event for a given block number\n                                    // can we trust the events are indexed\n                                    if (log.blockNumber > event._lastBlockNumber) {\n                                        event._lastBlockNumber = log.blockNumber;\n                                    }\n                                    // Make sure we stall requests to fetch blocks and txs\n                                    this._emitted[\"b:\" + log.blockHash] = log.blockNumber;\n                                    this._emitted[\"t:\" + log.transactionHash] = log.blockNumber;\n                                    this.emit(filter, log);\n                                });\n                            }).catch((error) => {\n                                this.emit(\"error\", error);\n                                // Allow another getLogs (the range was not updated)\n                                event._inflight = false;\n                            });\n                            runners.push(runner);\n                        }\n                        break;\n                    }\n                }\n            });\n            this._lastBlockNumber = blockNumber;\n            // Once all events for this loop have been processed, emit \"didPoll\"\n            Promise.all(runners).then(() => {\n                this.emit(\"didPoll\", pollId);\n            }).catch((error) => { this.emit(\"error\", error); });\n            return;\n        });\n    }\n    // Deprecated; do not use this\n    resetEventsBlock(blockNumber) {\n        this._lastBlockNumber = blockNumber - 1;\n        if (this.polling) {\n            this.poll();\n        }\n    }\n    get network() {\n        return this._network;\n    }\n    // This method should query the network if the underlying network\n    // can change, such as when connected to a JSON-RPC backend\n    detectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return logger.throwError(\"provider does not support network detection\", Logger.errors.UNSUPPORTED_OPERATION, {\n                operation: \"provider.detectNetwork\"\n            });\n        });\n    }\n    getNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const network = yield this._ready();\n            // Make sure we are still connected to the same network; this is\n            // only an external call for backends which can have the underlying\n            // network change spontaneously\n            const currentNetwork = yield this.detectNetwork();\n            if (network.chainId !== currentNetwork.chainId) {\n                // We are allowing network changes, things can get complex fast;\n                // make sure you know what you are doing if you use \"any\"\n                if (this.anyNetwork) {\n                    this._network = currentNetwork;\n                    // Reset all internal block number guards and caches\n                    this._lastBlockNumber = -2;\n                    this._fastBlockNumber = null;\n                    this._fastBlockNumberPromise = null;\n                    this._fastQueryDate = 0;\n                    this._emitted.block = -2;\n                    this._maxInternalBlockNumber = -1024;\n                    this._internalBlockNumber = null;\n                    // The \"network\" event MUST happen before this method resolves\n                    // so any events have a chance to unregister, so we stall an\n                    // additional event loop before returning from /this/ call\n                    this.emit(\"network\", currentNetwork, network);\n                    yield stall(0);\n                    return this._network;\n                }\n                const error = logger.makeError(\"underlying network changed\", Logger.errors.NETWORK_ERROR, {\n                    event: \"changed\",\n                    network: network,\n                    detectedNetwork: currentNetwork\n                });\n                this.emit(\"error\", error);\n                throw error;\n            }\n            return network;\n        });\n    }\n    get blockNumber() {\n        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {\n            this._setFastBlockNumber(blockNumber);\n        }, (error) => { });\n        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;\n    }\n    get polling() {\n        return (this._poller != null);\n    }\n    set polling(value) {\n        if (value && !this._poller) {\n            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);\n            if (!this._bootstrapPoll) {\n                this._bootstrapPoll = setTimeout(() => {\n                    this.poll();\n                    // We block additional polls until the polling interval\n                    // is done, to prevent overwhelming the poll function\n                    this._bootstrapPoll = setTimeout(() => {\n                        // If polling was disabled, something may require a poke\n                        // since starting the bootstrap poll and it was disabled\n                        if (!this._poller) {\n                            this.poll();\n                        }\n                        // Clear out the bootstrap so we can do another\n                        this._bootstrapPoll = null;\n                    }, this.pollingInterval);\n                }, 0);\n            }\n        }\n        else if (!value && this._poller) {\n            clearInterval(this._poller);\n            this._poller = null;\n        }\n    }\n    get pollingInterval() {\n        return this._pollingInterval;\n    }\n    set pollingInterval(value) {\n        if (typeof (value) !== \"number\" || value <= 0 || parseInt(String(value)) != value) {\n            throw new Error(\"invalid polling interval\");\n        }\n        this._pollingInterval = value;\n        if (this._poller) {\n            clearInterval(this._poller);\n            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);\n        }\n    }\n    _getFastBlockNumber() {\n        const now = getTime();\n        // Stale block number, request a newer value\n        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {\n            this._fastQueryDate = now;\n            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {\n                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n                    this._fastBlockNumber = blockNumber;\n                }\n                return this._fastBlockNumber;\n            });\n        }\n        return this._fastBlockNumberPromise;\n    }\n    _setFastBlockNumber(blockNumber) {\n        // Older block, maybe a stale request\n        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {\n            return;\n        }\n        // Update the time we updated the blocknumber\n        this._fastQueryDate = getTime();\n        // Newer block number, use  it\n        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {\n            this._fastBlockNumber = blockNumber;\n            this._fastBlockNumberPromise = Promise.resolve(blockNumber);\n        }\n    }\n    waitForTransaction(transactionHash, confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);\n        });\n    }\n    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const receipt = yield this.getTransactionReceipt(transactionHash);\n            // Receipt is already good\n            if ((receipt ? receipt.confirmations : 0) >= confirmations) {\n                return receipt;\n            }\n            // Poll until the receipt is good...\n            return new Promise((resolve, reject) => {\n                const cancelFuncs = [];\n                let done = false;\n                const alreadyDone = function () {\n                    if (done) {\n                        return true;\n                    }\n                    done = true;\n                    cancelFuncs.forEach((func) => { func(); });\n                    return false;\n                };\n                const minedHandler = (receipt) => {\n                    if (receipt.confirmations < confirmations) {\n                        return;\n                    }\n                    if (alreadyDone()) {\n                        return;\n                    }\n                    resolve(receipt);\n                };\n                this.on(transactionHash, minedHandler);\n                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });\n                if (replaceable) {\n                    let lastBlockNumber = replaceable.startBlock;\n                    let scannedBlock = null;\n                    const replaceHandler = (blockNumber) => __awaiter(this, void 0, void 0, function* () {\n                        if (done) {\n                            return;\n                        }\n                        // Wait 1 second; this is only used in the case of a fault, so\n                        // we will trade off a little bit of latency for more consistent\n                        // results and fewer JSON-RPC calls\n                        yield stall(1000);\n                        this.getTransactionCount(replaceable.from).then((nonce) => __awaiter(this, void 0, void 0, function* () {\n                            if (done) {\n                                return;\n                            }\n                            if (nonce <= replaceable.nonce) {\n                                lastBlockNumber = blockNumber;\n                            }\n                            else {\n                                // First check if the transaction was mined\n                                {\n                                    const mined = yield this.getTransaction(transactionHash);\n                                    if (mined && mined.blockNumber != null) {\n                                        return;\n                                    }\n                                }\n                                // First time scanning. We start a little earlier for some\n                                // wiggle room here to handle the eventually consistent nature\n                                // of blockchain (e.g. the getTransactionCount was for a\n                                // different block)\n                                if (scannedBlock == null) {\n                                    scannedBlock = lastBlockNumber - 3;\n                                    if (scannedBlock < replaceable.startBlock) {\n                                        scannedBlock = replaceable.startBlock;\n                                    }\n                                }\n                                while (scannedBlock <= blockNumber) {\n                                    if (done) {\n                                        return;\n                                    }\n                                    const block = yield this.getBlockWithTransactions(scannedBlock);\n                                    for (let ti = 0; ti < block.transactions.length; ti++) {\n                                        const tx = block.transactions[ti];\n                                        // Successfully mined!\n                                        if (tx.hash === transactionHash) {\n                                            return;\n                                        }\n                                        // Matches our transaction from and nonce; its a replacement\n                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {\n                                            if (done) {\n                                                return;\n                                            }\n                                            // Get the receipt of the replacement\n                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);\n                                            // Already resolved or rejected (prolly a timeout)\n                                            if (alreadyDone()) {\n                                                return;\n                                            }\n                                            // The reason we were replaced\n                                            let reason = \"replaced\";\n                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {\n                                                reason = \"repriced\";\n                                            }\n                                            else if (tx.data === \"0x\" && tx.from === tx.to && tx.value.isZero()) {\n                                                reason = \"cancelled\";\n                                            }\n                                            // Explain why we were replaced\n                                            reject(logger.makeError(\"transaction was replaced\", Logger.errors.TRANSACTION_REPLACED, {\n                                                cancelled: (reason === \"replaced\" || reason === \"cancelled\"),\n                                                reason,\n                                                replacement: this._wrapTransaction(tx),\n                                                hash: transactionHash,\n                                                receipt\n                                            }));\n                                            return;\n                                        }\n                                    }\n                                    scannedBlock++;\n                                }\n                            }\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        }), (error) => {\n                            if (done) {\n                                return;\n                            }\n                            this.once(\"block\", replaceHandler);\n                        });\n                    });\n                    if (done) {\n                        return;\n                    }\n                    this.once(\"block\", replaceHandler);\n                    cancelFuncs.push(() => {\n                        this.removeListener(\"block\", replaceHandler);\n                    });\n                }\n                if (typeof (timeout) === \"number\" && timeout > 0) {\n                    const timer = setTimeout(() => {\n                        if (alreadyDone()) {\n                            return;\n                        }\n                        reject(logger.makeError(\"timeout exceeded\", Logger.errors.TIMEOUT, { timeout: timeout }));\n                    }, timeout);\n                    if (timer.unref) {\n                        timer.unref();\n                    }\n                    cancelFuncs.push(() => { clearTimeout(timer); });\n                }\n            });\n        });\n    }\n    getBlockNumber() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this._getInternalBlockNumber(0);\n        });\n    }\n    getGasPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const result = yield this.perform(\"getGasPrice\", {});\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getGasPrice\",\n                    result, error\n                });\n            }\n        });\n    }\n    getBalance(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getBalance\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getBalance\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getTransactionCount(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getTransactionCount\", params);\n            try {\n                return BigNumber.from(result).toNumber();\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getTransactionCount\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getCode(addressOrName, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag)\n            });\n            const result = yield this.perform(\"getCode\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getCode\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    getStorageAt(addressOrName, position, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                address: this._getAddress(addressOrName),\n                blockTag: this._getBlockTag(blockTag),\n                position: Promise.resolve(position).then((p) => hexValue(p))\n            });\n            const result = yield this.perform(\"getStorageAt\", params);\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"getStorageAt\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    // This should be called by any subclass wrapping a TransactionResponse\n    _wrapTransaction(tx, hash, startBlock) {\n        if (hash != null && hexDataLength(hash) !== 32) {\n            throw new Error(\"invalid response - sendTransaction\");\n        }\n        const result = tx;\n        // Check the hash we expect is the same as the hash the server reported\n        if (hash != null && tx.hash !== hash) {\n            logger.throwError(\"Transaction hash mismatch from Provider.sendTransaction.\", Logger.errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });\n        }\n        result.wait = (confirms, timeout) => __awaiter(this, void 0, void 0, function* () {\n            if (confirms == null) {\n                confirms = 1;\n            }\n            if (timeout == null) {\n                timeout = 0;\n            }\n            // Get the details to detect replacement\n            let replacement = undefined;\n            if (confirms !== 0 && startBlock != null) {\n                replacement = {\n                    data: tx.data,\n                    from: tx.from,\n                    nonce: tx.nonce,\n                    to: tx.to,\n                    value: tx.value,\n                    startBlock\n                };\n            }\n            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);\n            if (receipt == null && confirms === 0) {\n                return null;\n            }\n            // No longer pending, allow the polling loop to garbage collect this\n            this._emitted[\"t:\" + tx.hash] = receipt.blockNumber;\n            if (receipt.status === 0) {\n                logger.throwError(\"transaction failed\", Logger.errors.CALL_EXCEPTION, {\n                    transactionHash: tx.hash,\n                    transaction: tx,\n                    receipt: receipt\n                });\n            }\n            return receipt;\n        });\n        return result;\n    }\n    sendTransaction(signedTransaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const hexTx = yield Promise.resolve(signedTransaction).then(t => hexlify(t));\n            const tx = this.formatter.transaction(signedTransaction);\n            if (tx.confirmations == null) {\n                tx.confirmations = 0;\n            }\n            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n            try {\n                const hash = yield this.perform(\"sendTransaction\", { signedTransaction: hexTx });\n                return this._wrapTransaction(tx, hash, blockNumber);\n            }\n            catch (error) {\n                error.transaction = tx;\n                error.transactionHash = tx.hash;\n                throw error;\n            }\n        });\n    }\n    _getTransactionRequest(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const values = yield transaction;\n            const tx = {};\n            [\"from\", \"to\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));\n            });\n            [\"gasLimit\", \"gasPrice\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"value\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? BigNumber.from(v) : null));\n            });\n            [\"type\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));\n            });\n            if (values.accessList) {\n                tx.accessList = this.formatter.accessList(values.accessList);\n            }\n            [\"data\"].forEach((key) => {\n                if (values[key] == null) {\n                    return;\n                }\n                tx[key] = Promise.resolve(values[key]).then((v) => (v ? hexlify(v) : null));\n            });\n            return this.formatter.transactionRequest(yield resolveProperties(tx));\n        });\n    }\n    _getFilter(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            filter = yield filter;\n            const result = {};\n            if (filter.address != null) {\n                result.address = this._getAddress(filter.address);\n            }\n            [\"blockHash\", \"topics\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = filter[key];\n            });\n            [\"fromBlock\", \"toBlock\"].forEach((key) => {\n                if (filter[key] == null) {\n                    return;\n                }\n                result[key] = this._getBlockTag(filter[key]);\n            });\n            return this.formatter.filter(yield resolveProperties(result));\n        });\n    }\n    _call(transaction, blockTag, attempt) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (attempt >= MAX_CCIP_REDIRECTS) {\n                logger.throwError(\"CCIP read exceeded maximum redirections\", Logger.errors.SERVER_ERROR, {\n                    redirects: attempt, transaction\n                });\n            }\n            const txSender = transaction.to;\n            const result = yield this.perform(\"call\", { transaction, blockTag });\n            // CCIP Read request via OffchainLookup(address,string[],bytes,bytes4,bytes)\n            if (attempt >= 0 && blockTag === \"latest\" && txSender != null && result.substring(0, 10) === \"0x556f1830\" && (hexDataLength(result) % 32 === 4)) {\n                try {\n                    const data = hexDataSlice(result, 4);\n                    // Check the sender of the OffchainLookup matches the transaction\n                    const sender = hexDataSlice(data, 0, 32);\n                    if (!BigNumber.from(sender).eq(txSender)) {\n                        logger.throwError(\"CCIP Read sender did not match\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    // Read the URLs from the response\n                    const urls = [];\n                    const urlsOffset = BigNumber.from(hexDataSlice(data, 32, 64)).toNumber();\n                    const urlsLength = BigNumber.from(hexDataSlice(data, urlsOffset, urlsOffset + 32)).toNumber();\n                    const urlsData = hexDataSlice(data, urlsOffset + 32);\n                    for (let u = 0; u < urlsLength; u++) {\n                        const url = _parseString(urlsData, u * 32);\n                        if (url == null) {\n                            logger.throwError(\"CCIP Read contained corrupt URL string\", Logger.errors.CALL_EXCEPTION, {\n                                name: \"OffchainLookup\",\n                                signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                                transaction, data: result\n                            });\n                        }\n                        urls.push(url);\n                    }\n                    // Get the CCIP calldata to forward\n                    const calldata = _parseBytes(data, 64);\n                    // Get the callbackSelector (bytes4)\n                    if (!BigNumber.from(hexDataSlice(data, 100, 128)).isZero()) {\n                        logger.throwError(\"CCIP Read callback selector included junk\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const callbackSelector = hexDataSlice(data, 96, 100);\n                    // Get the extra data to send back to the contract as context\n                    const extraData = _parseBytes(data, 128);\n                    const ccipResult = yield this.ccipReadFetch(transaction, calldata, urls);\n                    if (ccipResult == null) {\n                        logger.throwError(\"CCIP Read disabled or provided no URLs\", Logger.errors.CALL_EXCEPTION, {\n                            name: \"OffchainLookup\",\n                            signature: \"OffchainLookup(address,string[],bytes,bytes4,bytes)\",\n                            transaction, data: result\n                        });\n                    }\n                    const tx = {\n                        to: txSender,\n                        data: hexConcat([callbackSelector, encodeBytes([ccipResult, extraData])])\n                    };\n                    return this._call(tx, blockTag, attempt + 1);\n                }\n                catch (error) {\n                    if (error.code === Logger.errors.SERVER_ERROR) {\n                        throw error;\n                    }\n                }\n            }\n            try {\n                return hexlify(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"call\",\n                    params: { transaction, blockTag }, result, error\n                });\n            }\n        });\n    }\n    call(transaction, blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const resolved = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction),\n                blockTag: this._getBlockTag(blockTag),\n                ccipReadEnabled: Promise.resolve(transaction.ccipReadEnabled)\n            });\n            return this._call(resolved.transaction, resolved.blockTag, resolved.ccipReadEnabled ? 0 : -1);\n        });\n    }\n    estimateGas(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({\n                transaction: this._getTransactionRequest(transaction)\n            });\n            const result = yield this.perform(\"estimateGas\", params);\n            try {\n                return BigNumber.from(result);\n            }\n            catch (error) {\n                return logger.throwError(\"bad result from backend\", Logger.errors.SERVER_ERROR, {\n                    method: \"estimateGas\",\n                    params, result, error\n                });\n            }\n        });\n    }\n    _getAddress(addressOrName) {\n        return __awaiter(this, void 0, void 0, function* () {\n            addressOrName = yield addressOrName;\n            if (typeof (addressOrName) !== \"string\") {\n                logger.throwArgumentError(\"invalid address or ENS name\", \"name\", addressOrName);\n            }\n            const address = yield this.resolveName(addressOrName);\n            if (address == null) {\n                logger.throwError(\"ENS name not configured\", Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: `resolveName(${JSON.stringify(addressOrName)})`\n                });\n            }\n            return address;\n        });\n    }\n    _getBlock(blockHashOrBlockTag, includeTransactions) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            blockHashOrBlockTag = yield blockHashOrBlockTag;\n            // If blockTag is a number (not \"latest\", etc), this is the block number\n            let blockNumber = -128;\n            const params = {\n                includeTransactions: !!includeTransactions\n            };\n            if (isHexString(blockHashOrBlockTag, 32)) {\n                params.blockHash = blockHashOrBlockTag;\n            }\n            else {\n                try {\n                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);\n                    if (isHexString(params.blockTag)) {\n                        blockNumber = parseInt(params.blockTag.substring(2), 16);\n                    }\n                }\n                catch (error) {\n                    logger.throwArgumentError(\"invalid block hash or block tag\", \"blockHashOrBlockTag\", blockHashOrBlockTag);\n                }\n            }\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const block = yield this.perform(\"getBlock\", params);\n                // Block was not found\n                if (block == null) {\n                    // For blockhashes, if we didn't say it existed, that blockhash may\n                    // not exist. If we did see it though, perhaps from a log, we know\n                    // it exists, and this node is just not caught up yet.\n                    if (params.blockHash != null) {\n                        if (this._emitted[\"b:\" + params.blockHash] == null) {\n                            return null;\n                        }\n                    }\n                    // For block tags, if we are asking for a future block, we return null\n                    if (params.blockTag != null) {\n                        if (blockNumber > this._emitted.block) {\n                            return null;\n                        }\n                    }\n                    // Retry on the next block\n                    return undefined;\n                }\n                // Add transactions\n                if (includeTransactions) {\n                    let blockNumber = null;\n                    for (let i = 0; i < block.transactions.length; i++) {\n                        const tx = block.transactions[i];\n                        if (tx.blockNumber == null) {\n                            tx.confirmations = 0;\n                        }\n                        else if (tx.confirmations == null) {\n                            if (blockNumber == null) {\n                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                            }\n                            // Add the confirmations using the fast block number (pessimistic)\n                            let confirmations = (blockNumber - tx.blockNumber) + 1;\n                            if (confirmations <= 0) {\n                                confirmations = 1;\n                            }\n                            tx.confirmations = confirmations;\n                        }\n                    }\n                    const blockWithTxs = this.formatter.blockWithTransactions(block);\n                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));\n                    return blockWithTxs;\n                }\n                return this.formatter.block(block);\n            }), { oncePoll: this });\n        });\n    }\n    getBlock(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, false));\n    }\n    getBlockWithTransactions(blockHashOrBlockTag) {\n        return (this._getBlock(blockHashOrBlockTag, true));\n    }\n    getTransaction(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransaction\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                const tx = this.formatter.transactionResponse(result);\n                if (tx.blockNumber == null) {\n                    tx.confirmations = 0;\n                }\n                else if (tx.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - tx.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    tx.confirmations = confirmations;\n                }\n                return this._wrapTransaction(tx);\n            }), { oncePoll: this });\n        });\n    }\n    getTransactionReceipt(transactionHash) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            transactionHash = yield transactionHash;\n            const params = { transactionHash: this.formatter.hash(transactionHash, true) };\n            return poll(() => __awaiter(this, void 0, void 0, function* () {\n                const result = yield this.perform(\"getTransactionReceipt\", params);\n                if (result == null) {\n                    if (this._emitted[\"t:\" + transactionHash] == null) {\n                        return null;\n                    }\n                    return undefined;\n                }\n                // \"geth-etc\" returns receipts before they are ready\n                if (result.blockHash == null) {\n                    return undefined;\n                }\n                const receipt = this.formatter.receipt(result);\n                if (receipt.blockNumber == null) {\n                    receipt.confirmations = 0;\n                }\n                else if (receipt.confirmations == null) {\n                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                    // Add the confirmations using the fast block number (pessimistic)\n                    let confirmations = (blockNumber - receipt.blockNumber) + 1;\n                    if (confirmations <= 0) {\n                        confirmations = 1;\n                    }\n                    receipt.confirmations = confirmations;\n                }\n                return receipt;\n            }), { oncePoll: this });\n        });\n    }\n    getLogs(filter) {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            const params = yield resolveProperties({ filter: this._getFilter(filter) });\n            const logs = yield this.perform(\"getLogs\", params);\n            logs.forEach((log) => {\n                if (log.removed == null) {\n                    log.removed = false;\n                }\n            });\n            return Formatter.arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);\n        });\n    }\n    getEtherPrice() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield this.getNetwork();\n            return this.perform(\"getEtherPrice\", {});\n        });\n    }\n    _getBlockTag(blockTag) {\n        return __awaiter(this, void 0, void 0, function* () {\n            blockTag = yield blockTag;\n            if (typeof (blockTag) === \"number\" && blockTag < 0) {\n                if (blockTag % 1) {\n                    logger.throwArgumentError(\"invalid BlockTag\", \"blockTag\", blockTag);\n                }\n                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);\n                blockNumber += blockTag;\n                if (blockNumber < 0) {\n                    blockNumber = 0;\n                }\n                return this.formatter.blockTag(blockNumber);\n            }\n            return this.formatter.blockTag(blockTag);\n        });\n    }\n    getResolver(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let currentName = name;\n            while (true) {\n                if (currentName === \"\" || currentName === \".\") {\n                    return null;\n                }\n                // Optimization since the eth node cannot change and does\n                // not have a wildcard resolver\n                if (name !== \"eth\" && currentName === \"eth\") {\n                    return null;\n                }\n                // Check the current node for a resolver\n                const addr = yield this._getResolver(currentName, \"getResolver\");\n                // Found a resolver!\n                if (addr != null) {\n                    const resolver = new Resolver(this, addr, name);\n                    // Legacy resolver found, using EIP-2544 so it isn't safe to use\n                    if (currentName !== name && !(yield resolver.supportsWildcard())) {\n                        return null;\n                    }\n                    return resolver;\n                }\n                // Get the parent node\n                currentName = currentName.split(\".\").slice(1).join(\".\");\n            }\n        });\n    }\n    _getResolver(name, operation) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (operation == null) {\n                operation = \"ENS\";\n            }\n            const network = yield this.getNetwork();\n            // No ENS...\n            if (!network.ensAddress) {\n                logger.throwError(\"network does not support ENS\", Logger.errors.UNSUPPORTED_OPERATION, { operation, network: network.name });\n            }\n            try {\n                // keccak256(\"resolver(bytes32)\")\n                const addrData = yield this.call({\n                    to: network.ensAddress,\n                    data: (\"0x0178b8bf\" + namehash(name).substring(2))\n                });\n                return this.formatter.callAddress(addrData);\n            }\n            catch (error) {\n                // ENS registry cannot throw errors on resolver(bytes32)\n            }\n            return null;\n        });\n    }\n    resolveName(name) {\n        return __awaiter(this, void 0, void 0, function* () {\n            name = yield name;\n            // If it is already an address, nothing to resolve\n            try {\n                return Promise.resolve(this.formatter.address(name));\n            }\n            catch (error) {\n                // If is is a hexstring, the address is bad (See #694)\n                if (isHexString(name)) {\n                    throw error;\n                }\n            }\n            if (typeof (name) !== \"string\") {\n                logger.throwArgumentError(\"invalid ENS name\", \"name\", name);\n            }\n            // Get the addr from the resolver\n            const resolver = yield this.getResolver(name);\n            if (!resolver) {\n                return null;\n            }\n            return yield resolver.getAddress();\n        });\n    }\n    lookupAddress(address) {\n        return __awaiter(this, void 0, void 0, function* () {\n            address = yield address;\n            address = this.formatter.address(address);\n            const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n            const resolverAddr = yield this._getResolver(node, \"lookupAddress\");\n            if (resolverAddr == null) {\n                return null;\n            }\n            // keccak(\"name(bytes32)\")\n            const name = _parseString(yield this.call({\n                to: resolverAddr,\n                data: (\"0x691f3431\" + namehash(node).substring(2))\n            }), 0);\n            const addr = yield this.resolveName(name);\n            if (addr != address) {\n                return null;\n            }\n            return name;\n        });\n    }\n    getAvatar(nameOrAddress) {\n        return __awaiter(this, void 0, void 0, function* () {\n            let resolver = null;\n            if (isHexString(nameOrAddress)) {\n                // Address; reverse lookup\n                const address = this.formatter.address(nameOrAddress);\n                const node = address.substring(2).toLowerCase() + \".addr.reverse\";\n                const resolverAddress = yield this._getResolver(node, \"getAvatar\");\n                if (!resolverAddress) {\n                    return null;\n                }\n                // Try resolving the avatar against the addr.reverse resolver\n                resolver = new Resolver(this, resolverAddress, node);\n                try {\n                    const avatar = yield resolver.getAvatar();\n                    if (avatar) {\n                        return avatar.url;\n                    }\n                }\n                catch (error) {\n                    if (error.code !== Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                }\n                // Try getting the name and performing forward lookup; allowing wildcards\n                try {\n                    // keccak(\"name(bytes32)\")\n                    const name = _parseString(yield this.call({\n                        to: resolverAddress,\n                        data: (\"0x691f3431\" + namehash(node).substring(2))\n                    }), 0);\n                    resolver = yield this.getResolver(name);\n                }\n                catch (error) {\n                    if (error.code !== Logger.errors.CALL_EXCEPTION) {\n                        throw error;\n                    }\n                    return null;\n                }\n            }\n            else {\n                // ENS name; forward lookup with wildcard\n                resolver = yield this.getResolver(nameOrAddress);\n                if (!resolver) {\n                    return null;\n                }\n            }\n            const avatar = yield resolver.getAvatar();\n            if (avatar == null) {\n                return null;\n            }\n            return avatar.url;\n        });\n    }\n    perform(method, params) {\n        return logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n    }\n    _startEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _stopEvent(event) {\n        this.polling = (this._events.filter((e) => e.pollable()).length > 0);\n    }\n    _addEventListener(eventName, listener, once) {\n        const event = new Event(getEventTag(eventName), listener, once);\n        this._events.push(event);\n        this._startEvent(event);\n        return this;\n    }\n    on(eventName, listener) {\n        return this._addEventListener(eventName, listener, false);\n    }\n    once(eventName, listener) {\n        return this._addEventListener(eventName, listener, true);\n    }\n    emit(eventName, ...args) {\n        let result = false;\n        let stopped = [];\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag) {\n                return true;\n            }\n            setTimeout(() => {\n                event.listener.apply(this, args);\n            }, 0);\n            result = true;\n            if (event.once) {\n                stopped.push(event);\n                return false;\n            }\n            return true;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return result;\n    }\n    listenerCount(eventName) {\n        if (!eventName) {\n            return this._events.length;\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events.filter((event) => {\n            return (event.tag === eventTag);\n        }).length;\n    }\n    listeners(eventName) {\n        if (eventName == null) {\n            return this._events.map((event) => event.listener);\n        }\n        let eventTag = getEventTag(eventName);\n        return this._events\n            .filter((event) => (event.tag === eventTag))\n            .map((event) => event.listener);\n    }\n    off(eventName, listener) {\n        if (listener == null) {\n            return this.removeAllListeners(eventName);\n        }\n        const stopped = [];\n        let found = false;\n        let eventTag = getEventTag(eventName);\n        this._events = this._events.filter((event) => {\n            if (event.tag !== eventTag || event.listener != listener) {\n                return true;\n            }\n            if (found) {\n                return true;\n            }\n            found = true;\n            stopped.push(event);\n            return false;\n        });\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n    removeAllListeners(eventName) {\n        let stopped = [];\n        if (eventName == null) {\n            stopped = this._events;\n            this._events = [];\n        }\n        else {\n            const eventTag = getEventTag(eventName);\n            this._events = this._events.filter((event) => {\n                if (event.tag !== eventTag) {\n                    return true;\n                }\n                stopped.push(event);\n                return false;\n            });\n        }\n        stopped.forEach((event) => { this._stopEvent(event); });\n        return this;\n    }\n}\n//# sourceMappingURL=base-provider.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Signer } from \"@ethersproject/abstract-signer\";\nimport { BigNumber } from \"@ethersproject/bignumber\";\nimport { hexlify, hexValue, hexZeroPad, isHexString } from \"@ethersproject/bytes\";\nimport { _TypedDataEncoder } from \"@ethersproject/hash\";\nimport { checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy } from \"@ethersproject/properties\";\nimport { toUtf8Bytes } from \"@ethersproject/strings\";\nimport { accessListify } from \"@ethersproject/transactions\";\nimport { fetchJson, poll } from \"@ethersproject/web\";\nimport { Logger } from \"@ethersproject/logger\";\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\nimport { BaseProvider } from \"./base-provider\";\nconst errorGas = [\"call\", \"estimateGas\"];\nfunction spelunk(value, requireData) {\n    if (value == null) {\n        return null;\n    }\n    // These *are* the droids we're looking for.\n    if (typeof (value.message) === \"string\" && value.message.match(\"reverted\")) {\n        const data = isHexString(value.data) ? value.data : null;\n        if (!requireData || data) {\n            return { message: value.message, data };\n        }\n    }\n    // Spelunk further...\n    if (typeof (value) === \"object\") {\n        for (const key in value) {\n            const result = spelunk(value[key], requireData);\n            if (result) {\n                return result;\n            }\n        }\n        return null;\n    }\n    // Might be a JSON string we can further descend...\n    if (typeof (value) === \"string\") {\n        try {\n            return spelunk(JSON.parse(value), requireData);\n        }\n        catch (error) { }\n    }\n    return null;\n}\nfunction checkError(method, error, params) {\n    const transaction = params.transaction || params.signedTransaction;\n    // Undo the \"convenience\" some nodes are attempting to prevent backwards\n    // incompatibility; maybe for v6 consider forwarding reverts as errors\n    if (method === \"call\") {\n        const result = spelunk(error, true);\n        if (result) {\n            return result.data;\n        }\n        // Nothing descriptive..\n        logger.throwError(\"missing revert data in call exception; Transaction reverted without a reason string\", Logger.errors.CALL_EXCEPTION, {\n            data: \"0x\", transaction, error\n        });\n    }\n    if (method === \"estimateGas\") {\n        // Try to find something, with a preference on SERVER_ERROR body\n        let result = spelunk(error.body, false);\n        if (result == null) {\n            result = spelunk(error, false);\n        }\n        // Found \"reverted\", this is a CALL_EXCEPTION\n        if (result) {\n            logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n                reason: result.message, method, transaction, error\n            });\n        }\n    }\n    // @TODO: Should we spelunk for message too?\n    let message = error.message;\n    if (error.code === Logger.errors.SERVER_ERROR && error.error && typeof (error.error.message) === \"string\") {\n        message = error.error.message;\n    }\n    else if (typeof (error.body) === \"string\") {\n        message = error.body;\n    }\n    else if (typeof (error.responseText) === \"string\") {\n        message = error.responseText;\n    }\n    message = (message || \"\").toLowerCase();\n    // \"insufficient funds for gas * price + value + cost(data)\"\n    if (message.match(/insufficient funds|base fee exceeds gas limit|InsufficientFunds/i)) {\n        logger.throwError(\"insufficient funds for intrinsic transaction cost\", Logger.errors.INSUFFICIENT_FUNDS, {\n            error, method, transaction\n        });\n    }\n    // \"nonce too low\"\n    if (message.match(/nonce (is )?too low/i)) {\n        logger.throwError(\"nonce has already been used\", Logger.errors.NONCE_EXPIRED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/replacement transaction underpriced|transaction gas price.*too low/i)) {\n        logger.throwError(\"replacement fee too low\", Logger.errors.REPLACEMENT_UNDERPRICED, {\n            error, method, transaction\n        });\n    }\n    // \"replacement transaction underpriced\"\n    if (message.match(/only replay-protected/i)) {\n        logger.throwError(\"legacy pre-eip-155 transactions not supported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            error, method, transaction\n        });\n    }\n    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted|revert/)) {\n        logger.throwError(\"cannot estimate gas; transaction may fail or may require manual gas limit\", Logger.errors.UNPREDICTABLE_GAS_LIMIT, {\n            error, method, transaction\n        });\n    }\n    throw error;\n}\nfunction timer(timeout) {\n    return new Promise(function (resolve) {\n        setTimeout(resolve, timeout);\n    });\n}\nfunction getResult(payload) {\n    if (payload.error) {\n        // @TODO: not any\n        const error = new Error(payload.error.message);\n        error.code = payload.error.code;\n        error.data = payload.error.data;\n        throw error;\n    }\n    return payload.result;\n}\nfunction getLowerCase(value) {\n    if (value) {\n        return value.toLowerCase();\n    }\n    return value;\n}\nconst _constructorGuard = {};\nexport class JsonRpcSigner extends Signer {\n    constructor(constructorGuard, provider, addressOrIndex) {\n        super();\n        if (constructorGuard !== _constructorGuard) {\n            throw new Error(\"do not call the JsonRpcSigner constructor directly; use provider.getSigner\");\n        }\n        defineReadOnly(this, \"provider\", provider);\n        if (addressOrIndex == null) {\n            addressOrIndex = 0;\n        }\n        if (typeof (addressOrIndex) === \"string\") {\n            defineReadOnly(this, \"_address\", this.provider.formatter.address(addressOrIndex));\n            defineReadOnly(this, \"_index\", null);\n        }\n        else if (typeof (addressOrIndex) === \"number\") {\n            defineReadOnly(this, \"_index\", addressOrIndex);\n            defineReadOnly(this, \"_address\", null);\n        }\n        else {\n            logger.throwArgumentError(\"invalid address or index\", \"addressOrIndex\", addressOrIndex);\n        }\n    }\n    connect(provider) {\n        return logger.throwError(\"cannot alter JSON-RPC Signer connection\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"connect\"\n        });\n    }\n    connectUnchecked() {\n        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);\n    }\n    getAddress() {\n        if (this._address) {\n            return Promise.resolve(this._address);\n        }\n        return this.provider.send(\"eth_accounts\", []).then((accounts) => {\n            if (accounts.length <= this._index) {\n                logger.throwError(\"unknown account #\" + this._index, Logger.errors.UNSUPPORTED_OPERATION, {\n                    operation: \"getAddress\"\n                });\n            }\n            return this.provider.formatter.address(accounts[this._index]);\n        });\n    }\n    sendUncheckedTransaction(transaction) {\n        transaction = shallowCopy(transaction);\n        const fromAddress = this.getAddress().then((address) => {\n            if (address) {\n                address = address.toLowerCase();\n            }\n            return address;\n        });\n        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user\n        // wishes to use this, it is easy to specify explicitly, otherwise\n        // we look it up for them.\n        if (transaction.gasLimit == null) {\n            const estimate = shallowCopy(transaction);\n            estimate.from = fromAddress;\n            transaction.gasLimit = this.provider.estimateGas(estimate);\n        }\n        if (transaction.to != null) {\n            transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {\n                if (to == null) {\n                    return null;\n                }\n                const address = yield this.provider.resolveName(to);\n                if (address == null) {\n                    logger.throwArgumentError(\"provided ENS name resolves to null\", \"tx.to\", to);\n                }\n                return address;\n            }));\n        }\n        return resolveProperties({\n            tx: resolveProperties(transaction),\n            sender: fromAddress\n        }).then(({ tx, sender }) => {\n            if (tx.from != null) {\n                if (tx.from.toLowerCase() !== sender) {\n                    logger.throwArgumentError(\"from address mismatch\", \"transaction\", transaction);\n                }\n            }\n            else {\n                tx.from = sender;\n            }\n            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });\n            return this.provider.send(\"eth_sendTransaction\", [hexTx]).then((hash) => {\n                return hash;\n            }, (error) => {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected transaction\", Logger.errors.ACTION_REJECTED, {\n                        action: \"sendTransaction\",\n                        transaction: tx\n                    });\n                }\n                return checkError(\"sendTransaction\", error, hexTx);\n            });\n        });\n    }\n    signTransaction(transaction) {\n        return logger.throwError(\"signing transactions is unsupported\", Logger.errors.UNSUPPORTED_OPERATION, {\n            operation: \"signTransaction\"\n        });\n    }\n    sendTransaction(transaction) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // This cannot be mined any earlier than any recent block\n            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);\n            // Send the transaction\n            const hash = yield this.sendUncheckedTransaction(transaction);\n            try {\n                // Unfortunately, JSON-RPC only provides and opaque transaction hash\n                // for a response, and we need the actual transaction, so we poll\n                // for it; it should show up very quickly\n                return yield poll(() => __awaiter(this, void 0, void 0, function* () {\n                    const tx = yield this.provider.getTransaction(hash);\n                    if (tx === null) {\n                        return undefined;\n                    }\n                    return this.provider._wrapTransaction(tx, hash, blockNumber);\n                }), { oncePoll: this.provider });\n            }\n            catch (error) {\n                error.transactionHash = hash;\n                throw error;\n            }\n        });\n    }\n    signMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"personal_sign\", [hexlify(data), address.toLowerCase()]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                        action: \"signMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _legacySignMessage(message) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = ((typeof (message) === \"string\") ? toUtf8Bytes(message) : message);\n            const address = yield this.getAddress();\n            try {\n                // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign\n                return yield this.provider.send(\"eth_sign\", [address.toLowerCase(), hexlify(data)]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                        action: \"_legacySignMessage\",\n                        from: address,\n                        messageData: message\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    _signTypedData(domain, types, value) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Populate any ENS names (in-place)\n            const populated = yield _TypedDataEncoder.resolveNames(domain, types, value, (name) => {\n                return this.provider.resolveName(name);\n            });\n            const address = yield this.getAddress();\n            try {\n                return yield this.provider.send(\"eth_signTypedData_v4\", [\n                    address.toLowerCase(),\n                    JSON.stringify(_TypedDataEncoder.getPayload(populated.domain, types, populated.value))\n                ]);\n            }\n            catch (error) {\n                if (typeof (error.message) === \"string\" && error.message.match(/user denied/i)) {\n                    logger.throwError(\"user rejected signing\", Logger.errors.ACTION_REJECTED, {\n                        action: \"_signTypedData\",\n                        from: address,\n                        messageData: { domain: populated.domain, types, value: populated.value }\n                    });\n                }\n                throw error;\n            }\n        });\n    }\n    unlock(password) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const provider = this.provider;\n            const address = yield this.getAddress();\n            return provider.send(\"personal_unlockAccount\", [address.toLowerCase(), password, null]);\n        });\n    }\n}\nclass UncheckedJsonRpcSigner extends JsonRpcSigner {\n    sendTransaction(transaction) {\n        return this.sendUncheckedTransaction(transaction).then((hash) => {\n            return {\n                hash: hash,\n                nonce: null,\n                gasLimit: null,\n                gasPrice: null,\n                data: null,\n                value: null,\n                chainId: null,\n                confirmations: 0,\n                from: null,\n                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }\n            };\n        });\n    }\n}\nconst allowedTransactionKeys = {\n    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,\n    type: true, accessList: true,\n    maxFeePerGas: true, maxPriorityFeePerGas: true\n};\nexport class JsonRpcProvider extends BaseProvider {\n    constructor(url, network) {\n        let networkOrReady = network;\n        // The network is unknown, query the JSON-RPC for it\n        if (networkOrReady == null) {\n            networkOrReady = new Promise((resolve, reject) => {\n                setTimeout(() => {\n                    this.detectNetwork().then((network) => {\n                        resolve(network);\n                    }, (error) => {\n                        reject(error);\n                    });\n                }, 0);\n            });\n        }\n        super(networkOrReady);\n        // Default URL\n        if (!url) {\n            url = getStatic(this.constructor, \"defaultUrl\")();\n        }\n        if (typeof (url) === \"string\") {\n            defineReadOnly(this, \"connection\", Object.freeze({\n                url: url\n            }));\n        }\n        else {\n            defineReadOnly(this, \"connection\", Object.freeze(shallowCopy(url)));\n        }\n        this._nextId = 42;\n    }\n    get _cache() {\n        if (this._eventLoopCache == null) {\n            this._eventLoopCache = {};\n        }\n        return this._eventLoopCache;\n    }\n    static defaultUrl() {\n        return \"http:/\\/localhost:8545\";\n    }\n    detectNetwork() {\n        if (!this._cache[\"detectNetwork\"]) {\n            this._cache[\"detectNetwork\"] = this._uncachedDetectNetwork();\n            // Clear this cache at the beginning of the next event loop\n            setTimeout(() => {\n                this._cache[\"detectNetwork\"] = null;\n            }, 0);\n        }\n        return this._cache[\"detectNetwork\"];\n    }\n    _uncachedDetectNetwork() {\n        return __awaiter(this, void 0, void 0, function* () {\n            yield timer(0);\n            let chainId = null;\n            try {\n                chainId = yield this.send(\"eth_chainId\", []);\n            }\n            catch (error) {\n                try {\n                    chainId = yield this.send(\"net_version\", []);\n                }\n                catch (error) { }\n            }\n            if (chainId != null) {\n                const getNetwork = getStatic(this.constructor, \"getNetwork\");\n                try {\n                    return getNetwork(BigNumber.from(chainId).toNumber());\n                }\n                catch (error) {\n                    return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                        chainId: chainId,\n                        event: \"invalidNetwork\",\n                        serverError: error\n                    });\n                }\n            }\n            return logger.throwError(\"could not detect network\", Logger.errors.NETWORK_ERROR, {\n                event: \"noNetwork\"\n            });\n        });\n    }\n    getSigner(addressOrIndex) {\n        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);\n    }\n    getUncheckedSigner(addressOrIndex) {\n        return this.getSigner(addressOrIndex).connectUnchecked();\n    }\n    listAccounts() {\n        return this.send(\"eth_accounts\", []).then((accounts) => {\n            return accounts.map((a) => this.formatter.address(a));\n        });\n    }\n    send(method, params) {\n        const request = {\n            method: method,\n            params: params,\n            id: (this._nextId++),\n            jsonrpc: \"2.0\"\n        };\n        this.emit(\"debug\", {\n            action: \"request\",\n            request: deepCopy(request),\n            provider: this\n        });\n        // We can expand this in the future to any call, but for now these\n        // are the biggest wins and do not require any serializing parameters.\n        const cache = ([\"eth_chainId\", \"eth_blockNumber\"].indexOf(method) >= 0);\n        if (cache && this._cache[method]) {\n            return this._cache[method];\n        }\n        const result = fetchJson(this.connection, JSON.stringify(request), getResult).then((result) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                request: request,\n                response: result,\n                provider: this\n            });\n            return result;\n        }, (error) => {\n            this.emit(\"debug\", {\n                action: \"response\",\n                error: error,\n                request: request,\n                provider: this\n            });\n            throw error;\n        });\n        // Cache the fetch, but clear it on the next event loop\n        if (cache) {\n            this._cache[method] = result;\n            setTimeout(() => {\n                this._cache[method] = null;\n            }, 0);\n        }\n        return result;\n    }\n    prepareRequest(method, params) {\n        switch (method) {\n            case \"getBlockNumber\":\n                return [\"eth_blockNumber\", []];\n            case \"getGasPrice\":\n                return [\"eth_gasPrice\", []];\n            case \"getBalance\":\n                return [\"eth_getBalance\", [getLowerCase(params.address), params.blockTag]];\n            case \"getTransactionCount\":\n                return [\"eth_getTransactionCount\", [getLowerCase(params.address), params.blockTag]];\n            case \"getCode\":\n                return [\"eth_getCode\", [getLowerCase(params.address), params.blockTag]];\n            case \"getStorageAt\":\n                return [\"eth_getStorageAt\", [getLowerCase(params.address), hexZeroPad(params.position, 32), params.blockTag]];\n            case \"sendTransaction\":\n                return [\"eth_sendRawTransaction\", [params.signedTransaction]];\n            case \"getBlock\":\n                if (params.blockTag) {\n                    return [\"eth_getBlockByNumber\", [params.blockTag, !!params.includeTransactions]];\n                }\n                else if (params.blockHash) {\n                    return [\"eth_getBlockByHash\", [params.blockHash, !!params.includeTransactions]];\n                }\n                return null;\n            case \"getTransaction\":\n                return [\"eth_getTransactionByHash\", [params.transactionHash]];\n            case \"getTransactionReceipt\":\n                return [\"eth_getTransactionReceipt\", [params.transactionHash]];\n            case \"call\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_call\", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];\n            }\n            case \"estimateGas\": {\n                const hexlifyTransaction = getStatic(this.constructor, \"hexlifyTransaction\");\n                return [\"eth_estimateGas\", [hexlifyTransaction(params.transaction, { from: true })]];\n            }\n            case \"getLogs\":\n                if (params.filter && params.filter.address != null) {\n                    params.filter.address = getLowerCase(params.filter.address);\n                }\n                return [\"eth_getLogs\", [params.filter]];\n            default:\n                break;\n        }\n        return null;\n    }\n    perform(method, params) {\n        return __awaiter(this, void 0, void 0, function* () {\n            // Legacy networks do not like the type field being passed along (which\n            // is fair), so we delete type if it is 0 and a non-EIP-1559 network\n            if (method === \"call\" || method === \"estimateGas\") {\n                const tx = params.transaction;\n                if (tx && tx.type != null && BigNumber.from(tx.type).isZero()) {\n                    // If there are no EIP-1559 properties, it might be non-EIP-1559\n                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {\n                        const feeData = yield this.getFeeData();\n                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {\n                            // Network doesn't know about EIP-1559 (and hence type)\n                            params = shallowCopy(params);\n                            params.transaction = shallowCopy(tx);\n                            delete params.transaction.type;\n                        }\n                    }\n                }\n            }\n            const args = this.prepareRequest(method, params);\n            if (args == null) {\n                logger.throwError(method + \" not implemented\", Logger.errors.NOT_IMPLEMENTED, { operation: method });\n            }\n            try {\n                return yield this.send(args[0], args[1]);\n            }\n            catch (error) {\n                return checkError(method, error, params);\n            }\n        });\n    }\n    _startEvent(event) {\n        if (event.tag === \"pending\") {\n            this._startPending();\n        }\n        super._startEvent(event);\n    }\n    _startPending() {\n        if (this._pendingFilter != null) {\n            return;\n        }\n        const self = this;\n        const pendingFilter = this.send(\"eth_newPendingTransactionFilter\", []);\n        this._pendingFilter = pendingFilter;\n        pendingFilter.then(function (filterId) {\n            function poll() {\n                self.send(\"eth_getFilterChanges\", [filterId]).then(function (hashes) {\n                    if (self._pendingFilter != pendingFilter) {\n                        return null;\n                    }\n                    let seq = Promise.resolve();\n                    hashes.forEach(function (hash) {\n                        // @TODO: This should be garbage collected at some point... How? When?\n                        self._emitted[\"t:\" + hash.toLowerCase()] = \"pending\";\n                        seq = seq.then(function () {\n                            return self.getTransaction(hash).then(function (tx) {\n                                self.emit(\"pending\", tx);\n                                return null;\n                            });\n                        });\n                    });\n                    return seq.then(function () {\n                        return timer(1000);\n                    });\n                }).then(function () {\n                    if (self._pendingFilter != pendingFilter) {\n                        self.send(\"eth_uninstallFilter\", [filterId]);\n                        return;\n                    }\n                    setTimeout(function () { poll(); }, 0);\n                    return null;\n                }).catch((error) => { });\n            }\n            poll();\n            return filterId;\n        }).catch((error) => { });\n    }\n    _stopEvent(event) {\n        if (event.tag === \"pending\" && this.listenerCount(\"pending\") === 0) {\n            this._pendingFilter = null;\n        }\n        super._stopEvent(event);\n    }\n    // Convert an ethers.js transaction into a JSON-RPC transaction\n    //  - gasLimit => gas\n    //  - All values hexlified\n    //  - All numeric values zero-striped\n    //  - All addresses are lowercased\n    // NOTE: This allows a TransactionRequest, but all values should be resolved\n    //       before this is called\n    // @TODO: This will likely be removed in future versions and prepareRequest\n    //        will be the preferred method for this.\n    static hexlifyTransaction(transaction, allowExtra) {\n        // Check only allowed properties are given\n        const allowed = shallowCopy(allowedTransactionKeys);\n        if (allowExtra) {\n            for (const key in allowExtra) {\n                if (allowExtra[key]) {\n                    allowed[key] = true;\n                }\n            }\n        }\n        checkProperties(transaction, allowed);\n        const result = {};\n        // JSON-RPC now requires numeric values to be \"quantity\" values\n        [\"chainId\", \"gasLimit\", \"gasPrice\", \"type\", \"maxFeePerGas\", \"maxPriorityFeePerGas\", \"nonce\", \"value\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            const value = hexValue(BigNumber.from(transaction[key]));\n            if (key === \"gasLimit\") {\n                key = \"gas\";\n            }\n            result[key] = value;\n        });\n        [\"from\", \"to\", \"data\"].forEach(function (key) {\n            if (transaction[key] == null) {\n                return;\n            }\n            result[key] = hexlify(transaction[key]);\n        });\n        if (transaction.accessList) {\n            result[\"accessList\"] = accessListify(transaction.accessList);\n        }\n        return result;\n    }\n}\n//# sourceMappingURL=json-rpc-provider.js.map","export const version = \"ethers/5.7.2\";\n//# sourceMappingURL=_version.js.map","\"use strict\";\nimport { BaseContract, Contract, ContractFactory } from \"@ethersproject/contracts\";\nimport { BigNumber, FixedNumber } from \"@ethersproject/bignumber\";\nimport { Signer, VoidSigner } from \"@ethersproject/abstract-signer\";\nimport { Wallet } from \"@ethersproject/wallet\";\nimport * as constants from \"@ethersproject/constants\";\nimport * as providers from \"@ethersproject/providers\";\nimport { getDefaultProvider } from \"@ethersproject/providers\";\nimport { Wordlist, wordlists } from \"@ethersproject/wordlists\";\nimport * as utils from \"./utils\";\nimport { ErrorCode as errors, Logger } from \"@ethersproject/logger\";\n////////////////////////\n// Compile-Time Constants\n// This is generated by \"npm run dist\"\nimport { version } from \"./_version\";\nconst logger = new Logger(version);\n////////////////////////\n// Exports\nexport { Signer, Wallet, VoidSigner, getDefaultProvider, providers, BaseContract, Contract, ContractFactory, BigNumber, FixedNumber, constants, errors, logger, utils, wordlists, \n////////////////////////\n// Compile-Time Constants\nversion, Wordlist };\n//# sourceMappingURL=ethers.js.map","import {IWalletAdapter} from \"./IWalletAdapter\";\nimport {Contract, ContractTransaction, ethers} from \"ethers\";\nimport {ITransactionListener} from \"../TokenScript\";\n\nexport interface IChainConfig {\n\trpc: string,\n\texplorer: string\n}\n\n/**\n * The in-build implementation of IWalletAdapter that uses ethers.js to connect a wide range of wallet providers\n */\nexport class EthersAdapter implements IWalletAdapter {\n\n\tprivate ethersProvider: ethers.providers.Web3Provider\n\n\tconstructor(public getWalletEthersProvider: () => Promise<ethers.providers.Web3Provider>, private chainConfig: {[key: number]: IChainConfig}) {\n\n\t}\n\n\tprivate async getEthersProvider(){\n\n\t\tthis.ethersProvider = await this.getWalletEthersProvider();\n\n\t\treturn this.ethersProvider;\n\t}\n\n\tasync signPersonalMessage(data){\n\t\tconst ethersProvider = await this.getEthersProvider();\n\n\t\treturn await ethersProvider.getSigner().signMessage(data);\n\t}\n\n\tasync call(chain: number, contractAddr: string, method: string, args: any[], outputTypes: string[]){\n\n\t\tconsole.log(\"Call ethereum method. chain \" + chain + \"; contract \" + contractAddr + \"; method \" + method + \";\");\n\t\t//console.log(args);\n\n\t\tconst contract = await this.getEthersContractInstance(chain, contractAddr, method, args, outputTypes, \"view\");\n\n\t\treturn await contract[method](...(args.map((arg: any) => arg.value))) as ContractTransaction;\n\t}\n\n\tasync sendTransaction(chain: number, contractAddr: string, method: string, args: any[], outputTypes: string[], value?: BigInt, waitForConfirmation: boolean = true, listener?: ITransactionListener){\n\n\t\tconsole.log(\"Send ethereum transaction. chain \" + chain + \"; contract \" + contractAddr + \"; method \" + method + \"; value \" + value);\n\t\tconsole.log(args);\n\n\t\tawait this.switchChain(chain);\n\n\t\t// TODO: if no method is set, send raw transaction? Is this allowed?\n\t\t// TODO: handle no-method transaction\n\n\t\tconst contract = await this.getEthersContractInstance(chain, contractAddr, method, args, outputTypes, value ? \"payable\" : \"nonpayable\");\n\n\t\tconst overrides: any = {};\n\n\t\tif (value)\n\t\t\toverrides.value = value;\n\n\t\tconst tx = await contract[method](...(args.map((arg: any) => arg.value)), overrides) as ContractTransaction;\n\n\t\tconsole.log(\"Transaction submitted: \" + tx.hash);\n\n\t\tlistener({\n\t\t\tstatus: 'submitted',\n\t\t\ttxNumber: tx.hash\n\t\t});\n\n\t\tif (waitForConfirmation)\n\t\t\tawait tx.wait().then((transactionReceipt) => {\n\n\t\t\t\tif (transactionReceipt.status !== 1) {\n\t\t\t\t\tconsole.error(transactionReceipt);\n\t\t\t\t\tthrow new Error(\"Transaction failed: \" + transactionReceipt.status);\n\t\t\t\t}\n\n\t\t\t\tconsole.log(\"Transaction completed!\");\n\n\t\t\t\tlistener({\n\t\t\t\t\tstatus: 'confirmed',\n\t\t\t\t\ttxNumber: tx.hash,\n\t\t\t\t\ttxLink: this.chainConfig[chain].explorer ? this.chainConfig[chain].explorer + tx.hash : null\n\t\t\t\t});\n\n\t\t\t\treturn transactionReceipt;\n\t\t\t});\n\n\t\treturn tx;\n\t}\n\n\tprivate async getEthersContractInstance(chain: number, contractAddr: string, method: string, args: any[], outputTypes: string[], stateMutability: string){\n\n\t\tconst abiData = {\n\t\t\tname: method,\n\t\t\tinputs: args,\n\t\t\toutputs: outputTypes.map((value, index) => {\n\n\t\t\t\t// Converted value\n\t\t\t\tconst convertedType = value === \"uint\" ? \"uint256\" : value;\n\n\t\t\t\treturn {\n\t\t\t\t\tname: index.toString(),\n\t\t\t\t\ttype: convertedType,\n\t\t\t\t\tinternalType: convertedType\n\t\t\t\t}\n\t\t\t}),\n\t\t\tstateMutability: stateMutability,\n\t\t\ttype: \"function\"\n\t\t};\n\n\t\tconsole.log(abiData);\n\n\t\t// TODO: add all chain URLs into some configuration.\n\t\tconst provider = stateMutability === \"view\" ?\n\t\t\t\t\t\t\tnew ethers.providers.JsonRpcProvider(this.getRpcUrl(chain), chain) :\n\t\t\t\t\t\t\t(await this.getEthersProvider()).getSigner();\n\n\t\treturn new Contract(contractAddr, [abiData], provider);\n\t}\n\n\tprivate getRpcUrl(chainId: number){\n\n\t\tif (!this.chainConfig[chainId])\n\t\t\tthrow new Error(\"RPC URL is not configured for ethereum chain: \" + chainId);\n\n\t\treturn this.chainConfig[chainId].rpc;\n\t}\n\n\tasync getChain(){\n\n\t\tif (!this.ethersProvider)\n\t\t\treturn 1;\n\n\t\tconst ethersProvider = await this.getEthersProvider();\n\n\t\tconst network = await ethersProvider.getNetwork();\n\n\t\treturn network.chainId;\n\t}\n\n\tprivate async switchChain(chain: number){\n\n\t\tconst ethersProvider = await this.getEthersProvider();\n\n\t\tif (chain != await this.getChain()){\n\n\t\t\tconsole.log(\"Switch chain: \", chain);\n\n\t\t\ttry {\n\t\t\t\tawait ethersProvider.send(\"wallet_switchEthereumChain\", [{chainId: \"0x\" + chain.toString(16)}]);\n\t\t\t} catch (e){\n\t\t\t\tconsole.error(e);\n\t\t\t\tthrow new Error(\"Connected to wrong chain, please switch the chain to chainId: \" + chain + \", error: \" + e.message);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync getCurrentWalletAddress() {\n\n\t\tconst ethersProvider = await this.getEthersProvider();\n\n\t\tconst accounts = await ethersProvider.listAccounts();\n\n\t\tif (!accounts?.length){\n\t\t\tthrow new Error(\"Wallet could not connect or there is no accounts created\");\n\t\t}\n\n\t\treturn accounts[0];\n\t}\n\n\tasync getEvents(chain: number, contractAddr: string, event: string, inputs: any[]) {\n\n\t\tconsole.log(\"Get ethereum events. chain \" + chain + \"; contract \" + contractAddr + \"; event \" + event + \";\");\n\t\tconsole.log(inputs);\n\n\t\tconst provider = new ethers.providers.JsonRpcProvider(this.getRpcUrl(chain));\n\n\t\tconst contract = new Contract(contractAddr, [{\n\t\t\tname: event,\n\t\t\ttype: \"event\",\n\t\t\tinputs: inputs\n\t\t}], provider);\n\n\t\tconst values = inputs.map((input) => input.value);\n\n\t\treturn await contract.queryFilter(contract.filters[event](...values));\n\t}\n}\n","\n:host {\n\theight: 100vh;\n}\n\n.app-container {\n\tmin-height: 100vh;\n\tdisplay: flex;\n\tflex-direction: column;\n}\n\nheader {\n  background: #5851ff;\n  color: white;\n  height: 56px;\n  display: flex;\n  align-items: center;\n  box-shadow: 0 2px 5px 0 rgba(0, 0, 0, 0.26);\n}\n\n.header-icon {\n\twidth: 38px;\n\theight: auto;\n\tpadding-left: 10px;\n}\n\nheader h1 {\n\tmargin: 5px 0 0;\n}\n\nh1 {\n  font-size: 1.4rem;\n  font-weight: 500;\n  color: #fff;\n  padding: 0 12px;\n}\n\nmain {\n\tdisplay: flex;\n\tflex-direction: column;\n\tflex-grow: 1;\n}\n\n#tab-header {\n\tdisplay: flex;\n\tborder-bottom: 1px solid teal;\n}\n\n#tab-content {\n\tposition: relative;\n\tflex-grow: 1;\n}\n\n#tab-content > * {\n\tdisplay: none;\n}\n\n#tab-content > .active {\n\tdisplay: block !important;\n}\n\n#ts-loader {\n\tdisplay: none;\n\tposition: absolute;\n\ttop: 0;\n\twidth: 100%;\n\theight: 100%;\n\talign-items: center;\n\tjustify-content: center;\n\tbackground-color: rgba(131,131,131,0.67)\n}\n","import {Component, Element, h, Method} from '@stencil/core';\nimport {TokenScriptEngine} from \"../../../../engine-js/src/Engine\";\n\nimport {Client} from \"@tokenscript/token-negotiator\";\nimport \"@tokenscript/token-negotiator/dist/theme/style.css\";\n\nimport {EthersAdapter} from \"../../../../engine-js/src/wallet/EthersAdapter\";\nimport {TokenScript} from \"../../../../engine-js/src/TokenScript\";\nimport {CHAIN_CONFIG} from \"../../integration/constants\";\nimport {IWalletAdapter} from \"../../../../engine-js/src/wallet/IWalletAdapter\";\n\ninterface TabInstance {\n\ttabHeader: HTMLTabHeaderItemElement\n\tcontent: HTMLViewerTabElement\n}\n\nexport type TokenScriptSource = \"resolve\" | \"file\" | \"url\";\n\n@Component({\n\ttag: 'app-root',\n\tstyleUrl: 'app.css',\n\tshadow: false,\n})\nexport class AppRoot {\n\n\tasync getWalletAdapter(): Promise<IWalletAdapter> {\n\n\t\treturn new EthersAdapter(async () => {\n\n\t\t\t// TODO: replace with modal wallet selector\n\t\t\tvar negotiator: Client = new Client({\n\t\t\t\t'type': 'active',\n\t\t\t\t'issuers': [],\n\t\t\t\t'uiOptions': {\n\t\t\t\t\t'containerElement': '#tn-main',\n\t\t\t\t\t'openingHeading': 'Connect your wallet to load this TokenScripts tokens.'\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tconst walletProvider = await negotiator.getWalletProvider();\n\n\t\t\tawait walletProvider.loadConnections();\n\n\t\t\tif (walletProvider.getConnectedWalletData().length === 0) {\n\t\t\t\treturn new Promise((resolve, reject) => {\n\n\t\t\t\t\tnegotiator.createUiInstance();\n\t\t\t\t\tnegotiator.getUi().initialize();\n\t\t\t\t\tnegotiator.getUi().updateUI(\"wallet\", {\n\t\t\t\t\t\tconnectCallback: () => {\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\tresolve(walletProvider.getConnectedWalletData()[0].provider);\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn walletProvider.getConnectedWalletData()[0].provider;\n\t\t}, CHAIN_CONFIG);\n\t}\n\n\ttsEngine = new TokenScriptEngine(this.getWalletAdapter, null, {\n\t\tipfsGateway: \"https://smart-token-labs-demo-server.mypinata.cloud/ipfs/\",\n\t});\n\n\t@Element() host: HTMLElement;\n\n\ttabs: {[id: string]: TabInstance} = {};\n\n\t@Method()\n\tasync showTab(id: string){\n\n\t\tif (id !== \"start-tab\" && !this.tabs[id])\n\t\t\treturn;\n\n\t\tlet children = this.host.querySelector(\"#tab-header\").children;\n\n\t\tfor (let i=0; i < children.length; i++)\n\t\t\tchildren[i].classList.remove(\"active\");\n\n\t\tchildren = this.host.querySelector(\"#tab-content\").children;\n\n\t\tfor (let i=0; i < children.length; i++)\n\t\t\tchildren[i].classList.remove(\"active\");\n\n\t\tif (id === \"start-tab\"){\n\t\t\tthis.host.querySelector(\"#start-tab-header\").classList.add(\"active\");\n\t\t\tthis.host.querySelector(\"#start-tab\").classList.add(\"active\");\n\t\t} else {\n\t\t\tthis.tabs[id].tabHeader.classList.add(\"active\");\n\t\t\tthis.tabs[id].content.classList.add(\"active\");\n\t\t}\n\t}\n\n\tprivate addTab(tokenScript: TokenScript, emulator: string){\n\n\t\tconst id = Date.now().toString();\n\n\t\tconst query = new URLSearchParams(document.location.search);\n\t\tconst component = query.has(\"debugTab\") ? \"debug-viewer-tab\" : \"viewer-tab\";\n\n\t\tconst tab = this.tabs[id] = {\n\t\t\ttabHeader: document.createElement(\"tab-header-item\", {is: \"tab-header-item\"}) as HTMLTabHeaderItemElement,\n\t\t\tcontent: document.createElement(component, {is: component}) as HTMLViewerTabElement\n\t\t};\n\n\t\ttab.tabHeader.app = this;\n\t\ttab.tabHeader.tabId = id;\n\t\ttab.tabHeader.tabTitle = tokenScript.getLabel();\n\n\t\ttab.content.app = this;\n\t\ttab.content.tabId = id;\n\t\ttab.content.tokenScript = tokenScript;\n\n\t\tthis.host.querySelector(\"#tab-header\").appendChild(tab.tabHeader);\n\t\tthis.host.querySelector(\"#tab-content\").appendChild(tab.content);\n\n\t\tthis.showTab(id);\n\n\t\tif (emulator)\n\t\t\tthis.connectEmulatorSocket(id, emulator);\n\t}\n\n\t@Method()\n\tasync closeTab(id: string){\n\n\t\tif (!this.tabs[id])\n\t\t\treturn;\n\n\t\tconst tab = this.tabs[id];\n\n\t\ttab.tabHeader.remove();\n\t\ttab.content.remove();\n\t\tdelete this.tabs[id];\n\n\t\tconst tabIds = Object.keys(this.tabs);\n\n\t\tawait this.showTab(tabIds.length === 0 ? \"start-tab\" : tabIds[tabIds.length - 1]);\n\t}\n\n\tshowTsLoader(){\n\t\tdocument.getElementById(\"ts-loader\").style.display = \"flex\";\n\t}\n\n\thideTsLoader(){\n\t\tdocument.getElementById(\"ts-loader\").style.display = \"none\";\n\t}\n\n\t@Method()\n\tasync loadTokenscript(source: TokenScriptSource, tsId?: string): Promise<TokenScript> {\n\n\t\tswitch(source){\n\t\t\tcase \"resolve\":\n\t\t\t\treturn await this.tsEngine.getTokenScript(tsId);\n\t\t\tcase \"file\":\n\t\t\t\treturn this.loadTokenScriptFromFile();\n\t\t\tcase \"url\":\n\t\t\t\treturn await this.tsEngine.getTokenScriptFromUrl(tsId);\n\t\t}\n\t}\n\n\tasync loadTokenScriptFromFile(): Promise<TokenScript> {\n\n\t\treturn new Promise((resolve, reject) => {\n\n\t\t\tconst file = (document.getElementById(\"ts-file\") as HTMLInputElement).files[0];\n\n\t\t\tif (file) {\n\t\t\t\tthis.showTsLoader();\n\n\t\t\t\tconst reader = new FileReader();\n\t\t\t\treader.onload = async function (evt) {\n\t\t\t\t\tif (typeof evt.target.result === \"string\") {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresolve(await this.tsEngine.loadTokenScript(evt.target.result));\n\t\t\t\t\t\t} catch (e){\n\t\t\t\t\t\t\treject(\"Failed to load TokenScript: \" + e.message);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}.bind(this);\n\n\t\t\t\treader.onerror = function (err) {\n\t\t\t\t\treject(\"Failed to load file: \" + err.message);\n\t\t\t\t}.bind(this);\n\n\t\t\t\treader.readAsText(file, \"UTF-8\");\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve(null);\n\t\t});\n\t}\n\n\t@Method()\n\tasync openTokenScriptTab(source: TokenScriptSource, tsId?: string, emulator?: string){\n\n\t\tthis.showTsLoader();\n\n\t\ttry {\n\t\t\tconst tokenScript = await this.loadTokenscript(source, tsId)\n\t\t\tthis.addTab(tokenScript, emulator);\n\t\t} catch (e){\n\t\t\tconsole.error(e);\n\t\t\talert(\"Failed to load TokenScript: \" + e.message);\n\t\t}\n\n\t\tthis.hideTsLoader();\n\t}\n\n\tasync connectEmulatorSocket(tabId: string, host: string){\n\n\t\ttry {\n\t\t\tconst webSocket = new WebSocket(\"ws://\" + new URL(host).host + \"/ws\");\n\n\t\t\twebSocket.onopen = (event) => {\n\t\t\t\tconsole.log(\"connected: \", event.type);\n\t\t\t\twebSocket.send(\"Websocket client connected!\");\n\t\t\t};\n\n\t\t\twebSocket.onmessage = async (event) => {\n\n\t\t\t\tif (event.data != \"BUILD_UPDATED\")\n\t\t\t\t\treturn;\n\n\t\t\t\t// TODO: Implement build started and build error events\n\t\t\t\ttry {\n\t\t\t\t\tthis.tabs[tabId].content.tokenScript = await this.loadTokenscript(\"url\", host + \"/tokenscript.tsml\");\n\t\t\t\t} catch (e){\n\t\t\t\t\tconsole.error(e);\n\t\t\t\t\talert(\"Failed to reload TokenScript changes\");\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (e){\n\t\t\tconsole.error(e);\n\t\t}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div class=\"app-container\">\n\t\t\t\t<header>\n\t\t\t\t\t<img class=\"header-icon\" alt=\"TokenScript icon\" src=\"assets/icon/icon.png\"/>\n\t\t\t\t\t<h1>TokenScript Viewer</h1>\n\t\t\t\t</header>\n\n\t\t\t\t<main>\n\t\t\t\t\t<div id=\"tab-header\">\n\t\t\t\t\t\t<tab-header-item id=\"start-tab-header\" class=\"active\" tabId=\"start-tab\" app={this} tabTitle=\"Start\" closable={false} />\n\t\t\t\t\t</div>\n\t\t\t\t\t<div id=\"tab-content\">\n\t\t\t\t\t\t<start-tab id=\"start-tab\" tabId=\"start-tab\" class=\"active\" app={this} />\n\t\t\t\t\t</div>\n\t\t\t\t</main>\n\n\t\t\t\t<div id=\"ts-loader\">\n\t\t\t\t\t<loading-spinner/>\n\t\t\t\t</div>\n\n\t\t\t\t<div id=\"tn-main\" class=\"overlay-tn\"></div>\n\t\t\t</div>\n\t\t);\n\t}\n}\n","\n.lds-ring {\n\tdisplay: inline-block;\n\tposition: relative;\n\twidth: 80px;\n\theight: 80px;\n}\n.lds-ring div {\n\tbox-sizing: border-box;\n\tdisplay: block;\n\tposition: absolute;\n\twidth: 64px;\n\theight: 64px;\n\tmargin: 8px;\n\tborder: 8px solid;\n\tborder-radius: 50%;\n\tanimation: lds-ring 1.2s cubic-bezier(0.5, 0, 0.5, 1) infinite;\n}\n\n.small {\n\theight: 50px;\n\tmargin-top: -10px;\n\ttransform: scale(0.5);\n}\n\n.lds-ring div:nth-child(1) {\n\tanimation-delay: -0.45s;\n}\n.lds-ring div:nth-child(2) {\n\tanimation-delay: -0.3s;\n}\n.lds-ring div:nth-child(3) {\n\tanimation-delay: -0.15s;\n}\n@keyframes lds-ring {\n\t0% {\n\t\ttransform: rotate(0deg);\n\t}\n\t100% {\n\t\ttransform: rotate(360deg);\n\t}\n}\n","import {Component, h, Prop} from \"@stencil/core\";\n\n@Component({\n\ttag: 'loading-spinner',\n\tstyleUrl: 'loading-spinner.css',\n\tshadow: true,\n})\nexport class LoadingSpinner {\n\n\t@Prop()\n\tcolor = \"#fff\";\n\n\t@Prop()\n\tsize = \"large\";\n\n\trender() {\n\t\tconst color = this.color + \" transparent transparent transparent\";\n\n\t\treturn (\n\t\t\t<div class={\"lds-ring \" + (this.size === \"small\" ? \"small\" : \"\")}>\n\t\t\t\t<div style={{borderColor: color}}></div>\n\t\t\t\t<div style={{borderColor: color}}></div>\n\t\t\t\t<div style={{borderColor: color}}></div>\n\t\t\t\t<div style={{borderColor: color}}></div>\n\t\t\t</div>\n\t\t)\n\t}\n}\n","\n#start-tab {\n\tpadding: 20px;\n}\n\n.start-section {\n\tpadding: 15px 0;\n}\n","import {Component, Element, h, Prop} from \"@stencil/core\";\nimport {Components} from \"../../components\";\nimport AppRoot = Components.AppRoot;\n\n\n@Component({\n\ttag: 'start-tab',\n\tstyleUrl: 'start-tab.css',\n\tshadow: false,\n})\nexport class StartTab {\n\n\t@Prop() app: AppRoot;\n\t@Prop() tabId: string;\n\n\tprocessUrlLoad(){\n\n\t\tconsole.log(\"loading from URL: \" + document.location.hash);\n\t\tconst queryStr = document.location.search.substring(1);\n\n\t\tif (!queryStr)\n\t\t\treturn false;\n\n\t\tconst query = new URLSearchParams(queryStr);\n\n\t\tif (query.has(\"emulator\")) {\n\n\t\t\tconsole.log(\"Emulator mode enabled!\");\n\n\t\t\tlet tsHost = query.get(\"emulator\");\n\n\t\t\tif (tsHost) {\n\t\t\t\ttsHost = new URL(tsHost).origin;\n\t\t\t\tconsole.log(\"Using remote host for tokenscript dev server: \" + tsHost);\n\t\t\t} else {\n\t\t\t\ttsHost = document.location.origin;\n\t\t\t}\n\n\t\t\tthis.app.openTokenScriptTab(\"url\", tsHost + \"/tokenscript.tsml\", tsHost);\n\t\t\t//connectSocket(tsHost);\n\n\t\t\treturn true;\n\n\t\t} else if (query.has(\"tokenscriptUrl\")){\n\n\t\t\tthis.app.openTokenScriptTab(\"url\", query.get(\"tokenscriptUrl\"));\n\n\t\t\treturn true;\n\t\t} else if (query.has(\"chain\") && query.has(\"contract\")){\n\n\t\t\tconst tsId = query.get(\"chain\") + \"-\" + query.get(\"contract\");\n\n\t\t\tthis.app.openTokenScriptTab(\"resolve\", tsId);\n\n\t\t\treturn true;\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tcomponentDidLoad(){\n\n\t\tconst tsFile = document.getElementById(\"ts-file\") as HTMLInputElement;\n\n\t\tif (this.processUrlLoad()) {\n\t\t\ttsFile.value = \"\";\n\t\t} else {\n\t\t\tif (tsFile.value)\n\t\t\t\tthis.app.openTokenScriptTab(\"file\");\n\t\t}\n\t}\n\n\trender() {\n\t\treturn (\n\t\t\t<div>\n\t\t\t\t<div class=\"start-section\">\n\t\t\t\t\t<h3>Load with contract ID</h3>\n\t\t\t\t\t<label htmlFor=\"ts-id\">Tokenscript ID: </label>\n\t\t\t\t\t<input style={{marginRight: \"15px\"}} id=\"ts-id\" type=\"text\" value=\"0xd915c8ad3241f459a45adcbbf8af42caa561a154\"/>\n\t\t\t\t\t<label htmlFor=\"ts-chain\">Chain: </label>\n\t\t\t\t\t<select id=\"ts-chain\" style={{marginRight: \"15px\"}}>\n\t\t\t\t\t\t<option value=\"1\">Ethereum Mainnet</option>\n\t\t\t\t\t\t<option value=\"5\">Goerli Testnet</option>\n\t\t\t\t\t\t<option value=\"8217\" selected>Klaytn Mainnet</option>\n\t\t\t\t\t</select>\n\t\t\t\t\t<button id=\"ts-resolve-btn\" type=\"button\" onClick={() => {\n\t\t\t\t\t\tconst tsId = (document.getElementById('ts-chain') as HTMLSelectElement).value + \"-\" +\n\t\t\t\t\t\t\t\t\t\t(document.getElementById('ts-id') as HTMLInputElement).value;\n\t\t\t\t\t\tthis.app.openTokenScriptTab(\"resolve\", tsId);\n\t\t\t\t\t}}>Resolve</button>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"start-section\">\n\t\t\t\t\t<h3>Load from URL</h3>\n\t\t\t\t\t<label htmlFor=\"ts-url\">URL: </label>\n\t\t\t\t\t<input id=\"ts-url\" type=\"text\" style={{marginRight: \"15px\"}} />\n\t\t\t\t\t<button id=\"ts-load-url-btn\" type=\"button\" onClick={() => {\n\t\t\t\t\t\tconst url = (document.getElementById('ts-url') as HTMLSelectElement).value;\n\t\t\t\t\t\tthis.app.openTokenScriptTab(\"url\", url);\n\t\t\t\t\t}}>Load</button>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"start-section\">\n\t\t\t\t\t<h3>Load from file</h3>\n\t\t\t\t\t<label htmlFor=\"ts-file\">Load XML: </label><input id=\"ts-file\" type=\"file\" accept=\".xml,.tsml,text/xml\" onChange={() => {\n\t\t\t\t\t\tthis.app.openTokenScriptTab(\"file\")\n\t\t\t\t\t}}/>\n\t\t\t\t</div>\n\t\t\t\t<div class=\"start-section\">\n\t\t\t\t\t<h3>Load Predefined TokenScripts </h3>\n\t\t\t\t\t<label htmlFor=\"ts-predefined\"></label>\n\t\t\t\t\t<select id=\"ts-predefined\" style={{marginRight: \"15px\"}}>\n\t\t\t\t\t\t<option value=\"DAI\">DAI</option>\n\t\t\t\t\t\t<option value=\"ENS\">ENS</option>\n\t\t\t\t\t</select>\n\t\t\t\t\t<button id=\"ts-load-predefined-btn\" type=\"button\" onClick={() => {\n\t\t\t\t\t\tconst tsId = (document.getElementById('ts-predefined') as HTMLSelectElement).value;\n\t\t\t\t\t\tthis.app.openTokenScriptTab(\"resolve\", tsId);\n\t\t\t\t\t}}>Load</button>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t);\n\t}\n}\n","\n:host {\n\tbackground: none;\n\tborder: none;\n\tborder-bottom: 2px solid white;\n\tborder-radius: 0;\n\tmargin: 0;\n\tcolor: #ccc;\n\tmax-width: 200px;\n\tflex-grow: 1;\n\talign-content: center;\n\tjustify-content: center;\n\tpadding: 5px 10px;\n\tbox-sizing: border-box;\n\tcursor: pointer !important;\n}\n\n:host > .tab-button {\n\theight: 40px;\n\tdisplay: flex;\n\tflex-direction: row;\n\talign-items: center;\n}\n\n.tab-button span {\n\tflex-grow: 1;\n\tdisplay: inline-block;\n\tcolor: inherit;\n\tfont-weight: bold;\n\tmargin-top: 4px;\n\ttext-overflow: ellipsis ellipsis;\n\toverflow: hidden;\n\twhite-space: nowrap;\n}\n\n.tab-button button {\n\tbackground: #fff;\n\tborder: #414141 1px solid;\n\tborder-radius: 5px;\n\tpadding: 4px 6px;\n\tfont-weight: bold;\n\tcursor: pointer !important;\n}\n\n.tab-button button:hover {\n\tbackground: #a6a6a6 !important;\n\tborder-color: #a6a6a6 !important;\n}\n\n:host(.active) {\n\tborder-bottom: 2px solid teal;\n\tcolor: #333 !important;\n}\n","import {Component, h, Prop, Element} from \"@stencil/core\";\nimport {Components} from \"../../components\";\nimport AppRoot = Components.AppRoot;\n\n@Component({\n\ttag: 'tab-header-item',\n\tstyleUrl: 'tab-header-item.css',\n\tshadow: true,\n})\nexport class StartTab {\n\n\t@Prop() app: AppRoot;\n\t@Prop() tabId: string;\n\t@Prop() tabTitle: string;\n\t@Prop() closable = true;\n\n\trender() {\n\t\treturn (\n\t\t\t<div class=\"tab-button\" onClick={() => this.app.showTab(this.tabId) } title={this.tabTitle}>\n\t\t\t\t<span>{this.tabTitle}</span>\n\t\t\t\t{this.closable === true ? <button onClick={() => this.app.closeTab(this.tabId) }>X</button> : ''}\n\t\t\t</div>\n\t\t);\n\t}\n}\n"],"mappings":"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"}